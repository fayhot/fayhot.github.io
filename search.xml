<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11 Features</title>
    <url>/program/C++11-Features.html</url>
    <content><![CDATA[<h2 id="C-11-新增特性"><a href="#C-11-新增特性" class="headerlink" title="C++11 新增特性"></a>C++11 新增特性</h2><h3 id="空指针-nullptr"><a href="#空指针-nullptr" class="headerlink" title="空指针 nullptr"></a>空指针 nullptr</h3><p>nullptr 出现的目的是为了替代 NULL。</p>
<p>C++11之前官方标准对NULL、0没有严格的区分，更多的是取决于不同编译器的选择，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。</p>
<p>C++ 不允许直接将 void * 隐式转换到其他类型，但如果 NULL 被定义为 ((void*)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0。</p>
<p>这显然会产生问题，导致了 C++ 中重载特性会发生混乱，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span></pre></td></tr></table></figure>
<p>如果 NULL 又被定义为了 0 那么 foo(NULL)将会去调用 foo(int)，从而导致代码违反直观。</p>
<blockquote>
<p>为了解决这个问题，C++11 引入了 <strong>nullptr</strong> 关键字，专门用来区分<strong>空指针、0</strong>。<br>nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等运算。</p>
</blockquote>
<p>当需要使用 NULL 时候，养成直接使用 nullptr 的习惯</p>
<a id="more"></a>
<h3 id="类型推导-auto、decltype"><a href="#类型推导-auto、decltype" class="headerlink" title="类型推导 auto、decltype"></a>类型推导 auto、decltype</h3><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>c++11之前，auto、register作为存储类型的指示符存在，一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。c++11标准中 register 被弃用，auto 语义重定义。</p>
<p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//without auto</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = vec.cbegin();  itr != vec.cend();  ++ itr)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> itr = vec.cbegin(); itr != vec.cend(); ++itr);</span></pre></td></tr></table></figure>

<p>auto <strong>不能用于函数传参</strong>，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span></span>;</span></pre></td></tr></table></figure>

<p>auto <strong>不能用于推导数组类型</strong></p>
<h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译器分析表达式并得到它的类型，却不实际计算表达式的值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) z;</span></pre></td></tr></table></figure>

<h4 id="拖尾返回类型、auto-与-decltype-配合"><a href="#拖尾返回类型、auto-与-decltype-配合" class="headerlink" title="拖尾返回类型、auto 与 decltype 配合"></a>拖尾返回类型、auto 与 decltype 配合</h4><p>auto 推导函数的返回类型。考虑这样一个例子加法函数的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//before c++11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型<br>C++11 中这个问题得到解决。但不是通过下面这种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y);</span></pre></td></tr></table></figure>
<p>这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做<strong>拖尾返回类型</strong>（<strong>trailing return type</strong>），利用 auto 关键字将返回类型后置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>C++14 甚至可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="区间迭代-Iterator-by-for"><a href="#区间迭代-Iterator-by-for" class="headerlink" title="区间迭代 Iterator by for"></a>区间迭代 Iterator by for</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">5</span>, <span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = arr.begin(); i != arr.end(); ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//==&gt; convert to </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="初始化列表-initialization-list"><a href="#初始化列表-initialization-list" class="headerlink" title="初始化列表 initialization list"></a>初始化列表 initialization list</h3><p>C++11 提供了统一的语法来初始化任意的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">int</span> _a, <span class="keyword">float</span> _b): a(_a), b(_b) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">A a &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;;    <span class="comment">// 统一的初始化语法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">B b &#123;<span class="number">2</span>, <span class="number">2.2</span>&#125;;</span></pre></td></tr></table></figure>

<p>C++11 初始化列表的概念也绑定到了类型上，即 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span></pre></td></tr></table></figure>

<h3 id="模板增强"><a href="#模板增强" class="headerlink" title="模板增强"></a>模板增强</h3><h4 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h4><p>C++11之前，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。</p>
<p>C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;            <span class="comment">// 强行实例化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;  <span class="comment">// 不在该编译文件中实例化模板</span></span></pre></td></tr></table></figure>

<h4 id="尖括号-gt"><a href="#尖括号-gt" class="headerlink" title="尖括号 &gt;"></a>尖括号 &gt;</h4><p>C++11 之前，&gt;&gt; 一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; wow;</span></pre></td></tr></table></figure>
<p>这在传统C++编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</p>
<h4 id="类型别名模板-using"><a href="#类型别名模板-using" class="headerlink" title="类型别名模板 using"></a>类型别名模板 using</h4><p>C++11之前，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    U b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SuckType():a(value),b(value)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span></pre></td></tr></table></figure>

<p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">emplate &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span></pre></td></tr></table></figure>

<h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>我们定义一个加法函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>要使用 add，就必须每次都指定其模板参数的类型。<br>在 C++11 中提供了一种便利，可以指定模板的默认参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="构造函数-Constructor-Delegate"><a href="#构造函数-Constructor-Delegate" class="headerlink" title="构造函数 Constructor Delegate"></a>构造函数 Constructor Delegate</h3><h4 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h4><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        value2 = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h4><p>继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。<br>假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">int</span> i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等系列的构造函数版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等好多个和基类构造函数对应的构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>C++11的继承构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">int</span> i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等系列的构造函数版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> A::A;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//关于基类各构造函数的继承一句话搞定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;；</span></pre></td></tr></table></figure>
<p>如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p>
<p>Lambda 表达式的基本语法如下：</p>
<blockquote>
<p>[ caputrue ] ( params ) opt -&gt; ret { body; };</p>
</blockquote>
<ol>
<li>capture是捕获列表；</li>
<li>params是参数表；</li>
<li>opt是函数选项，mutable,exception,attribute<ol>
<li>mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。</li>
<li>exception说明lambda表达式是否抛出异常以及何种异常。</li>
<li>attribute用来声明属性。</li>
</ol>
</li>
<li>ret是返回值类型（拖尾返回类型）。</li>
<li>body是函数体。</li>
</ol>
<p><strong>捕获列表：</strong>lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<blockquote>
<ol>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意<strong>值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝</strong>。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</li>
<li>[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量。</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。<strong>捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</strong></li>
</ol>
</blockquote>
<p><strong>值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝</strong><br><strong>捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=] &#123; <span class="keyword">return</span> a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a+=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//输出0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [&amp;a] &#123; <span class="keyword">return</span> a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a+=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt;<span class="built_in">endl</span>;       <span class="comment">//输出1</span></span></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> i_ = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x1 = [] &#123; <span class="keyword">return</span> i_; &#125;;                   <span class="comment">//error,没有捕获外部变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x2 = [=] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;          <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x3 = [&amp;] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_; &#125;;               <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;       <span class="comment">//error,没有捕获x,y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;     <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_++; &#125;;             <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span> , b=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [] &#123; <span class="keyword">return</span> a; &#125;;                         <span class="comment">//error,没有捕获外部变量    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = [&amp;] &#123; <span class="keyword">return</span> a++ &#125;;                      <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f3 = [=] &#123; <span class="keyword">return</span> a; &#125;;                        <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;;                       <span class="comment">//error,a是以复制方式捕获的，无法修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f5 = [a] &#123; <span class="keyword">return</span> a+b; &#125;;                      <span class="comment">//error,没有捕获变量b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span></pre></td></tr></table></figure>

<p>注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去<strong>修改按值捕获的外部变量，需要显示指明lambda表达式为mutable</strong>。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。<strong>mutable的作用，就在于取消operator()的const</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [=] &#123; <span class="keyword">return</span> a++; &#125;;                <span class="comment">//error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = [=] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;       <span class="comment">//OK</span></span></pre></td></tr></table></figure>

<p>lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为<strong>闭包类型（closure type）</strong>。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个<strong>右值</strong>。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<p>lambda表达式是不能被赋值的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = [] &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = [] &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = b;   <span class="comment">// 非法，lambda无法赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = a;   <span class="comment">// 合法，生成一个副本</span></span></pre></td></tr></table></figure>

<p>闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以<strong>用一个lambda表达式去初始化另外一个lambda表达式而产生副本</strong>。</p>
<p>在多种捕获方式中，<strong>最好不要使用[=]和[&amp;]默认捕获所有变量</strong>。</p>
<p>默认引用捕获所有变量，你有很大可能会出现<strong>悬挂引用（Dangling references）</strong>，因为引用捕获不会延长引用的变量的生命周期：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; add_x(<span class="keyword">int</span> x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [&amp;](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> x + a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Filter(<span class="keyword">int</span> divisorVal):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        divisor&#123;divisorVal&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> divisor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [divisor](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>原代码中，lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % <span class="keyword">this</span>-&gt;divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，<strong>采用默认值捕捉所有变量仍然是不安全的</strong>，主要是由于<strong>指针变量的复制，实际上还是按引用传值</strong>。</p>
<p>lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; wrapper = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span></pre></td></tr></table></figure>

<p>lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p>
<p>最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nt value = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(v.beigin(), v.end(), [value](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x &gt; value; &#125;);</span></pre></td></tr></table></figure>
<p>再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::generate(v.begin(), v.end(), [&amp;a, &amp;b] &#123; <span class="keyword">int</span> value = b; b = b + a; a = value; <span class="keyword">return</span> value; &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 此时v &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;</span></span></pre></td></tr></table></figure>
<p>当需要遍历容器并对每个元素进行操作时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> even_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), [&amp;even_count](<span class="keyword">int</span> val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!(val &amp; <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++ even_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number of even is "</span> &lt;&lt; even_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。</p>
<h3 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h3><h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h4><p>std::array 保存在<strong>栈内存</strong>中，相比<strong>堆内存</strong>中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</p>
<p>std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 非法, 数组大小参数必须是常量表达式</span></span></pre></td></tr></table></figure>
<p>当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span> 4&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// C 风格接口传参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// foo(arr, arr.size());           // 非法, 无法隐式转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">foo(&amp;arr[<span class="number">0</span>], arr.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo(arr.data(), arr.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 `std::sort`</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(arr.begin(), arr.end());</span></pre></td></tr></table></figure>

<h4 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h4><p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。<br>和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p>
<h4 id="unorder-container"><a href="#unorder-container" class="headerlink" title="unorder container"></a>unorder container</h4><p>C++11 引入了两组无序容器：</p>
<ul>
<li>std::unordered_map、std::unordered_multimap</li>
<li>std::unordered_set、std::unordered_multiset</li>
</ul>
<p>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</p>
<h4 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h4><p>元组的使用有三个核心的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::make_tuple <span class="comment">// 构造元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::get <span class="comment">//获得元组某个位置的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tie <span class="comment">//元组拆包</span></span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, <span class="string">'A'</span>, <span class="string">"张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, <span class="string">'C'</span>, <span class="string">"李四"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, <span class="string">'D'</span>, <span class="string">"王五"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, <span class="string">'D'</span>, <span class="string">"null"</span>);   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: 0, "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"GPA: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"成绩: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> gpa;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 元组进行拆包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: 1, "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"GPA: "</span> &lt;&lt; gpa &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"成绩: "</span> &lt;&lt; grade &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>合并两个元组，可以通过 std::tuple_cat 来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p>
<ol>
<li>检查一个串是否包含某种形式的子串；</li>
<li>将匹配的子串替换；</li>
<li>从某个串中取出符合条件的子串。</li>
</ol>
<p>C++11 提供的正则表达式库操作 <strong>std::string</strong> 对象，对模式 <strong>std::regex</strong> (本质是 std::basic_regex)进行初始化，通过 <strong>std::regex_match</strong>进行匹配，从而产生 <strong>std::smatch</strong>（本质是 std::match_results 对象）。</p>
<p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式：</p>
<blockquote>
<p>[a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个及以上小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 转义后则表示匹配字符 . ，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的所要匹配的内容就是文件名为纯小写字母的文本文件。</p>
</blockquote>
<p>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"test"</span>, <span class="string">"a0.txt"</span>, <span class="string">"AAA.txt"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在 C++ 中 `\` 会被作为字符串内的转义符，为使 `\.` 作为正则表达式传递进去生效，需要对 `\` 进行二次转义，从而有 `\\.`</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">regex <span class="title">txt_regex</span><span class="params">(<span class="string">"[a-z]+\\.txt"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>另一种常用的形式就是依次传入 std::string、std::smatch、std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">regex <span class="title">base_regex</span><span class="params">(<span class="string">"([a-z]+)\\.txt"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::smatch base_match;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::regex_match(fname, base_match, base_regex)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sub_match 的第一个元素匹配整个字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sub_match 的第二个元素匹配了第一个括号表达式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (base_match.size() == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> base = base_match[<span class="number">1</span>].str();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sub-match[0]: "</span> &lt;&lt; base_match[<span class="number">0</span>].str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">" sub-match[1]: "</span> &lt;&lt; base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>以上两个代码段的输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo.txt: <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">bar.txt: <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a0.txt: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">AAA.txt: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sub-match[<span class="number">0</span>]: foo.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo.txt sub-match[<span class="number">1</span>]: foo</span></pre></td></tr><tr><td class="code"><pre><span class="line">sub-match[<span class="number">0</span>]: bar.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">bar.txt sub-match[<span class="number">1</span>]: bar</span></pre></td></tr></table></figure>

<h3 id="语言级线程支持"><a href="#语言级线程支持" class="headerlink" title="语言级线程支持"></a>语言级线程支持</h3><ul>
<li>std::thread</li>
<li>std::mutex/std::unique_lock</li>
<li>std::future/std::packaged_task</li>
<li>std::condition_variable</li>
</ul>
<p>代码编译需要使用 -pthread 选项</p>
<h3 id="右值引用和move语义"><a href="#右值引用和move语义" class="headerlink" title="右值引用和move语义"></a>右值引用和move语义</h3><p>以字符串处理为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">a</span><span class="params">(x)</span></span>;                                    <span class="comment">// line 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">b</span><span class="params">(x + y)</span></span>;                                    <span class="comment">// line 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">c</span><span class="params">(some_function_returning_a_string())</span></span>;       <span class="comment">// line 3</span></span></pre></td></tr></table></figure>
<p>如果使用以下拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; that)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(that.data) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memcpy</span>(data, that.data, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>以上3行中，只有第一行(line 1)的x深度拷贝是有必要的，因为我们可能会在后边用到x，x是一个左值(lvalues)。</p>
<p>第二行和第三行的参数则是右值，因为表达式产生的string对象是匿名对象，之后没有办法再使用了。</p>
<p>C++ 11引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; that)   <span class="comment">// string&amp;&amp; is an rvalue reference to a string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	data = that.data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	that.data = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我们<strong>没有深度拷贝堆内存</strong>中的数据，而是仅仅<strong>复制了指针，并把源对象的指针置空</strong>。事实上，我们“偷取”了属于源对象的内存数据。由于<strong>源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了</strong>。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做 <strong>转移构造函数（move constructor）</strong>，他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。</p>
<p>有了右值引用，再来看看赋值操作符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">string</span> that)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::swap(data, that.data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意到我们是直接对参数that传值，所以that会像其他任何对象一样被初始化，那么确切的说，that是怎样被初始化的呢？对于<strong>C++ 98，是复制构造函数</strong>，但是<strong>对于C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择</strong>。</p>
<p>如果是a=b，这样就会调用复制构造函数来初始化that（因为b是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。</p>
<p>如果是a = x + y，这样就会调用转移构造函数来初始化that（因为x+y是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为x+y是右值，再次，从右值指向的对象中转移是没有问题的。</p>
<p>总结：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。</p>
<p>下面我们进一步讨论<strong>右值引用、move语义</strong>。</p>
<p>C++98标准库中提供了一种唯一拥有性的智能指针std::auto_ptr，该类型在C++11中已被废弃，因为其“复制”行为是危险的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; b(a);</span></pre></td></tr></table></figure>
<p>注意b是怎样使用a进行初始化的，它不复制triangle，而是把triangle的所有权从a传递给了b，也可以说成“a 被转移进了b”或者“triangle被从a转移到了b”。</p>
<p>auto_ptr 的复制构造函数可能看起来像这样（简化）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&amp; source)   <span class="comment">// note the missing const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p = source.p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	source.p = <span class="number">0</span>;   <span class="comment">// now the source no longer owns the object</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>auto_ptr 的危险之处在于看上去应该是复制，但实际上确是转移。调用被转移过的auto_ptr 的成员函数将会导致不可预知的后果。所以你必须非常谨慎的使用auto_ptr ，如果他被转移过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; make_triangle()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">auto_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; c(make_triangle());      <span class="comment">// move temporary into c</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> area = make_triangle()-&gt;area();   <span class="comment">// perfectly safe</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);    <span class="comment">// create triangle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; b(a);               <span class="comment">// move a into b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> area = a-&gt;area();                <span class="comment">// undefined behavior</span></span></pre></td></tr></table></figure>

<p>然，在持有auto_ptr 对象的a表达式和持有调用函数返回的auto_ptr值类型的make_triangle()表达式之间一定有一些潜在的区别，每调用一次后者就会创建一个新的auto_ptr对象。这里a 其实就是一个左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。</p>
<p>转移像a这样的左值是非常危险的，因为我们可能调用a的成员函数，这会导致不可预知的行为。另一方面，转移像make_triangle()这样的右值却是非常安全的，因为复制构造函数之后，我们不能再使用这个临时对象了，因为这个转移后的临时对象会在下一行之前销毁掉。</p>
<p>我们现在知道转移左值是十分危险的，但是转移右值却是很安全的。如果C++能从语言级别支持区分左值和右值参数，我就可以完全杜绝对左值转移，或者把转移左值在调用的时候暴露出来，以使我们不会不经意的转移左值。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>C++ 11对这个问题的答案是<strong>右值引用</strong>。</p>
<p>右值引用是针对右值的新的引用类型，语法是X&amp;&amp;。以前的老的引用类型X&amp; 现在被称作左值引用。</p>
<p>使用右值引用X&amp;&amp;作为参数的最有用的函数之一就是转移构造函数X::X(X&amp;&amp; source)，它的主要作用是把源对象的本地资源转移给当前对象。</p>
<p>C++ 11中，std::auto_ptr&lt; T &gt;已经被std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用。</p>
<p>其转移构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; source)   <span class="comment">// note the rvalue reference</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ptr = source.ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    source.ptr = <span class="literal">nullptr</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个转移构造函数跟auto_ptr中复制构造函数做的事情一样，但是它却只能接受右值作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; b(a);                 <span class="comment">// error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; c(make_triangle());       <span class="comment">// okay</span></span></pre></td></tr></table></figure>
<p>第二行不能编译通过，因为a是左值，但是参数unique_ptr&amp;&amp; source只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。<br>第三行编译没有问题，因为make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象c，这正是我们需要的。</p>
<h4 id="转移左值-std-move"><a href="#转移左值-std-move" class="headerlink" title="转移左值 std::move"></a>转移左值 std::move</h4><p>有时候，我们可能想转移左值，也就是说，有时候我们想让编译器把左值当作右值对待，以便能使用转移构造函数，即便这有点不安全。出于这个目的，C++ 11在标准库的头文件&lt; utility &gt;中提供了一个模板函数std::move。</p>
<blockquote>
<p>std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。</p>
</blockquote>
<p>以下是如何正确的转移左值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; b(a);              <span class="comment">// still an error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; c(<span class="built_in">std</span>::move(a));   <span class="comment">// okay</span></span></pre></td></tr></table></figure>
<p><strong>注意</strong>: 第三行之后，a不再拥有Triangle对象。不过这没有关系，因为通过明确的写出std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对a做任何想要做的事情来初始化c；我不再需要a了，对于a，您请自便。</p>
<p>当然，如果你在使用了mova(a)之后，还继续使用a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。</p>
<p>总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">unique_ptr</span>&lt;Shape&gt; member;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Foo(<span class="built_in">unique_ptr</span>&lt;Shape&gt;&amp;&amp; parameter)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    : member(parameter)   <span class="comment">// error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面的parameter，其类型是一个右值引用，只能说明parameter是指向右值的引用，而parameter本身是个左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）</p>
<p>因此以上对parameter的转移是不允许的，需要使用std::move来显示转换成右值</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>左值、右值表达式(LValue-And-RValue Expression)</title>
    <url>/program/lvalue-and-rvalue.html</url>
    <content><![CDATA[<h3 id="L-Value"><a href="#L-Value" class="headerlink" title="L-Value"></a>L-Value</h3><p>Expressions that refer to <strong>memory locations</strong> are called “l-value” expressions. An l-value represents a storage region’s “locator” value, or a “left” value, implying that it can appear on the left of the equal sign (=). L-values are often identifiers.</p>
<p>Expressions referring to <strong>modifiable locations</strong> are called “modifiable l-values.” A modifiable l-value cannot have an array type, an incomplete type, or a type with the <strong>const</strong> attribute. For structures and unions to be modifiable l-values, they must not have any members with the const attribute. The name of the identifier denotes a storage location, while the value of the variable is the value stored at that location.</p>
<p>An identifier is a modifiable l-value if it refers to a memory location and if its type is arithmetic, structure, union, or pointer. For example, if ptr is a pointer to a storage region, then <strong>*ptr</strong> is a modifiable l-value that designates the storage region to which ptr points.</p>
<p>Any of the following C expressions can be l-value expressions:</p>
<blockquote>
<ul>
<li>An identifier of integral, floating, pointer, structure, or union type</li>
<li>A subscript ([ ]) expression that does not evaluate to an array</li>
<li>A member-selection expression (-&gt; or .)</li>
<li>A unary-indirection (*) expression that does not refer to an array</li>
<li>An l-value expression in parentheses</li>
<li>A const object (a nonmodifiable l-value)</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="R-Value"><a href="#R-Value" class="headerlink" title="R-Value"></a>R-Value</h3><p>The term “r-value” is sometimes used to describe the value of an expression and to distinguish it from an l-value. All l-values are r-values but not all r-values are l-values.</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>The terms lvalue and rvalue are not something one runs into often in C/C++ programming, but when one does, it’s usually not immediately clear what they mean. The most common place to run into these terms are in compiler error &amp; warning messages. For example, compiling the following with gcc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>You get:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test.c: In function 'main':</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.c:<span class="number">8</span>:<span class="number">5</span>: error: lvalue required as left operand of assignment</span></pre></td></tr></table></figure>

<p>True, this code is somewhat perverse and not something you’d write, but the error message mentions lvalue, which is not a term one usually finds in C/C++ tutorials. Another example is compiling this code with g++:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Now the error is:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">testcpp.cpp: In function 'int&amp; foo()':</span></pre></td></tr><tr><td class="code"><pre><span class="line">testcpp.cpp:<span class="number">5</span>:<span class="number">12</span>: error: invalid initialization of non-<span class="keyword">const</span> reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">of type 'int&amp;' from an rvalue of type 'int'</span></pre></td></tr></table></figure>

<p>Here again, the error mentions some mysterious rvalue. So what do lvalue and rvalue mean in C and C++? This is what I intend to explore in this article.</p>
<h4 id="A-simple-definition"><a href="#A-simple-definition" class="headerlink" title="A simple definition"></a>A simple definition</h4><p>This section presents an intentionally simplified definition of lvalues and rvalues. The rest of the article will elaborate on this definition.</p>
<blockquote>
<p>An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address).</p>
</blockquote>
<blockquote>
<p>rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.</p>
</blockquote>
<h4 id="Basic-examples"><a href="#Basic-examples" class="headerlink" title="Basic examples"></a>Basic examples</h4><p>The terms as defined above may appear vague, which is why it’s important to see some simple examples right away.<br>Let’s assume we have an integer variable defined and assigned to:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var = <span class="number">4</span>;</span></pre></td></tr></table></figure>

<p>An assignment expects an lvalue as its left operand, and var is an lvalue, because it is an object with an identifiable memory location. On the other hand, the following are invalid:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> = var;       <span class="comment">// ERROR!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>; <span class="comment">// ERROR!</span></span></pre></td></tr></table></figure>

<p>Neither the constant 4, nor the expression var + 1 are lvalues (<strong>which makes them rvalues</strong>). They’re not lvalues because both are temporary results of expressions, which don’t have an identifiable memory location (i.e. they can just reside in some temporary register for the duration of the computation). Therefore, assigning to them makes no semantic sense - there’s nowhere to assign to.</p>
<p>So it should now be clear what the error message in the first code snippet means. foo returns a temporary value which is an rvalue. Attempting to assign to it is an error, so when seeing foo() = 2; the compiler complains that it expected to see an lvalue on the left-hand-side of the assignment statement.</p>
<p>Not all assignments to results of function calls are invalid, however. For example, C++ references make this possible:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalvar = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> globalvar;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Here foo returns a reference, which is an lvalue, so it can be assigned to. Actually, the ability of C++ to return lvalues from functions is important for implementing some overloaded operators. One common example is overloading the brackets operator [] in classes that implement some kind of lookup access. std::map does this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; mymap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mymap[<span class="number">10</span>] = <span class="number">5.6</span>;</span></pre></td></tr></table></figure>

<p>The assignment mymap[10] works because the non-const overload of std::map::operator[] returns a reference that can be assigned to.</p>
<h4 id="Modifiable-lvalues"><a href="#Modifiable-lvalues" class="headerlink" title="Modifiable lvalues"></a>Modifiable lvalues</h4><p>Initially when lvalues were defined for C, it literally meant “values suitable for left-hand-side of assignment”. Later, however, when ISO C added the const keyword, this definition had to be refined. After all:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 'a' is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;           <span class="comment">// but it can't be assigned!</span></span></pre></td></tr></table></figure>

<p>So a further refinement had to be added. Not all lvalues can be assigned to. Those that can are called modifiable lvalues. Formally, the C99 standard defines modifiable lvalues as:</p>
<blockquote>
<p>[…] an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.</p>
</blockquote>
<h4 id="Conversions-between-lvalues-and-rvalues"><a href="#Conversions-between-lvalues-and-rvalues" class="headerlink" title="Conversions between lvalues and rvalues"></a>Conversions between lvalues and rvalues</h4><p>Generally speaking, language constructs operating on object values require rvalues as arguments. For example, the binary addition operator ‘+’ takes two rvalues as arguments and returns an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// + needs rvalues, so a and b are converted to rvalues</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="comment">// and an rvalue is returned</span></span></pre></td></tr></table></figure>

<p>As we’ve seen earlier, a and b are both lvalues. Therefore, in the third line, they undergo an implicit lvalue-to-rvalue conversion. All lvalues that aren’t arrays, functions or of incomplete types can be converted thus to rvalues.</p>
<p>What about the other direction? Can rvalues be converted to lvalues? Of course not! This would violate the very nature of an lvalue according to its definition [1].</p>
<p>This doesn’t mean that lvalues can’t be produced from rvalues by more explicit means. For example, the unary ‘*’ (dereference) operator takes an rvalue argument but produces an lvalue as a result. Consider this valid code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// OK: p + 1 is an rvalue, but *(p + 1) is an lvalue</span></span></pre></td></tr></table></figure>

<p>Conversely, the unary address-of operator ‘&amp;’ takes an lvalue argument and produces an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// ERROR: lvalue required as unary '&amp;' operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// OK: var is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// ERROR: lvalue required as left operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="comment">// of assignment</span></span></pre></td></tr></table></figure>

<p>The ampersand plays another role in C++ - it allows to define reference types. These are called “lvalue references”. Non-const lvalue references cannot be assigned rvalues, since that would require an invalid rvalue-to-lvalue conversion:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; sref = <span class="built_in">std</span>::<span class="built_in">string</span>();  <span class="comment">// ERROR: invalid initialization of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// non-const reference of type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// 'std::string&amp;' from an rvalue of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// type 'std::string'</span></span></pre></td></tr></table></figure>

<p>Constant lvalue references can be assigned rvalues. Since they’re constant, the value can’t be modified through the reference and hence there’s no problem of modifying an rvalue. This makes possible the very common C++ idiom of accepting values by constant references into functions, which avoids unnecessary copying and construction of temporary objects.</p>
<h4 id="CV-qualified-rvalues"><a href="#CV-qualified-rvalues" class="headerlink" title="CV-qualified rvalues"></a>CV-qualified rvalues</h4><p>If we read carefully the portion of the C++ standard discussing lvalue-to-rvalue conversions [2], we notice it says:</p>
<blockquote>
<p>An lvalue (3.10) of a non-function, non-array type T can be converted to an rvalue. […] If T is a non-class type, the type of the rvalue is the cv-unqualified version of T. Otherwise, the type of the rvalue is T.</p>
</blockquote>
<p>What is this “cv-unqualified” thing? CV-qualifier is a term used to describe const and volatile type qualifiers.<br>From section 3.9.3:</p>
<blockquote>
<p>Each type which is a cv-unqualified complete or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type: a const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. […] The cv-qualified or cv-unqualified versions of a type are distinct types; however, they shall have the same representation and alignment requirements (3.9)</p>
</blockquote>
<p>But what has this got to do with rvalues? Well, in C, rvalues never have cv-qualified types. Only lvalues do. In C++, on the other hand, class rvalues can have cv-qualified types, but built-in types (like int) can’t. Consider this example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bar().foo();  <span class="comment">// calls foo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cbar().foo(); <span class="comment">// calls foo const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The second call in main actually calls the foo () const method of A, because the type returned by cbar is const A, which is distinct from A. This is exactly what’s meant by the last sentence in the quote mentioned earlier. Note also that the return value from cbar is an rvalue. So this is an example of a cv-qualified rvalue in action.</p>
<h4 id="Rvalue-references-C-11"><a href="#Rvalue-references-C-11" class="headerlink" title="Rvalue references (C++11)"></a>Rvalue references (C++11)</h4><p>Rvalue references and the related concept of move semantics is one of the most powerful new features the C++11 standard introduces to the language. A full discussion of the feature is way beyond the scope of this humble article [3], but I still want to provide a simple example, because I think it’s a good place to demonstrate how an understanding of what lvalues and rvalues are aids our ability to reason about non-trivial language concepts.</p>
<p>I’ve just spent a good part of this article explaining that one of the main differences between lvalues and rvalues is that lvalues can be modified, and rvalues can’t. Well, C++11 adds a crucial twist to this distinction, by allowing us to have references to rvalues and thus modify them, in some special circumstances.</p>
<p>As an example, consider a simplistic implementation of a dynamic “integer vector”. I’m showing just the relevant methods here:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intvec</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="keyword">size_t</span> num = <span class="number">0</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(num), m_data(new int[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Intvec()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"destructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span>[] m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(other.m_size), m_data(<span class="keyword">new</span> <span class="keyword">int</span>[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data[i] = other.m_data[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_data, tmp.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="string">"\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> m_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>So, we have the usual constructor, destructor, copy constructor and copy assignment operator [4] defined, all using a logging function to let us know when they’re actually called.</p>
<p>Let’s run some simple code, which copies the contents of v1 into v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Intvec v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning lvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning lvalue...\n"</span>;</span></pre></td></tr></table></figure>

<p>What this prints is:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning lvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning lvalue...</span></pre></td></tr></table></figure>

<p>Makes sense - this faithfully represents what’s going on inside operator=. But suppose that we want to assign some rvalue to v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning rvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = Intvec(<span class="number">33</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning rvalue...\n"</span>;</span></pre></td></tr></table></figure>

<p>Although here I just assign a freshly constructed vector, it’s just a demonstration of a more general case where some temporary rvalue is being built and then assigned to v2 (this can happen for some function returning a vector, for example). What gets printed now is this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>
<p>Ouch, this looks like a lot of work. In particular, it has one extra pair of constructor/destructor calls to create and then destroy the temporary object. And this is a shame, because inside the copy assignment operator, another temporary copy is being created and destroyed. That’s extra work, for nothing.</p>
<p>Well, no more. C++11 gives us rvalue references with which we can implement “move semantics”, and in particular a “move assignment operator” [5]. Let’s add another operator= to Intvec:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The &amp;&amp; syntax is the new rvalue reference. It does exactly what it sounds it does - gives us a reference to an rvalue, which is going to be destroyed after the call. We can use this fact to just “steal” the internals of the rvalue - it won’t need them anyway! This prints:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] move assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>

<p>What happens here is that our new move assignment operator is invoked since an rvalue gets assigned to v2. The constructor and destructor calls are still needed for the temporary object that’s created by Intvec(33), but another temporary inside the assignment operator is no longer needed. The operator simply switches the rvalue’s internal buffer with its own, arranging it so the rvalue’s destructor will release our object’s own buffer, which is no longer used. Neat.</p>
<p>I’ll just mention once again that this example is only the tip of the iceberg on move semantics and rvalue references. As you can probably guess, it’s a complex subject with a lot of special cases and gotchas to consider. My point here was to demonstrate a very interesting application of the difference between lvalues and rvalues in C++. The compiler obviously knows when some entity is an rvalue, and can arrange to invoke the correct constructor at compile time.</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>One can write a lot of C++ code without being concerned with the issue of rvalues vs. lvalues, dismissing them as weird compiler jargon in certain error messages. However, as this article aimed to show, getting a better grasp of this topic can aid in a deeper understanding of certain C++ code constructs, and make parts of the C++ spec and discussions between language experts more intelligible.</p>
<p>Also, in the new C++ spec this topic becomes even more important, because C++11’s introduction of rvalue references and move semantics. To really grok this new feature of the language, a solid understanding of what rvalues and lvalues are becomes crucial.</p>
<blockquote>
<ol>
<li>rvalues can be assigned to lvalues explicitly. The lack of implicit conversion means that rvalues cannot be used in places where lvalues are expected.</li>
<li>That’s section 4.1 in the new C++11 standard draft.</li>
<li>You can find a lot of material on this topic by simply googling “rvalue references”. Some resources I personally found useful: <a href="https://www.artima.com/cppsource/rvalue.html" target="_blank" rel="noopener">this one</a>, and <a href="https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11" target="_blank" rel="noopener">this one</a>, and especially <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">this one</a>.</li>
<li>This a canonical implementation of a copy assignment operator, from the point of view of exception safety. By using the copy constructor and then the non-throwing std::swap, it makes sure that no intermediate state with uninitialized memory can arise if exceptions are thrown.</li>
<li>So now you know why I was keeping referring to my operator= as “copy assignment operator”. In C++11, the distinction becomes important.</li>
</ol>
</blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>@Reference</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/c-language/l-value-and-r-value-expressions?view=vs-2019" target="_blank" rel="noopener">L-Value and R-Value Expressions</a></li>
<li><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/" target="_blank" rel="noopener">Understanding lvalues and rvalues in C and C++</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>前馈神经网络(Feedforward Neural Network)</title>
    <url>/pytorch/tutorial-feedforward-neural-network.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络(Convolutional Neural Network)</title>
    <url>/pytorch/tutorial-convolutional-neural-network.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归 (Logistic Regression)</title>
    <url>/pytorch/tutorial-logistic-regression-03.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归 (Linear Regression)</title>
    <url>/pytorch/tutorial-linear-regression.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch基础</title>
    <url>/pytorch/tutorial-basic-01.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><a id="more"></a>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown guide and mdeditor</title>
    <url>/markdown/markdown-guide-and-mdeditor.html</url>
    <content><![CDATA[<pre><code>markdown 语法sample</code></pre><hr>
<blockquote>
<p>Itatic And Bold Sample<br>partial differential equasion<strong><em>偏微分方程</em></strong><br>常微分方程<em><strong>是这样解开的</strong></em><br>仰天大笑出门去，我辈岂是蓬蒿人  </p>
</blockquote>
<hr>
<blockquote>
<p>Order List Sample<br>遇见冬天的离别<br>–<br>孙燕姿的绿光<br>–</p>
<ol>
<li>窗外的麻雀，消失在电线杆上</li>
<li>就是开不了口让她知道</li>
<li>断了的弦，再谈一遍</li>
<li>哪里跟那里<ol>
<li>你的转变，想断掉的弦</li>
<li>你的美，已经追不回，追了又追我要不会</li>
<li>诶，小朋友在玩什么呀，</li>
</ol>
</li>
<li>一波还未平息，一波早就过去</li>
</ol>
</blockquote>
<hr>
<a id="more"></a>

<blockquote>
<p>Unorder List Sample<br>让我疯狂的可爱女人</p>
<ul>
<li>没有了联络，后来的生活，都是听别人说</li>
</ul>
<ul>
<li>你发如雪，凄美了离别，我等待苍老了谁</li>
</ul>
<ul>
<li>没有地球，太阳还是会绕</li>
</ul>
<ul>
<li>你的外没注意太彻底<ul>
<li>彩虹</li>
<li>周杰伦作曲 方文山作词</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>Code Sample<br> To denote a word or phrase as code, enclose it in tick marks (`).<br> Atthecommandprompt,type<code>nano</code>.</p>
<pre><code>int a = 12 // code syntax require at lease 4 spaces on the left</code></pre></blockquote>
<hr>
<h1 id="MDEditor-Online-Samples"><a href="#MDEditor-Online-Samples" class="headerlink" title="MDEditor Online Samples"></a>MDEditor <a href="/editor/sample.html">Online Samples</a></h1><p><strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p><img alt="markdown" title="markdown" data-src="https://www.mdeditor.com/images/logos/markdown.png"></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<h2 id="MdEditor是一个在线编辑Markdown文档的编辑器"><a href="#MdEditor是一个在线编辑Markdown文档的编辑器" class="headerlink" title="MdEditor是一个在线编辑Markdown文档的编辑器"></a>MdEditor是一个在线编辑Markdown文档的编辑器</h2><p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href="https://github.com/pandao/editor.md" target="_blank" rel="noopener" title="Editor.md">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p>
<p><img alt="Pandao editor.md" title="Pandao editor.md" data-src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png"></p>
<h2 id="MdEditor的功能列表演示"><a href="#MdEditor的功能列表演示" class="headerlink" title="MdEditor的功能列表演示"></a>MdEditor的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr>
<p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p>
<p><em>斜体字</em>      <em>斜体字</em></p>
<p><strong>粗体</strong>  <strong>粗体</strong></p>
<p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br><a href="https://www.mdeditor.com/" target="_blank" rel="noopener" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com" target="_blank" rel="noopener">www@vip.qq.com</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;</code></pre><p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">"Microsoft Yahei"</span>, Tahoma, <span class="string">"Hiragino Sans GB"</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>
<h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p>
<p><a href="https://www.mdeditor.com/images/logos/markdown.png" target="_blank" rel="noopener" title="markdown"><img alt data-src="https://www.mdeditor.com/images/logos/markdown.png"></a></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li><input checked disabled type="checkbox"> GFM task list 1</li>
<li><input checked disabled type="checkbox"> GFM task list 2</li>
<li><input disabled type="checkbox"> GFM task list 3<ul>
<li><input disabled type="checkbox"> GFM task list 3-1</li>
<li><input disabled type="checkbox"> GFM task list 3-2</li>
<li><input disabled type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled type="checkbox"> GFM task list 4<ul>
<li><input disabled type="checkbox"> GFM task list 4-1</li>
<li><input disabled type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p>
<p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p>
<p>18&ordm;C  &quot;  &apos;</p>
<p>[========]</p>
<h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul>
<li><input checked disabled type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li><input checked disabled type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li>
<li><input disabled type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li><input disabled type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>
<li><input disabled type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li><input disabled type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p>
<p>[========]</p>
<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p>
<p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p>
<p>$$x &gt; y$$</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span></pre></td></tr><tr><td class="code"><pre><span class="line">\leq</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \frac&#123;1&#125;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#123;1+\cdots&#125; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x) &#x3D; \int_&#123;-\infty&#125;^\infty</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \,d\xi</span></pre></td></tr></table></figure>
<h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<p>[========]</p>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span></pre></td></tr><tr><td class="code"><pre><span class="line">op&#x3D;&gt;operation: 登陆操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 进入后台</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st-&gt;op-&gt;cond</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond(yes)-&gt;e</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond(no)-&gt;op</span></pre></td></tr></table></figure>
<p>[========]</p>
<h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note right of China: China thinks\nabout it</span></pre></td></tr><tr><td class="code"><pre><span class="line">China--&gt;Andrew: How are you?</span></pre></td></tr><tr><td class="code"><pre><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>Go To <a href="/editor/">Online Editor</a><br>See more samples from the <a href="https://www.markdownguide.org/assets/book/markdown-guide.pdf" target="_blank" rel="noopener" title="Ctrl/Command to open in new tab">official manual guide</a> with pdf</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
