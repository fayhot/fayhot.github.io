<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pytorch Tutorial And Deep Learning(Pytorch与深度学习)</title>
    <url>/unmark/pytorch-deep-learning-tutorial.html</url>
    <content><![CDATA[<h2 id="深度学习框架pytorch"><a class="markdownIt-Anchor" href="#深度学习框架pytorch"></a> 深度学习框架pytorch</h2>
<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>所有代码都在当前版本pytorch下测试通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(torch.__version__)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>))</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span><span class="number">.0</span>.post2</span></pre></td></tr><tr><td class="code"><pre><span class="line">cpu</span></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="pytorch基础"><a class="markdownIt-Anchor" href="#pytorch基础"></a> pytorch基础</h3>
<h4 id="autograd-求取梯度"><a class="markdownIt-Anchor" href="#autograd-求取梯度"></a> autograd 求取梯度</h4>
<ul>
<li>导入包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr></table></figure>
<ul>
<li>autograd（自动求导/求梯度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建张量（tensors）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">1.</span>, requires_grad=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">w = torch.tensor(<span class="number">2.</span>, requires_grad=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">b = torch.tensor(<span class="number">3.</span>, requires_grad=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建计算图（ computational graph）：前向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y = w * x + b    <span class="comment"># y = 2 * x + 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 反向传播，计算梯度（gradients）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(x.grad)    <span class="comment"># x.grad = 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(w.grad)    <span class="comment"># w.grad = 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(b.grad)    <span class="comment"># b.grad = 1</span></span></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">tensor</span><span class="params">(<span class="number">2</span>.)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">tensor</span><span class="params">(<span class="number">1</span>.)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">tensor</span><span class="params">(<span class="number">1</span>.)</span></span></span></pre></td></tr></table></figure>
<ul>
<li>autograd（自动求导/求梯度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建大小为 (10, 3) 和 (10, 2)的张量.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># randn 返回标准正态分布（均值为0，方差为1）的随机数, rand返回区间(0,1)均匀分布的随机数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">10</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">y = torch.randn(<span class="number">10</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建全连接层（fully connected layer）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">linear = nn.Linear(<span class="number">3</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'w: '</span>, linear.weight)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'b: '</span>, linear.bias)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建损失函数和优化器（loss function and optimizer）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数使用均方差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 优化器使用随机梯度下降，lr是learning rate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">criterion = nn.MSELoss()</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(linear.parameters(), lr=<span class="number">0.01</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pred = linear(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算损失</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">loss = criterion(pred, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'loss: '</span>, loss.item())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">loss.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'dL/dw: '</span>, linear.weight.grad) </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'dL/db: '</span>, linear.bias.grad)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 执行一步-梯度下降（1-step gradient descent）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer.step()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 更底层的实现方式是这样子的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># linear.weight.data.sub_(0.01 * linear.weight.grad.data)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># linear.bias.data.sub_(0.01 * linear.bias.grad.data)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 进行一次梯度下降之后，输出新的预测损失</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># loss的确变少了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pred = linear(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">loss = criterion(pred, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'loss after 1 step optimization: '</span>, loss.item())</span></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">w:  Parameter containing:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">tensor([[-0.3414,</span> <span class="number">-0.2485</span><span class="string">,</span>  <span class="number">0.5127</span><span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">[</span> <span class="number">0.1081</span><span class="string">,</span> <span class="number">-0.2054</span><span class="string">,</span> <span class="number">-0.0197</span><span class="string">]],</span> <span class="string">requires_grad=True)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">b:  Parameter containing:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">tensor([</span> <span class="number">0.0694</span><span class="string">,</span> <span class="number">-0.4127</span><span class="string">],</span> <span class="string">requires_grad=True)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">loss:</span>  <span class="number">1.1263189315795898</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dL/dw:</span>  <span class="string">tensor([[-0.8668,</span> <span class="number">-0.4168</span><span class="string">,</span>  <span class="number">0.2444</span><span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">[</span> <span class="number">0.5876</span><span class="string">,</span> <span class="number">-0.0610</span><span class="string">,</span>  <span class="number">0.4616</span><span class="string">]])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">dL/db:</span>  <span class="string">tensor([</span> <span class="number">0.0916</span><span class="string">,</span> <span class="number">-0.3413</span><span class="string">])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">loss after 1 step optimization:</span>  <span class="number">1.1097254753112793</span></span></pre></td></tr></table></figure>
<h4 id="从numpy装载数据"><a class="markdownIt-Anchor" href="#从numpy装载数据"></a> 从Numpy装载数据</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Numpy数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 将numpy数组转换为torch的张量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y = torch.from_numpy(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(y)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 将torch的张量转换为numpy数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">z = y.numpy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(z)</span></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">[[1 2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string"> [3 4]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tensor(<span class="string">[[1, 2],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        [3, 4]]</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[[1 2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string"> [3 4]]</span></span></pre></td></tr></table></figure>
<h4 id="输入工作流input-pipeline"><a class="markdownIt-Anchor" href="#输入工作流input-pipeline"></a> 输入工作流（Input pipeline）</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载和构造CIFAR-10 数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Cifar-10数据集介绍：https://www.cs.toronto.edu/~kriz/cifar.html</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_dataset = torchvision.datasets.CIFAR10(root=<span class="string">'../../../data/'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                             train=<span class="literal">True</span>, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                                             transform=transforms.ToTensor(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                             download=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一组数据对（从磁盘中读取）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">image, label = train_dataset[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (image.size())</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (label)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载器（提供了队列和线程的简单实现）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                           batch_size=<span class="number">64</span>, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                                           shuffle=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代的使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 当迭代开始时，队列和线程开始从文件中加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">data_iter = iter(train_loader)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一组mini-batch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">images, labels = data_iter.next()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 正常的使用方式如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> train_loader:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 在此处添加训练用的代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pass</span></span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Files already downloaded <span class="keyword">and</span> verified</span></pre></td></tr><tr><td class="code"><pre><span class="line">torch.Size([<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr></table></figure>
<h4 id="自定义数据集的input-pipeline"><a class="markdownIt-Anchor" href="#自定义数据集的input-pipeline"></a> 自定义数据集的Input pipeline</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建自定义数据集的方式如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataset</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># TODO</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 1. 初始化文件路径或者文件名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># TODO</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 1. 从文件中读取一份数据（比如使用nump.fromfile，PIL.Image.open）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 2. 预处理数据（比如使用 torchvision.Transform）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 3. 返回数据对（比如 image和label）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 将0替换成数据集的总长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 然后就可以使用预置的数据加载器（data loader）了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">custom_dataset = CustomDataset()</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=custom_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                batch_size=<span class="number">64</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                shuffle=<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<p>如果没有实现TODO会报错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">ValueError                                Traceback (most recent call last)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;ipython-input<span class="number">-27</span>-be02a903d589&gt; <span class="keyword">in</span> &lt;module&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">1</span> train_loader = torch.utils.data.DataLoader(dataset=custom_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">2</span>                                            batch_size=<span class="number">64</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">----&gt; 3                                            shuffle=True)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">/usr/local/Cellar/python/<span class="number">3.7</span><span class="number">.3</span>/Frameworks/Python.framework/Versions/<span class="number">3.7</span>/lib/python3<span class="number">.7</span>/site-packages/torch/utils/data/dataloader.py <span class="keyword">in</span> __init__(self, dataset, batch_size, shuffle, sampler, batch_sampler, num_workers, collate_fn, pin_memory, drop_last, timeout, worker_init_fn)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">174</span>             <span class="keyword">if</span> sampler <span class="keyword">is</span> <span class="literal">None</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">175</span>                 <span class="keyword">if</span> shuffle:</span></pre></td></tr><tr><td class="code"><pre><span class="line">--&gt; 176                     sampler = RandomSampler(dataset)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">177</span>                 <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">178</span>                     sampler = SequentialSampler(dataset)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">/usr/local/Cellar/python/<span class="number">3.7</span><span class="number">.3</span>/Frameworks/Python.framework/Versions/<span class="number">3.7</span>/lib/python3<span class="number">.7</span>/site-packages/torch/utils/data/sampler.py <span class="keyword">in</span> __init__(self, data_source, replacement, num_samples)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="number">64</span>         <span class="keyword">if</span> <span class="keyword">not</span> isinstance(self.num_samples, int) <span class="keyword">or</span> self.num_samples &lt;= <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="number">65</span>             <span class="keyword">raise</span> ValueError(<span class="string">"num_samples should be a positive integer "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">---&gt; 66                              "value, but got num_samples=&#123;&#125;".format(self.num_samples))</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="number">67</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="number">68</span>     @property</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ValueError: num_samples should be a positive integer value, but got num_samples=<span class="number">0</span></span></pre></td></tr></table></figure>
<h4 id="预训练模型"><a class="markdownIt-Anchor" href="#预训练模型"></a> 预训练模型</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并加载预训练好的模型 ResNet-18</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">resnet = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 如果想要在模型仅对Top Layer进行微调的话，可以设置如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># requieres_grad设置为False的话，就不会进行梯度更新，就能保持原有的参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> resnet.parameters():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    param.requires_grad = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 替换TopLayer，只对这一层做微调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">resnet.fc = nn.Linear(resnet.fc.in_features, <span class="number">100</span>)  <span class="comment"># 100 is an example.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">images = torch.randn(<span class="number">64</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">outputs = resnet(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (outputs.size())     <span class="comment"># (64, 100)</span></span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.Size([<span class="number">64</span>, <span class="number">100</span>])</span></pre></td></tr></table></figure>
<h4 id="保存和加载模型"><a class="markdownIt-Anchor" href="#保存和加载模型"></a> 保存和加载模型</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存和加载整个模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch.save(resnet, <span class="string">'model.ckpt'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">model = torch.load(<span class="string">'model.ckpt'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 仅保存和加载模型的参数（推荐这个方式）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch.save(resnet.state_dict(), <span class="string">'params.ckpt'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">resnet.load_state_dict(torch.load(<span class="string">'params.ckpt'</span>))</span></pre></td></tr></table></figure>
<h3 id="线性回归linear-regression"><a class="markdownIt-Anchor" href="#线性回归linear-regression"></a> 线性回归（Linear Regression）</h3>
<ul>
<li>导入包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr></table></figure>
<ul>
<li>参数、模型设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">input_size = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">output_size = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_epochs = <span class="number">60</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Toy dataset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 玩具资料：小数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_train = np.array([[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>], </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>], [<span class="number">2.167</span>], [<span class="number">7.042</span>], </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">y_train = np.array([[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>], </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>], [<span class="number">1.221</span>], [<span class="number">2.827</span>], </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 线性回归模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model = nn.Linear(input_size, output_size)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数和优化器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">criterion = nn.MSELoss()</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span></pre></td></tr></table></figure>
<ul>
<li>训练模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 将Numpy数组转换为torch张量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    inputs = torch.from_numpy(x_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    targets = torch.from_numpy(y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    outputs = model(inputs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    loss = criterion(outputs, targets)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 反向传播和优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    optimizer.zero_grad()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    loss.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    optimizer.step()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">print</span> (<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span>.format(epoch+<span class="number">1</span>, num_epochs, loss.item()))</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">60</span>], Loss: <span class="number">7.4997</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">10</span>/<span class="number">60</span>], Loss: <span class="number">3.1402</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">15</span>/<span class="number">60</span>], Loss: <span class="number">1.3741</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">20</span>/<span class="number">60</span>], Loss: <span class="number">0.6586</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">25</span>/<span class="number">60</span>], Loss: <span class="number">0.3687</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">30</span>/<span class="number">60</span>], Loss: <span class="number">0.2513</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">35</span>/<span class="number">60</span>], Loss: <span class="number">0.2037</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">40</span>/<span class="number">60</span>], Loss: <span class="number">0.1844</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">45</span>/<span class="number">60</span>], Loss: <span class="number">0.1766</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">50</span>/<span class="number">60</span>], Loss: <span class="number">0.1734</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">55</span>/<span class="number">60</span>], Loss: <span class="number">0.1722</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">60</span>/<span class="number">60</span>], Loss: <span class="number">0.1716</span></span></pre></td></tr></table></figure>
<ul>
<li>绘制图形</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># torch.from_numpy(x_train)将X_train转换为Tensor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># model()根据输入和模型，得到输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># detach().numpy()预测结结果转换为numpy数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">predicted = model(torch.from_numpy(x_train)).detach().numpy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.plot(x_train, y_train, <span class="string">'ro'</span>, label=<span class="string">'Original data'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.plot(x_train, predicted, label=<span class="string">'Fitted line'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<p><img alt="linear_regression_sample" data-src="/assets/2019/12/10/linear_regression_sample.png"></p>
<ul>
<li>将模型的记录节点保存下来</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">'model.ckpt'</span>)</span></pre></td></tr></table></figure>
<h3 id="逻辑回归logistic-regression"><a class="markdownIt-Anchor" href="#逻辑回归logistic-regression"></a> 逻辑回归（Logistic Regression）</h3>
<ul>
<li>导入包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr></table></figure>
<ul>
<li>参数设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数设置 Hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">input_size = <span class="number">784</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_classes = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_epochs = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span></pre></td></tr></table></figure>
<ul>
<li>MINIST数据集加载（image and labels）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 train=<span class="literal">True</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 transform=transforms.ToTensor(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 download=<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Downloading <span class="string">http:</span><span class="comment">//yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ../../../data/minist/MNIST/raw/train-images-idx3-ubyte.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.1</span>%</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extracting ..<span class="regexp">/../</span>..<span class="regexp">/data/</span>minist<span class="regexp">/MNIST/</span>raw/train-images-idx3-ubyte.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">Downloading <span class="string">http:</span><span class="comment">//yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz to ../../../data/minist/MNIST/raw/train-labels-idx1-ubyte.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">113.5</span>%</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extracting ..<span class="regexp">/../</span>..<span class="regexp">/data/</span>minist<span class="regexp">/MNIST/</span>raw/train-labels-idx1-ubyte.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">Downloading <span class="string">http:</span><span class="comment">//yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz to ../../../data/minist/MNIST/raw/t10k-images-idx3-ubyte.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.4</span>%</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extracting ..<span class="regexp">/../</span>..<span class="regexp">/data/</span>minist<span class="regexp">/MNIST/</span>raw/t10k-images-idx3-ubyte.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">Downloading <span class="string">http:</span><span class="comment">//yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz to ../../../data/minist/MNIST/raw/t10k-labels-idx1-ubyte.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">180.4</span>%</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extracting ..<span class="regexp">/../</span>..<span class="regexp">/data/</span>minist<span class="regexp">/MNIST/</span>raw/t10k-labels-idx1-ubyte.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">Processing...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Done!</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               train=<span class="literal">False</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               transform=transforms.ToTensor())</span></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载器（data loader）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(<span class="attribute">dataset</span>=train_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 <span class="attribute">batch_size</span>=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 <span class="attribute">shuffle</span>=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_loader = torch.utils.data.DataLoader(<span class="attribute">dataset</span>=test_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               <span class="attribute">batch_size</span>=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               <span class="attribute">shuffle</span>=<span class="literal">False</span>)</span></pre></td></tr></table></figure>
<ul>
<li>Logistic Regression模型：加载和训练</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线性模型，指定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model = nn.Linear(input_size, num_classes)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数和优化器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># nn.CrossEntropyLoss()内部集成了softmax函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># It is useful when training a classification problem with `C` classes.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">total_step = len(train_loader)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 将图像序列抓换至大小为 (batch_size, input_size)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss = criterion(outputs, labels)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 反向传播及优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.zero_grad() <span class="comment"># 注意每次循环都要注意清空梯度缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.step()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">print</span> (<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">                   .format(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, total_step, loss.item()))</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">2.2573</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">2.1257</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">2.0524</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">1.9810</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">1.9118</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">1.8635</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">1.7000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">1.7233</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">1.6955</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">1.5738</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">1.6119</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">1.4994</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">1.4966</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">1.3909</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">1.2951</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">1.3250</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">1.1628</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">1.2553</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">1.2861</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">1.1990</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">1.2871</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">1.1154</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">1.1758</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">1.1805</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">1.0249</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">1.0673</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">1.0265</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">1.0038</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">1.0607</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">1.0184</span></span></pre></td></tr></table></figure>
<ul>
<li>模型测试</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在测试阶段，为了运行内存效率，就不需要计算梯度了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># PyTorch 默认每一次前向传播都会计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    correct = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    total = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += labels.size(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        correct += (predicted == labels).sum()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	print(<span class="string">'Accuracy of the model on the 10000 test images: &#123;&#125; %'</span>.format(<span class="number">100</span> * correct / total))</span></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">of</span> <span class="keyword">the</span> model <span class="keyword">on</span> <span class="title">the</span> <span class="title">10000</span> <span class="title">test</span> <span class="title">images</span>: <span class="title">82</span> %</span></pre></td></tr></table></figure>
<ul>
<li>保存模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">'model.ckpt'</span>)</span></pre></td></tr></table></figure>
<h3 id="前馈神经网络feedforward-neural-network"><a class="markdownIt-Anchor" href="#前馈神经网络feedforward-neural-network"></a> 前馈神经网络（Feedforward Neural Network）</h3>
<ul>
<li>导入包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr></table></figure>
<ul>
<li>参数设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设备配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 有cuda就用cuda</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">input_size = <span class="number">784</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hidden_size = <span class="number">500</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_classes = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_epochs = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span></pre></td></tr></table></figure>
<ul>
<li>MINIST 数据集加载</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 train=<span class="literal">True</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 transform=transforms.ToTensor(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 download=<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               train=<span class="literal">False</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               transform=transforms.ToTensor())</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载器 Data Loader</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练数据加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 batch_size=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 shuffle=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               batch_size=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               shuffle=<span class="literal">False</span>)</span></pre></td></tr></table></figure>
<ul>
<li>自定义前馈神经网络</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：有一个隐藏层的全连接的神经网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeuralNet</span><span class="params">(nn.Module)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, num_classes)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        super(NeuralNet, self).__init__()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.fc1 = nn.Linear(input_size, hidden_size) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.relu = nn.ReLU()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.fc2 = nn.Linear(hidden_size, num_classes)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.fc1(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.relu(out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.fc2(out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载（实例化）一个网络模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># to(device)可以用来将模型放在GPU上训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model = NeuralNet(input_size, hidden_size, num_classes).to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 定义损失函数和优化器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 再次，损失函数CrossEntropyLoss适合用于分类问题，因为它自带SoftMax功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span></pre></td></tr></table></figure>
<ul>
<li>训练模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_step = len(train_loader)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 将tensor移动到配置好的设备上（GPU）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>).to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        labels = labels.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss = criterion(outputs, labels)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 反向传播和优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.zero_grad()    <span class="comment"># 还是要注意此处，每次迭代训练都需要清空梯度缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.step()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">print</span> (<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                   .format(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, total_step, loss.item()))</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.3046</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.2803</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.2142</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.1459</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.1378</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.2241</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.1013</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0935</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0990</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.1639</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0283</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0304</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0659</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0738</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.1491</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.1034</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0109</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0884</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0489</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0575</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0833</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0684</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0445</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0789</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0192</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0227</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0076</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0595</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0214</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0562</span></span></pre></td></tr></table></figure>
<ul>
<li>测试并保存模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试阶段为提高效率，可以不计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 使用with torch.no_grad()函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    correct = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    total = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>).to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        labels = labels.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 统计预测概率最大的下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += labels.size(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        correct += (predicted == labels).sum().item()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Accuracy of the network on the 10000 test images: &#123;&#125; %'</span>.format(<span class="number">100</span> * correct / total))</span></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Accuracy of the<span class="built_in"> network </span>on the 10000 test images: 97.73 %</span></pre></td></tr></table></figure>
<ul>
<li>保存模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">'model.ckpt'</span>)</span></pre></td></tr></table></figure>
<h3 id="卷积神经网络convolutional-neural-network"><a class="markdownIt-Anchor" href="#卷积神经网络convolutional-neural-network"></a> 卷积神经网络（Convolutional Neural Network）</h3>
<ul>
<li>导入包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr></table></figure>
<ul>
<li>参数设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设备配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> device.type != <span class="string">'cpu'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	torch.cuda.set_device(<span class="number">1</span>) <span class="comment"># 这句用来设置pytorch在哪块GPU上运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_epochs = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_classes = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span></pre></td></tr></table></figure>
<ul>
<li>MINIST数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist/'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 train=<span class="literal">True</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 transform=transforms.ToTensor(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 download=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_dataset = torchvision.datasets.MNIST(root=<span class="string">'../../../data/minist'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               train=<span class="literal">False</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                               transform=transforms.ToTensor())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练数据 加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 batch_size=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                 shuffle=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                batch_size=batch_size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                shuffle=<span class="literal">False</span>)</span></pre></td></tr></table></figure>
<ul>
<li>自定义 卷积神经网络</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搭建卷积神经网络模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 两个卷积层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvNet</span><span class="params">(nn.Module)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">10</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        super(ConvNet, self).__init__()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.layer1 = nn.Sequential(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 卷积层计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">#  批归一化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">#ReLU激活函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.ReLU(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 池化层：最大池化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.layer2 = nn.Sequential(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.ReLU(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.fc = nn.Linear(<span class="number">7</span>*<span class="number">7</span>*<span class="number">32</span>, num_classes)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 定义前向传播顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.layer1(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.layer2(out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = out.reshape(out.size(<span class="number">0</span>), <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out = self.fc(out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化一个模型，并迁移至gpu|cpu</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model = ConvNet(num_classes).to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 定义损失函数和优化器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span></pre></td></tr></table></figure>
<ul>
<li>训练模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_step = len(train_loader)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 注意模型在GPU中，数据也要搬到GPU中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        labels = labels.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss = criterion(outputs, labels)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 反向传播和优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.zero_grad()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loss.backward()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        optimizer.step()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">print</span> (<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">                   .format(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, total_step, loss.item()))</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.1633</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.1629</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0813</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0428</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0351</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">1</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.1182</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0323</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0501</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0592</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0257</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0668</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">2</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0521</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0144</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0292</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0239</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0948</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0140</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">3</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0481</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0648</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0362</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0217</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0257</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0833</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">4</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0321</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">100</span>/<span class="number">600</span>], Loss: <span class="number">0.0119</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">200</span>/<span class="number">600</span>], Loss: <span class="number">0.0307</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">300</span>/<span class="number">600</span>], Loss: <span class="number">0.0212</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">400</span>/<span class="number">600</span>], Loss: <span class="number">0.0084</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">500</span>/<span class="number">600</span>], Loss: <span class="number">0.0159</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Epoch [<span class="number">5</span>/<span class="number">5</span>], Step [<span class="number">600</span>/<span class="number">600</span>], Loss: <span class="number">0.0050</span></span></pre></td></tr></table></figure>
<ul>
<li>测试并保存模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换成评估测试模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 这是因为在测试时，与训练时的dropout和batch normalization的操作是不同的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model.eval()</span></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ConvNet(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (layer1): Sequential(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (0): Conv2d(1, 16, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (1): BatchNorm2d(16, <span class="attribute">eps</span>=1e-05, <span class="attribute">momentum</span>=0.1, <span class="attribute">affine</span>=<span class="literal">True</span>, <span class="attribute">track_running_stats</span>=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (2): ReLU()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (3): MaxPool2d(<span class="attribute">kernel_size</span>=2, <span class="attribute">stride</span>=2, <span class="attribute">padding</span>=0, <span class="attribute">dilation</span>=1, <span class="attribute">ceil_mode</span>=<span class="literal">False</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (layer2): Sequential(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (0): Conv2d(16, 32, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (1): BatchNorm2d(32, <span class="attribute">eps</span>=1e-05, <span class="attribute">momentum</span>=0.1, <span class="attribute">affine</span>=<span class="literal">True</span>, <span class="attribute">track_running_stats</span>=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (2): ReLU()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (3): MaxPool2d(<span class="attribute">kernel_size</span>=2, <span class="attribute">stride</span>=2, <span class="attribute">padding</span>=0, <span class="attribute">dilation</span>=1, <span class="attribute">ceil_mode</span>=<span class="literal">False</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (fc): Linear(<span class="attribute">in_features</span>=1568, <span class="attribute">out_features</span>=10, <span class="attribute">bias</span>=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 节省计算资源，不去计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    correct = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    total = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        images = images.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        labels = labels.to(device)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += labels.size(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        correct += (predicted == labels).sum().item()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Test Accuracy of the model on the 10000 test images: &#123;&#125; %'</span>.format(<span class="number">100</span> * correct / total))</span></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>Accuracy of the model on the 10000 test images: 98.98 %</span></pre></td></tr></table></figure>
<ul>
<li>保存模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">'model.ckpt'</span>)</span></pre></td></tr></table></figure>
<h4 id="用自己的图片和模型进行测试单张"><a class="markdownIt-Anchor" href="#用自己的图片和模型进行测试单张"></a> 用自己的图片和模型进行测试（单张）</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># plt 用于显示图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg <span class="comment"># mpimg 用于读取图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#resize功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 彩图转灰度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rgb2gray</span><span class="params">(rgb)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> np.dot(rgb[...,:<span class="number">3</span>], [<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 读取图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">srcPath = <span class="string">'8.png'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">src = mpimg.imread(srcPath)<span class="comment"># 读取和代码处于同一目录下的 图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 此时 lena 就已经是一个 np.array 了，可以对它进行任意处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 原图大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(src.shape)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(src) <span class="comment"># 显示图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>) <span class="comment"># 不显示坐标轴</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">252</span>, <span class="number">261</span>, <span class="number">4</span>)</span></pre></td></tr></table></figure>
<p><img alt="handwrite_image_8" data-src="/assets/2019/12/10/handwrite_image_8.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转灰度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gray = rgb2gray(src)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 第二个参数如果是整数，则为百分比，如果是tuple，则为输出图像的尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gray_new_sz =  np.array(Image.fromarray(gray).resize((<span class="number">28</span>,<span class="number">28</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(gray_new_sz.shape)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(gray_new_sz, cmap=<span class="string">'Greys_r'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>)</span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">28</span>, <span class="number">28</span>)</span></pre></td></tr></table></figure>
<p><img alt="resize_image_8" data-src="/assets/2019/12/10/resize_image_8.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换为（B,C,H,W）大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">image = gray_new_sz.reshape(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 转换为torch tensor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">image_tensor = torch.from_numpy(image).float()</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用模型进行评估</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model.eval()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">output = model(image_tensor.to(device))</span></pre></td></tr><tr><td class="code"><pre><span class="line">_, predicted = torch.max(output.data, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">pre = predicted.cpu().numpy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(pre) <span class="comment"># 查看预测结果</span></span></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span></pre></td></tr></table></figure>
<h4 id="查看pytorch跑在哪块gpu上"><a class="markdownIt-Anchor" href="#查看pytorch跑在哪块gpu上"></a> 查看Pytorch跑在哪块GPU上</h4>
<p>如果在GPU环境下运行，遇到<code>cuda runtime error: out of memory</code>时，可以查看一下跑在哪块GPU上了。然后用nvidia-smi看一下是不是GPU被占用了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这一段可以用来查看当前GPU的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__Python VERSION:'</span>, sys.version)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__pyTorch VERSION:'</span>, torch.__version__)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__CUDA VERSION'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># call(["nvcc", "--version"]) does not work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">! nvcc --version</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__CUDNN VERSION:'</span>, torch.backends.cudnn.version())</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__Number CUDA Devices:'</span>, torch.cuda.device_count())</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'__Devices'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">call([<span class="string">"nvidia-smi"</span>, <span class="string">"--format=csv"</span>, <span class="string">"--query-gpu=index,name,driver_version,memory.total,memory.used,memory.free"</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'Active CUDA Device: GPU'</span>, torch.cuda.current_device())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'Available devices '</span>, torch.cuda.device_count())</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">'Current cuda device '</span>, torch.cuda.current_device())</span></pre></td></tr></table></figure>
<h3 id="深度残差网络deep-residual-networks"><a class="markdownIt-Anchor" href="#深度残差网络deep-residual-networks"></a> 深度残差网络（Deep Residual Networks）</h3>
<h3 id="循环神经网络recurrent-neural-network"><a class="markdownIt-Anchor" href="#循环神经网络recurrent-neural-network"></a> 循环神经网络（Recurrent Neural Network）</h3>
<h3 id="双向循环神经网络bidirectional-recurrent-neural-network"><a class="markdownIt-Anchor" href="#双向循环神经网络bidirectional-recurrent-neural-network"></a> 双向循环神经网络（Bidirectional Recurrent Neural Network）</h3>
<h3 id="语言模型language-model-rnn-lm"><a class="markdownIt-Anchor" href="#语言模型language-model-rnn-lm"></a> 语言模型（Language Model (RNN-LM)）</h3>
<h3 id="生成对抗网络generative-adversarial-networks"><a class="markdownIt-Anchor" href="#生成对抗网络generative-adversarial-networks"></a> 生成对抗网络（Generative Adversarial Networks）</h3>
<h3 id="变分自编码器variational-auto-encoder"><a class="markdownIt-Anchor" href="#变分自编码器variational-auto-encoder"></a> 变分自编码器（Variational Auto-Encoder）</h3>
<h3 id="神经风格迁移neural-style-transfer"><a class="markdownIt-Anchor" href="#神经风格迁移neural-style-transfer"></a> 神经风格迁移（Neural Style Transfer）</h3>
<h3 id="图像标注image-captioning-cnn-rnn"><a class="markdownIt-Anchor" href="#图像标注image-captioning-cnn-rnn"></a> 图像标注（Image Captioning (CNN-RNN)）</h3>
<h3 id="pytorch中的tensorboardtensorboard-in-pytorch"><a class="markdownIt-Anchor" href="#pytorch中的tensorboardtensorboard-in-pytorch"></a> Pytorch中的TensorBoard（TensorBoard in PyTorch）</h3>
<h3 id="pytorch在cifar-10数据集上的训练及测试过程"><a class="markdownIt-Anchor" href="#pytorch在cifar-10数据集上的训练及测试过程"></a> PyTorch在CIFAR-10数据集上的训练及测试过程</h3>
<h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> @Reference:</h3>
<p><a href="https://pytorch.org/tutorials/" target="_blank" rel="noopener">pytorch offical tutorials</a><br>
<a href="https://github.com/yunjey/pytorch-tutorial" target="_blank" rel="noopener">Yunjey Choi Github Repo</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pattern Recognition And Machine Learning(模式识别&amp;机器学习)</title>
    <url>/pattern-recognition/pattern-recognition-and-machine-learning.html</url>
    <content><![CDATA[<h1 id="pattern-recognition-and-machine-learning"><a class="markdownIt-Anchor" href="#pattern-recognition-and-machine-learning"></a> Pattern Recognition And Machine Learning</h1>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> introduction</h2>
<h3 id="keywords"><a class="markdownIt-Anchor" href="#keywords"></a> keywords</h3>
<ul>
<li>
<p>supervised learning<br>
Supervised learning, in the context of artificial intelligence (AI) and machine learning, is a type of system in which both input and desired output data are provided. Input and output data are labelled for classification to provide a learning basis for future data processing.</p>
</li>
<li>
<p>unsupervised learning<br>
opposite of supervised learning</p>
</li>
<li>
<p>classification<br>
Cases such as the digit recognition example, in which the aim is to assign each input vector to one of a finite number of discrete categories</p>
</li>
<li>
<p>reinforcement learning<br>
Reinforcement learning is where a system, or agent, tries to maximize some measure of reward while interacting with a dynamic environment. If an action is followed by an increase in the reward, then the system increases the tendency to produce that action.</p>
</li>
<li>
<p>regression<br>
If the desired output consists of one or more continuous variables, then the task is called regression</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>
<p>error function</p>
</li>
<li>
<p>over-fitting</p>
</li>
<li>
<p>generalization</p>
</li>
<li>
<p>credit assignment</p>
</li>
<li>
<p>regularization</p>
</li>
<li>
<p>maximum likelihood</p>
</li>
<li>
<p>Polynomial Curve Fitting</p>
</li>
<li>
<p>shrinkage methods</p>
</li>
<li>
<p>ridge regression</p>
</li>
<li>
<p>weight decay</p>
</li>
</ul>
<p>In other pattern recognition problems, the training data consists of a set of input vectors x without any corresponding target values. The goal in such <strong>unsupervised learning</strong> problems may be to discover groups of similar examples within the data, where it is called <strong>clustering</strong>, or to determine the distribution of data within the input space, known as <strong>density estimation</strong>, or to project the data from a high-dimensional space down to two or three dimensions for the purpose of <strong>visualization</strong>.</p>
<h3 id="polynomial-curve-fitting"><a class="markdownIt-Anchor" href="#polynomial-curve-fitting"></a> Polynomial Curve Fitting</h3>
<p>suppose that we are given a training set comprising N observations of x, written</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">x</mi><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf x \equiv (x_1, ..., x_n)^\top
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>together with corresponding observations of the values of t ,denoted</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">t</mi><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf t \equiv (t_1, ..., t_n)^\top
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63492em;vertical-align:0em;"></span><span class="mord mathbf">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>we shall fit the data using a polynomial function of the form</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mn>0</mn></msub><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>w</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>j</mi></msub><msup><mi>x</mi><mi>j</mi></msup></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1.1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">y(x, w) = w_0 + w_1x + w_2x^2 + ... + w_nx^n= \sum_{j=0}^{n} w_jx^j  \tag{1.1.1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0141079999999998em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8643919999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>where <strong>n</strong> is the order of the polynomial, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">x^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> denotes x raised to the power of j.<br>
The polynomial coefficients <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, … , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are collectively denoted by the vector <strong>w</strong>.<br>
Note that, although the polynomial function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y(x, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> is a nonlinear function of x, it is a linear function of the coefficients <strong>w</strong>.</p>
<p>The values of the coefficients will be determined by fitting the polynomial to the training data. This can be done by minimizing an <strong>error function</strong> that measures the misfit between the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y(x, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>, for any given value of <strong>w</strong>, and the training set data points.</p>
<p>One simple choice of error function, which is widely used, is given by the sum of the squares of the errors between the predictions <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y(x_n, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> for each data point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the corresponding target values <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, so that we minimize</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>E</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>t</mi><mi>n</mi></msub><msup><mo stretchy="false">}</mo><mn>2</mn></msup></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1.2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E(w) = \frac{1}{2} \sum_{n=1}^N \{y(x_n, w) - t_n\}^2 \tag{1.1.2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>where the factor of 1/2 is included for later convenience. We can solve the curve fitting problem by choosing the value of <strong>w</strong> for which <strong>E(w)</strong> is as small as possible.</p>
<p>It is sometimes more convenient to use the root-mean-square</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>E</mi><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow></msub><mo>=</mo><msqrt><mfrac><mrow><mn>2</mn><mi>E</mi><mo stretchy="false">(</mo><msup><mi>w</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac></msqrt></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1.3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E_{RMS} = \sqrt\frac{2E(w^*)}{N} \tag{1.1.3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7356250000000002em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7043749999999998em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6146959999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span style="top:-3.664375em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width="400em" height="2.48em" viewbox="0 0 400000 2592" preserveaspectratio="xMinYMin slice"><path d="M424,2478c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,
-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,
25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,
-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079
c169.3,-717.3,254.7,-1077.7,256,-1081c4,-6.7,10,-10,18,-10H400000v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80H400000v40H1014z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7356250000000002em;"><span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:2.44em;vertical-align:-0.7356250000000002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>in which the division by N allows us to compare different sizes of data sets on an equal footing, and the square root ensures that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">E_{RMS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is measured on the same scale (and in the same units) as the target variable t.</p>
<p>there is something rather unsatisfying about <strong>having to limit the number of parameters in a model according to the size of the available training set</strong>. It would seem more reasonable to choose the complexity of the model according to the complexity of the problem being solved. We shall see that the <strong>least squares approach to finding the model parameters represents a specific case of maximum likelihood</strong>, and that <strong>the over-fitting problem can be understood as a general property of maximum likelihood</strong>. By adopting a Bayesian approach, the over-fitting problem can be avoided. We shall see that there is no difficulty from a Bayesian perspective in employing models for which the number of parameters greatly exceeds the number of data points. Indeed, in a Bayesian model the effective number of parameters adapts automatically to the size of the data set</p>
<p>For the moment, however, it is instructive to continue with the current approach and to consider how in practice we can apply it to data sets of limited size where we may wish to use relatively complex and flexible models. <strong>One technique that is often used to control the over-fitting phenomenon in such cases is that of regularization</strong>, which involves adding <strong>a penalty term</strong> to the error function (1.1.2) in order to discourage the coefficients from reaching large values. The simplest such penalty term takes the form of a sum of squares of all of the coefficients, leading to a modified error function of the form</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mtext>E</mtext><mo>˜</mo></mover><mtext>(w)</mtext></mrow><mo>≡</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>t</mi><mi>n</mi></msub><msup><mo stretchy="false">}</mo><mn>2</mn></msup><mo>+</mo><mfrac><mi>λ</mi><mn>2</mn></mfrac><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1.4)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle \text{\~{E}(w)} \equiv \frac{1}{2}\sum_{n=1}^{N}\{y(x_n, w) - t_n\}^2 + \frac{\lambda}{2}||w||^2 \tag{1.1.4}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.17019em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9201900000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">E</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">˜</span></span></span></span></span></span><span class="mord">(w)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>≡</mo><mrow><msup><mi mathvariant="bold">w</mi><mi mathvariant="bold">⊤</mi></msup><mrow><mi mathvariant="bold">w</mi><mrow><mo>=</mo><msubsup><mi mathvariant="normal">w</mi><mn>0</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi mathvariant="normal">w</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msubsup><mi mathvariant="normal">w</mi><mi mathvariant="normal">m</mi><mn>2</mn></msubsup></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">||w||^2 \equiv\bf{w}^\top\bf{w}\rm{=w_0^2 + w_1^2 + ... + w_m^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mord"><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.01389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.01389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.01389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span>, and the coefficient λ governs the relative importance of the regularization term compared with the sum-of-squares error term.</p>
<blockquote>
<p>Note that often the coefficient w0 is omitted from the regularizer because its inclusion causes the results to depend on the choice of origin for the target variable (Hastie et al., 2001), or it may be included but with its own regularization coefficient.</p>
</blockquote>
<p>Again, the error function in (1.1.4) can be minimized exactly in closed form. Techniques such as this are known in the statistics literature as <strong>shrinkage methods</strong> because they reduce the value of the coefficients. The particular case of a quadratic regularizer is called ridge regres- sion (Hoerl and Kennard, 1970). In the context of neural networks, this approach is known as weight decay.</p>
<h3 id="probability-theory"><a class="markdownIt-Anchor" href="#probability-theory"></a> Probability Theory</h3>
<h4 id="probability-densities"><a class="markdownIt-Anchor" href="#probability-densities"></a> Probability densities</h4>
<p>A key concept in the field of pattern recognition is that of uncertainty. It arises both through noise on measurements, as well as through the finite size of data sets. Prob- ability theory provides a consistent framework for the quantification and manipula- tion of uncertainty and forms one of the central foundations for pattern recognition. Combined with <strong>decision theory</strong>, it allows us to make optimal predictions given all the information available to us, even though that information may be incomplete or ambiguous.</p>
<p>The probability that X will take the value <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and Y will take the value <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is written <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X = x_i,Y = y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and is called the <em>joint probability</em> of X = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Y = y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> . It is given by the number of points falling in the cell i,j as a fraction of the total number of points, and hence</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>N</mi></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(X = x_i, Y = y_j) = \frac{n_{ij}}{N} \tag{1.2.1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Here we are implicitly considering the limit <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">N \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>. Similarly, the probability that X takes the value <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> irrespective of the value of Y is written as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X = x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and is given by the fraction of the total number of points that fall in column i, so that</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><msub><mi>c</mi><mi>i</mi></msub><mi>N</mi></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(X = x_i) = \frac{c_i}{N} \tag{1.2.2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Because the number of instances in column i is just the sum of the number of instances in each cell of that column, we have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_i = \sum_jn_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> nij and therefore, from (1.2.1) and (1.2.2), we have</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(X = x_i) = \sum_{j=1}^Lp(X = x_i, Y = y_j) \tag{1.2.3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2421130000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:3.2421130000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>which is the sum rule of probability. Note that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X = x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is sometimes called the <strong>marginal probability</strong>, because it is obtained by marginalizing, or summing out, the other variables (in this case Y ).</p>
<p>If we consider only those instances for which <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X = x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, then the fraction of such instances for which <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Y = y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is written <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo>=</mo><mi>y</mi><mi>j</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>=</mo><mi>x</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(Y = yj|X = xi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> and is called the <strong>conditional probability</strong> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Y = y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X = x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. It is obtained by finding the fraction of those points in column i that fall in cell i,j and hence is given by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>c</mi><mi>i</mi></msub></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.4)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(Y = y_j|X = x_i) = \frac{n_{ij}}{c_i} \tag{1.2.4}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94356em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:1.94356em;vertical-align:-0.8360000000000001em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>From (1.2.1), (1.2.2), (1.2.4) we can then derive the following relationship</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>N</mi></mfrac><mo>=</mo><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>c</mi><mi>i</mi></msub></mfrac><mo>⋅</mo><mfrac><msub><mi>c</mi><mi>i</mi></msub><mi>N</mi></mfrac><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(X = x_i, Y = y_j) = \frac{n_{ij}}{N} = \frac{n_{ij}}{c_i} \cdot \frac{c_i}{N} = p(Y = y_j|X = x_i) \cdot p(X = x_i) \tag{1.2.5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94356em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1.94356em;vertical-align:-0.8360000000000001em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>which is the product rule of probability.</p>
<p>two fundamental rules of probability theory in the following form.</p>
<blockquote>
<ul>
<li><strong>sum rule</strong></li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>Y</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.6)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(X) = \sum_Yp(X,Y) \tag{1.2.6}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.344341em;vertical-align:-1.294336em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.344341em;vertical-align:-1.294336em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<ul>
<li><strong>product rule</strong></li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.7)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(X,Y) = p(Y|X) \cdot p(X) \tag{1.2.7}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">7</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>From the product rule, together with the symmetry property <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X, Y ) = p(Y, X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>, we immediately obtain the following relationship between conditional probabilities</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.8)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(Y|X) = \frac{p(X|Y) \cdot p(Y)}{p(X)} \tag{1.2.8}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">8</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>which is called Bayes’ theorem and which plays a central role in pattern recognition and machine learning.</p>
<p>Using the sum rule, the denominator in Bayes’ theorem can be expressed in terms of the quantities appearing in the numerator</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>Y</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.9)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(X) = \sum_Yp(X|Y) \cdot p(Y) \tag{1.2.9}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.344341em;vertical-align:-1.294336em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.344341em;vertical-align:-1.294336em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">9</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>We can view the denominator in Bayes’ theorem as being the normalization constant required to ensure that the sum of the conditional probability on the left-hand side of (1.2.8) over all values of Y equals one.</p>
<h4 id="probability-densities-2"><a class="markdownIt-Anchor" href="#probability-densities-2"></a> Probability densities</h4>
<p>As well as considering probabilities defined over discrete sets of events, we also wish to consider probabilities with respect to continuous variables. If the probability of a real-valued variable x falling in the interval <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mi>δ</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, x + δx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> is given by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">p(x)δx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mi>x</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">δx \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> is called the probability density over x. The probability that x will lie in an interval <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> is then given by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.10)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(x \in (a, b)) = \int_{a}^{b}p(x)dx\tag{1.2.10}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span><span class="tag"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Because probabilities are nonnegative, and because the value of x must lie somewhere on the real axis, the probability density p(x) must satisfy the two conditions</p>
<blockquote>
<ul>
<li>probabilities are nonnegativ</li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.11)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p(x)  \ge 0 \tag{1.2.11}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<ul>
<li>integrad of probability density is 1</li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.12)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\int_{-\infty }^{\infty}p(x)dx = 1 \tag{1.2.12}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.384573em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:2.384573em;vertical-align:-0.970281em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Under a nonlinear change of variable, a probability density transforms differently from a simple function, due to the Jacobian factor. For instance, if we consider a change of variables <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = g(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, then a function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> becomes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(y) = f(g(y))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. Now consider a probability density <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_x(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> that corresponds to a density <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_y(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> with respect to the new variable y, where the suffices denote the fact that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_x(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_y(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> are different densities. Observations falling in the range <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mi>δ</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, x + δx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> will, for small values of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">δx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span></span></span></span>, be transformed into the range <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>δ</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y, y + δy)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>δ</mi><mi>x</mi><mo>⋍</mo><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mi>δ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">px(x)δx \backsimeq py(y)δy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⋍</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, and hence</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mi>p</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mi mathvariant="normal">∣</mi><mspace linebreak="newline"></mspace><mspace width="4.2em"></mspace><mo>=</mo><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msup><mi>g</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.13)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">p_y(y)  = p_x(x) |\frac{dx}{dy}| \\ \hspace{4.2em} = p_x(g(y)) |g^{&#x27;}(y)| \tag{1.2.13}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mspace" style="margin-right:4.2em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">∣</span></span><span class="tag"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>One consequence of this property is that the concept of the maximum of a probability density is dependent on the choice of variable.<br>
The probability that x lies in the interval <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">−</mi><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(−\infty,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> is given by the <strong>cumulative distribution function(CDF)</strong> defined by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mi mathvariant="normal">∞</mi><mi>z</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.14)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">P(z) = \int_{\infty}^zp(x)dx \tag{1.2.14}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4142920000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span><span class="tag"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>which satisfies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P^{&#x27;}(x) = p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.19248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>If we have several continuous variables <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">x_1 , . . . , x_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , denoted collectively by the vector x, then we can define a joint probability density <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x) = p(x_1 , . . . , x_D )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> such that the probability of x falling in an infinitesimal volume <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">δx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span></span></span></span> containing the point x is given by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">p(x)δx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">x</span></span></span></span>. This multivariate probability density must satisfy <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p(x) \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∫</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int p(x)dx = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11112em;vertical-align:-0.30612em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> in which the integral is taken over the whole of x space. We can also consider joint probability distributions over a combination of <strong>discrete</strong> and <strong>continuous</strong> variables.</p>
<blockquote>
<p>Note that if x is a discrete variable, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> is sometimes called a probability mass function because it can be regarded as a set of ‘probability masses’ concentrated at the allowed values of x.</p>
</blockquote>
<p>The <strong>sum and product rules of probability</strong>, as well as Bayes’ theorem, apply equally to the case of probability densities, or to combinations of discrete and continuous variables. For instance, if x and y are two real variables, then the sum and product rules take the form</p>
<blockquote>
<ul>
<li><strong>sum rule</strong></li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∫</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi>d</mi><mi>y</mi></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.15)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(x) = \int p(x,y)dy \tag{1.2.15}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span><span class="tag"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<ul>
<li><strong>product rule</strong></li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.16)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(x,y) = p(y|x)  p(x) \tag{1.2.16}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span></span><span class="mord">)</span></span></span></span></span></span></p>
<h4 id="expectations-and-covariances"><a class="markdownIt-Anchor" href="#expectations-and-covariances"></a> Expectations and covariances</h4>
<p>One of the most important operations involving probabilities is that of finding weighted averages of functions. The average value of some function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> under a probability distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> is called the expectation of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> and will be denoted by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[f]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span></span></span></span>.</p>
<blockquote>
<ul>
<li>For a <strong>discrete distribution</strong>, the average is weighted by the relative probabilities of the different values of x</li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>x</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.17)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E[f] = \sum_x p(x)f(x) \tag{1.2.17}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">7</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<ul>
<li>For <strong>continuous variables</strong>, expectations are expressed in terms of an integration with respect to the corresponding probability density</li>
</ul>
</blockquote>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo><mo>=</mo><mo>∫</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.18)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E[f] = \int p(x)f(x)dx \tag{1.2.18}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span><span class="tag"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>In either case, if we are given a finite number N of points drawn from the probability distribution or probability density, then the expectation can be approximated as a finite sum over these points</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo><mo>⋍</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munder><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></munder><mi>N</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.19)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E[f] \backsimeq \frac{1}{N}\sum_{n=1}{N}f(x_n) \tag{1.2.19}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⋍</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.588553em;vertical-align:-1.2671130000000002em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8828869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671130000000002em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.588553em;vertical-align:-1.2671130000000002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">9</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Sometimes we will be considering expectations of functions of several variables, in which case we can use a subscript to indicate which variable is being averaged over, so that for instance <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>x</mi></msub><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E_x[f(x,y)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> denotes the average of the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> with respect to the distribution of x. Note that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>x</mi></msub><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E_x[f(x,y)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> will be a function of y.</p>
<p>We can also consider a conditional expectation with respect to a conditional distribution, so that</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>E</mi><mi>x</mi></msub><mo stretchy="false">[</mo><mi>f</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>x</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.20)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle E_x[f|y] = \sum_xp(x|y) f(x) \tag{1.2.20}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">0</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>The variance of f(x) is defined by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">]</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.21)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle var[f] = E[(f(x) - E[f(x)])^2 ] \tag{1.2.21}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span></span><span class="tag"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Expanding out the square, we see that the variance can also be written in terms of the expectations of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.22)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle var[f] = E[f(x)^2] - E[f(x)]^2 \tag{1.2.22}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<p>for variabce of one variable x<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>x</mi><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle var[x] = E[x^2] - E[x]^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<blockquote>
<p>for random variables x and y, the covariance is defined by<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>E</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo stretchy="false">[</mo><mo stretchy="false">{</mo><mi>x</mi><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo stretchy="false">{</mo><mi>y</mi><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo stretchy="false">]</mo><mo>=</mo><msub><mi>E</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo stretchy="false">[</mo><mi>x</mi><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mi>E</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle cov[x,y] = E_{x,y}[\{x - E[x]\}\{y - E[y]\}]  = E_{x,y}[xy] - E[x]E[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">}</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
</blockquote>
<blockquote>
<p>for two vectors of random variables <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\mathbf y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span>, the covariance is a matrix<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">y</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>E</mi><mrow><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">y</mi></mrow></msub><mo stretchy="false">[</mo><mo stretchy="false">{</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo stretchy="false">{</mo><msup><mi mathvariant="bold">y</mi><mi mathvariant="normal">⊤</mi></msup><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><msup><mi mathvariant="bold">y</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo stretchy="false">]</mo><mo>=</mo><msub><mi>E</mi><mrow><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">y</mi></mrow></msub><mo stretchy="false">[</mo><mrow><mi mathvariant="bold">x</mi><msup><mi mathvariant="bold">y</mi><mi mathvariant="bold">⊤</mi></msup></mrow><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo stretchy="false">]</mo><mi>E</mi><mo stretchy="false">[</mo><msup><mi mathvariant="bold">y</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">]</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle cov[\mathbf x, \mathbf y] = E_{\mathbf x, \mathbf y}[\{\mathbf x - E[\mathbf x]\}\{\mathbf y^\top - E[\mathbf y^\top]\}]  = E_{\mathbf x, \mathbf y}[\mathbf {xy^\top}] - E[\mathbf x]E[\mathbf y^\top]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16110799999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mopen">{</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathbf">x</span><span class="mclose">]</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">}</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1852159999999998em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16110799999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathbf">x</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">⊤</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathbf">x</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></p>
</blockquote>
<h4 id="bayesian-probabilities"><a class="markdownIt-Anchor" href="#bayesian-probabilities"></a> Bayesian probabilities</h4>
<p>So far, we have viewed probabilities in terms of the frequencies of random, repeatable events. We shall refer to this as the classical or frequentist interpretation of probability. Now we turn to the more general Bayesian view, in which probabilities provide a quantification of uncertainty.</p>
<p>we can adopt a similar approach when making inferences about quantities such as the parameters <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> in the polynomial curve fitting example. We capture our assumptions about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>, before observing the data, in the form of a prior probability distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. The effect of the observed data <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>N</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D = \{t_1, . . . , t_N \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> is expressed through the conditional probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D|w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>, how this can be represented explicitly. Bayes’ theorem, which takes the form</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.23)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(\mathbf w|D) = \frac{p(D|\mathbf w)p(\mathbf w)}{p(D)} \tag{1.2.23}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>then allows us to evaluate the uncertainty in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> after we have observed D in the form of the posterior probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(w|D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span></p>
<p>The quantity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D|w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> on the right-hand side of Bayes’ theorem is evaluated for the observed data set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> and can be viewed as a function of the parameter vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>, in which case it is called the <strong>likelihood function</strong>.It expresses how probable the observed data set is for different settings of the parameter vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>.</p>
<blockquote>
<p>Note that the likelihood is not a probability distribution over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>, and its integral with respect to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> does not (necessarily) equal one.</p>
</blockquote>
<blockquote>
<p>Given this definition of likelihood, we can state Bayes’ theorem in words: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mo>∝</mo><mi>l</mi><mi>i</mi><mi>k</mi><mi>e</mi><mi>l</mi><mi>i</mi><mi>h</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo>×</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">posterior \propto likelihood \times prior</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> where all of these quantities are viewed as functions of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>.</p>
</blockquote>
<p>The denominator in (1.2.23) is the normalization constant, which ensures that the posterior distribution on the left-hand side is a valid probability density and integrates to one. Indeed, integrating both sides of (1.2.23) with respect to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>, we can express the denominator in Bayes’ theorem in terms of the prior distribution and the likelihood function</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∫</mo><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo><mi>d</mi><mi mathvariant="bold">w</mi></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.24)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(D) = \int p(D|\mathbf w)p(\mathbf w)d\mathbf w \tag{1.2.24}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="tag"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>In both the Bayesian and frequentist paradigms, the likelihood function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D|\mathbf w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span></span></span></span> plays a central role. However, the manner in which it is used is fundamentally different in the two approaches. In a frequentist setting, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\bf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span> is considered to be a fixed parameter, whose value is determined by some form of ‘estimator’, and error bars on this estimate are obtained by considering the distribution of possible data sets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>. By contrast, from the Bayesian viewpoint there is only a single data set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> (namely the one that is actually observed), and the uncertainty in the parameters is expressed through a probability distribution over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>.</p>
<p>A widely used frequentist estimator is <strong>maximum likelihood</strong>, in which <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> is set to the value that maximizes the likelihood function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D|\mathbf w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span></span></span></span>. This corresponds to choosing the value of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> for which the probability of the observed data set is maximized. <strong>In the machine learning literature, the negative log of the likelihood function is called an error function</strong>. Because the negative logarithm is a monotonically decreasing function, maximizing the likelihood is equivalent to minimizing the error.</p>
<h4 id="the-gaussian-distribution"><a class="markdownIt-Anchor" href="#the-gaussian-distribution"></a> The Gaussian distribution</h4>
<p>For the case of a single real-valued variable x, the Gaussian distribution is defined by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi mathvariant="normal">N</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup><msup><mo stretchy="false">)</mo><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mfrac><msup><mstyle mathsize="2.074em"><mi>e</mi></mstyle><mrow><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msup></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.25)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\Nu(x|\mu, \sigma^2) = \frac{1}{(2\pi\sigma^2)^{1/2}} {\huge  e}^{-\frac{1}{2\sigma^2}(x - \mu)^2} \tag{1.2.25}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.2754399999999997em;vertical-align:-0.954em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord"><span class="mord mathdefault sizing reset-size6 size10">e</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2698014399999997em;"><span style="top:-3.64588144em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:2.2754399999999997em;vertical-align:-0.954em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<p>which is governed by two parameters: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">μ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>, called the <strong>mean</strong>, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">σ2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord">2</span></span></span></span>, called the <strong>variance</strong>. The square root of the variance, given by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>, is called the <strong>standard deviation</strong>, and the reciprocal of the variance, written as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">β = 1/σ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, is called the <strong>precision</strong>.</p>
</blockquote>
<p>From the form of (1.2.25) we see that the Gaussian distribution satisfies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">N</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Nu(x|\mu, \sigma^2) &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. Also it is straightforward to show that the Gaussian is normalized, so that</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msubsup><mo>∫</mo><mi mathvariant="normal">∞</mi><mi mathvariant="normal">∞</mi></msubsup><mi mathvariant="normal">N</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.26)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\int _{\infty}^\infty \Nu(x|\mu, \sigma^2)dx = 1 \tag{1.2.26}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4142920000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">6</span></span><span class="mord">)</span></span></span></span></span></span></p>
<blockquote>
<p>Proof the form (1.2.26) with standard gaussian distribution(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>σ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu = 0, \sigma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>), the common gaussian distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mu, \sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span> can be linear transform of the standard one.<br>
gaussian distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle f(x) = \frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4211080000000003em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span><br>
standard gaussian distribution  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle f(x) = \frac{1}{\sqrt{2\pi } }exp(-\frac{x^{2}}{2})\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4211080000000003em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span><br>
since <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>y</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>y</mi><mspace linebreak="newline"></mspace></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{x^{2}}{2})dx = \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{y^{2}}{2})dy\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span><span class="mspace newline"></span></span></span><br>
then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>y</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mi>d</mi><mi>y</mi><mspace linebreak="newline"></mspace></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{x^{2}}{2})dx\int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{y^{2}}{2})dy = \frac{1}{2\pi}\int_{-\infty }^{+\infty }\int_{-\infty }^{+\infty }exp(-\frac{(x^{2}+y^{2})}{2})dxdy\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span><span class="mspace newline"></span></span></span><br>
image that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mi>r</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x = r\cos\theta, y = r\sin\theta \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace newline"></span></span></span><br>
then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mi>d</mi><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mn>0</mn><mrow><mn>2</mn><mi>π</mi></mrow></msubsup><msubsup><mo>∫</mo><mn>0</mn><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>r</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>r</mi><mi>d</mi><mi>r</mi><mi>d</mi><mi>θ</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{1}{2\pi}\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}exp(-\frac{(x^{2}+y^{2})}{2})dxdy = \frac{1}{2\pi}\int_{0}^{2\pi}\int_{0}^{+\infty }exp(-\frac{r^{2}}{2})rdrd\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4759580000000003em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mi>d</mi><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>r</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>r</mi><mi>d</mi><mi>r</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{1}{2\pi}\int_{-\infty }^{+\infty }\int_{-\infty }^{+\infty }exp(-\frac{(x^{2}+y^{2})}{2})dxdy = \int_{0}^{+\infty }exp(-\frac{r^{2}}{2})rdr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4331810000000003em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><br>
image that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><msup><mi>r</mi><mn>2</mn></msup><mn>2</mn></mfrac><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">t = \frac{r^{2}}{2} \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span></span></span><br>
then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mn>0</mn><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>r</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>r</mi><mi>d</mi><mi>r</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>=</mo><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{0}^{+\infty }exp(-\frac{r^{2}}{2})rdr = \int_{0}^{+\infty }exp(-t)dt = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4331810000000003em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4331810000000003em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>y</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>y</mi><mo>=</mo><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{x^{2}}{2})dx = \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi } }exp(-\frac{y^{2}}{2})dy = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<blockquote>
<p>as the normal gaussion distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> satisfies<br>
translate rule: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{-\infty }^{+\infty }f(x)dx =\int_{-\infty }^{+\infty }f(x-c)dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span><br>
scale rule: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mi>a</mi></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mfrac><mi>x</mi><mi>a</mi></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{-\infty }^{+\infty }f(x)dx =\frac{1}{a}\int_{-\infty }^{+\infty }f(\frac{x}{a})dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></p>
</blockquote>
<blockquote>
<p>so the integral of any gaussion distribution density function equals 1</p>
</blockquote>
<blockquote>
<p>mean of guassion distribution：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mi>x</mi><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mi mathvariant="normal">（</mi><mi>x</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">）</mi><mi>d</mi><mi>x</mi><mo>+</mo><mi>μ</mi><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">E(x) = \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})xdx = \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})（x-\mu）dx + \mu\int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6469199999999997em;vertical-align:-0.5379999999999999em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6469199999999997em;vertical-align:-0.5379999999999999em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mord cjk_fallback">）</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.6469199999999997em;vertical-align:-0.5379999999999999em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></p>
</blockquote>
<blockquote>
<p>as the gaussion distribution is symmetric ：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex">E(x) = \mu\int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})dx = \mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6469199999999997em;vertical-align:-0.5379999999999999em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span></p>
</blockquote>
<blockquote>
<p>variance of guassion distribution：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Var(x) = \int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{(x-\mu)^{2}}{2\sigma^{2}})(x-\mu)^{2}dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6469199999999997em;vertical-align:-0.5379999999999999em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></p>
</blockquote>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><msup><mi>y</mi><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><msup><mi>y</mi><mn>2</mn></msup><mi>d</mi><mi>y</mi><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\int_{-\infty }^{+\infty }\frac{1}{\sqrt{2\pi }\sigma }exp(-\frac{y^{2}}{2\sigma^{2}})y^{2}dy = \sigma^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.608028em;vertical-align:-0.5379999999999999em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.070028em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h4 id="curve-fitting-re-visited"><a class="markdownIt-Anchor" href="#curve-fitting-re-visited"></a> Curve fitting re-visited</h4>
<p>We have seen how the problem of polynomial curve fitting can be expressed in terms of error minimization. Here we return to the curve fitting example and view it from a probabilistic perspective, thereby gaining some insights into error functions and regularization, as well as taking us towards a full Bayesian treatment.</p>
<p>The goal in the curve fitting problem is to be able to make predictions for the target variable t given some new value of the input variable x on the basis of a set of training data comprising N input values <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf x = (x_1 , . . . , x_N )^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span> and their corresponding T target values <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">t</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>N</mi></msub><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf t = (t_1 , . . . , t_N )^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63492em;vertical-align:0em;"></span><span class="mord mathbf">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span> . We can express our uncertainty over the value of the target variable using a probability distribution. For this purpose, we shall assume that, given the value of x, the corresponding value of t has a Gaussian distribution with a mean equal to the value <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y(x, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> of the polynomial curve given  Thus we have</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">N</mi><mo stretchy="false">(</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>β</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.25)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(t|x, \mathbf w, \beta) = \Nu(t|w(x, \mathbf w), \beta^{-1}) \tag{1.2.25}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>where we have defined a precision parameter <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> corresponding to the inverse variance of the distribution.</p>
<p><img alt="schematic_illustration_of_gaussian_conditional_distribution" data-src="/assets/2019/12/10/schematic_illustration_of_gaussian_conditional_distribution.jpg"></p>
<blockquote>
<p>Schematic illustration of a Gaussian conditional distribution for t given x given by (1.2.25), in which the mean is given by the polynomial function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y(x,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>, and the precision is given by the parameter <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>, which is related to the variance by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>β</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\beta^{-1} = \sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>We now use the training data <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x, t\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">}</span></span></span></span> to determine the values of the unknown parameters <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> by maximum likelihood. If the data are assumed to be drawn independently from the distribution (1.2.25), then the likelihood function is given by</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">t</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi mathvariant="normal">N</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">∣</mi><mi>y</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mi mathvariant="bold">w</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>β</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mstyle></mtd><mtd width="50%"></mtd><mtd><mtext>(1.2.26)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\displaystyle p(\mathbf t|\mathbf x, \mathbf w, \beta) = \prod_{n=1}^{N} \Nu(t_n|y(x_n, \mathbf w), \beta^{-1}) \tag{1.2.26}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathbf">t</span><span class="mord">∣</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">6</span></span><span class="mord">)</span></span></span></span></span></span></p>
<h4 id="bayesian-curve-fitting"><a class="markdownIt-Anchor" href="#bayesian-curve-fitting"></a> Bayesian curve fitting</h4>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision Algorithms And Applications</title>
    <url>/computer-vision/computer-vision-algorithms-and-applications.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>图像处理算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 Template (模板编程)</title>
    <url>/program/C++11-Template.html</url>
    <content><![CDATA[<h2 id="c-template"><a class="markdownIt-Anchor" href="#c-template"></a> C++ Template</h2>
<h3 id="模板基础"><a class="markdownIt-Anchor" href="#模板基础"></a> 模板基础</h3>
<h4 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h4>
<h5 id="定义模板"><a class="markdownIt-Anchor" href="#定义模板"></a> 定义模板</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">tmax</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &lt; b ? b: a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="使用模板"><a class="markdownIt-Anchor" href="#使用模板"></a> 使用模板</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">max(<span class="number">32</span>, <span class="number">43</span>);</span></pre></td></tr></table></figure>
<blockquote>
<p>通常而言，并不是把模板编译成一个可以处理任何类型的单一实体。<br>
而是对于实例化模板参数的每种类型，都从模板产生一个不同的实体。<br>
这种用具体类型代替模板参数的过程叫做实例化，它产生了一个模板的实例。</p>
</blockquote>
<p>由此，我们可以得出一个结论：模板被编译了两次，分别发生在：</p>
<ol>
<li>实例化之前，先检查模板代码本身，查看语法是否正确；在这里会发现错误的语法，如遗漏分号等。</li>
<li>在实例化期间，检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用(该类型没有提供模板所需要使用到的操作)等。</li>
</ol>
<h5 id="实参的演绎deduction"><a class="markdownIt-Anchor" href="#实参的演绎deduction"></a> 实参的演绎（deduction）</h5>
<blockquote>
<p>模板实参不允许进行自动类型转换；每个T都必须正确地匹配。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">max(<span class="number">4</span>, <span class="number">4.3</span>); <span class="comment">// Error:第1个参数类型是int，第2个参数类型是double</span></span></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="模板参数"><a class="markdownIt-Anchor" href="#模板参数"></a> 模板参数</h5>
<p>函数模板有两种类型的参数</p>
<ul>
<li>模板参数：位于函数模板名称的前面，在一对尖括号内部进行声明：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">// T是模板参数</span></span></pre></td></tr></table></figure>
<ul>
<li>调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...max(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b);        <span class="comment">// a和b都是调用参数</span></span></pre></td></tr></table></figure>
<p><strong>函数模板和类模板区别：</strong></p>
<blockquote>
<p>函数模板可以进行模板实参演绎(不能演绎返回类型)、重载、指定缺省调用实参、全局特化；<s>不能指定缺省模板实参</s>(已经可以了)，<s>不能局部特化</s>；类模板可以指定缺省模板实参、指定全局特化和局部特化(用来完成类似函数模板重载功能)；不能重载类模板，不能进行实参演绎。</p>
</blockquote>
<p><strong>显式实例化：</strong></p>
<blockquote>
<p>当模板参数和调用参数没有发生关联，或者不能由调用参数来决定模板参数的时候，在调用时就必须显式指定模板实参。切记，模板实参演绎并不适合返回类型。如下</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>;</span></pre></td></tr></table></figure>
<p>那么必须进行显式实例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">max&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">4.3</span>);  <span class="comment">// OK，但很麻烦。这里T1和T2是不同的类型，所以可以指定两个不同类型的实参4和4.3</span></span></pre></td></tr></table></figure>
<p>通常而言，你必须指定“最后一个不能被隐式演绎的模板实参之前的”所有实参类型。上面的例子中，改变模板参数的声明顺序，那么调用者就只需要指定返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">4.3</span>); <span class="comment">// ok，返回类型是double</span></span></pre></td></tr></table></figure>
<h5 id="重载函数模板"><a class="markdownIt-Anchor" href="#重载函数模板"></a> 重载函数模板</h5>
<ul>
<li>
<p>对于非模板函数和同名的函数模板，如果其他条件都是相同的话，那么在调用的时候，重载解析过程通常会优先调用非模板函数，而不会从该模板产生出一个实例。然而，如果模板可以产生一个具有更好匹配的函数，那么将选择模板。</p>
</li>
<li>
<p><strong>可以显式地指定一个空的模板实参列表，这个语法好像是告诉编译器：只有模板才能匹配这个调用（即便非模板函数更符合匹配条件也不会被调用到），而且所有的模板参数都应该根据调用实参演绎出来</strong>。</p>
</li>
<li>
<p>因为模板是不允许自动类型转化的；但普通函数可以进行自动类型转换，所以当一个匹配既没有非模板函数，也没有函数模板可以匹配到的时候，会尝试通过自动类型转换调用到非模板函数（前提是可以转换为非模板函数的参数类型）</p>
</li>
<li>
<p>在所有重载的实现里面，我们都是通过引用来传递每个实参的。一般而言，在重载函数模板的时候，最好只是改变那些需要改变的内容；就是说，你应该把你的改变限制在下面两种情况：改变参数的数目或者显式地指定模板参数。否则可能会出现非预期的结果。</p>
</li>
<li>
<p>定义一个重载函数A，而在A1(函数A的重载)中调用A，但是，如果直到A1的定义处还没有见到A的定义(也即函数A的定义在函数A1的后面，但函数A1中调用了函数A)，那么并不会调用到这个重载函数A，而会寻找在函数A1之前已经定义了的符合条件的其他函数Ax（即便A是符合条件的非模板函数，而Ax是模板函数，也会由于A的声明太迟，而选择调用Ax）</p>
</li>
</ul>
<h4 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h4>
<h5 id="类模板的stack实现"><a class="markdownIt-Anchor" href="#类模板的stack实现"></a> 类模板的Stack实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems;  <span class="comment">// elements</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;  <span class="comment">// push element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;                <span class="comment">// pop element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">// return top element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;       <span class="comment">// return whether the stack is empty</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> elems.empty();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push(T <span class="keyword">const</span>&amp; elem) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	elems.push_back(elem);  <span class="comment">// append copy of passed elem</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	assert(!elems.empty());</span></pre></td></tr><tr><td class="code"><pre><span class="line">	elems.pop_back();  <span class="comment">// remove last element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top() <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	assert(!elems.empty());</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> elems.back();  <span class="comment">// return copy of last element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个类的类型是Stack&lt;T&gt;,其中T是模板参数。因此，当在声明中需要使用该类的类型时，你必须使用Stack&lt;T&gt;。然而，当使用类名而不是类的类型时，就应该只用Stack;譬如，当你指定类的名称、类的构造函数、析构函数时，就应该使用Stack</p>
<p>为了定义类模板的成员函数，必须指定该成员函数是一个函数模板，而且你还需要使用这个类模板的完整类型限定符</p>
<p>显然，对于类模板的任何成员函数，你都可以把它实现为内联函数，将它定义于类声明里面，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        elems.push_back(elem);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="类模板stack的使用"><a class="markdownIt-Anchor" href="#类模板stack的使用"></a> 类模板Stack的使用</h5>
<p>为了使用类模板对象，必须显式地指定模板实参。</p>
<ol>
<li>只有那些被调用的成员函数，才会产生这些函数的实例化代码。<br>
对于类模板，成员函数只有在被使用的时候才会被实例化。显然，这样可以节省空间和时间；</li>
<li>另一个好处是，对于那些“未能提供所有成员函数中所有操作的”类型，你也可以使用该类型来实例化类模板，只要对那些“未能提供某些操作的”成员函数，模板内部不使用就可以。</li>
<li>如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。</li>
</ol>
<p><strong>切记，要作为模板参数类型，唯一的要求就是：该类型必须提供被调用的所有操作。</strong></p>
<h5 id="类模板的特化"><a class="markdownIt-Anchor" href="#类模板的特化"></a> 类模板的特化</h5>
<p>为了特化一个类模板，你必须在起始处声明一个__template&lt;&gt;__，接下来声明用来特化类模板的类型。这个类型被用作模板实参，且必须在类名的后面直接指定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>进行类模板的特化时，每个成员函数都必须重新定义为普通函数，原来模板函数中的每个T也相应地被进行特化的类型取代。如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elems.push_back(elem);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="局部特化"><a class="markdownIt-Anchor" href="#局部特化"></a> 局部特化</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个模板参数具有相同的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&lt;T, T&gt;   // </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 第2个模板参数的类型是int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&lt;T, int&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 两个模板参数都是指针类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&lt;T1*, T2*&gt;     // 也可以使引用类型<span class="title">T</span>&amp;，常引用等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<blockquote>
<p>局部特化种类1：把模板类型列表里，部分的类型，特化。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt; <span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    M m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> M&gt; <span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;bool, M&gt;&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面的例子，把类型T特化了，类型M保留了，所以是部分特化。也就是当外部使用时，穿进来的T的类型是bool类型的话，就进入到特化定义的类里。</p>
<p> </p>
<blockquote>
<p>局部特化种类2：限定泛化类型，比如限定成指针。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;T*&gt;&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;const T*&gt;&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面的例子，把类型限定了，如果外部穿进来的是指针则有特殊的处理，如果穿进来的是const指针，则有另外的特殊处理。</p>
<h5 id="缺省模板实参"><a class="markdownIt-Anchor" href="#缺省模板实参"></a> 缺省模板实参</h5>
<p>对于类模板，你还可以为模板参数定义缺省值；这些值就被称为缺省模板实参；而且它们还可以引用之前的模板参数。(STL容器使用缺省默认实参指定内存分配其alloc)如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> CONT = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Stack</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2  = <span class="keyword">int</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Sample</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="非类型模板参数"><a class="markdownIt-Anchor" href="#非类型模板参数"></a> 非类型模板参数</h4>
<p><strong>非类型的类模板参数</strong>:</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> MAXSIZE&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>, <span class="number">20</span>&gt; int20Stack;     <span class="comment">// 可以存储20个int元素的栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>, <span class="number">40</span>&gt; int40Stack;     <span class="comment">// 可以存储40个int元素的栈 </span></span></pre></td></tr></table></figure>
</blockquote>
<p>每个模板实例都具有自己的类型，因此int20Stack和int40Stack属于不同的类型，而且这两种类型之间也不存在显式或者隐式的类型转换；所以它们之间不能互相替换，更不能互相赋值。</p>
<blockquote>
<p>然而，如果从优化设计的观点来看，这个例子并不适合使用缺省值。缺省值应该是直观上正确的值。但对于栈的类型和大小而言，int类型和最大容量100从直观上看起来都不是正确的。因此，在这里最好还是让程序员显式地指定这两个值。因此我们可以在设计文档中用一条声明来说明这两个属性（即类型和最大容量）。</p>
</blockquote>
<p><strong>非类型的函数模板参数</strong>:</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> VAL&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T <span class="keyword">const</span>&amp; x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> x + VAL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; </span></pre></td></tr></table></figure>
</blockquote>
<p>借助标准模板库（STL）使用上面例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(source.begin(), source.end(), dest.begin(), addValue&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;);</span></pre></td></tr></table></figure>
<ul>
<li>上面的调用中，最后一个实参实例化了函数模板addValue()，它让int元素增加5.</li>
<li>这个例子有一个问题：addValue&lt;int, 5&gt;是一个函数模板实例，而函数模板实例通常被看成是用来命名一组重载函数的集合（即使该组只有一个函数）。<br>
然而，根据现今的标准，重载函数的集合并不能被用于模板参数的演绎（注意，标准模板库中的函数是使用模板定义的，故而在transform()函数中，参数是作为函数模板调用实参传递的，也即参与了模板参数演绎）。于是，必须将这个函数模板的实参强制类型转换为具体的类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(source.begin(), source.end(), dest.begin(), (<span class="keyword">int</span>(*)(<span class="keyword">int</span> <span class="keyword">const</span>&amp;))addValue&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;);</span></pre></td></tr></table></figure>
<p><strong>非类型模板参数的限制</strong>:</p>
<blockquote>
<p>非类型模板参数是有限制的。<br>
通常而言，它们可以是常整数（包括枚举值）或者指向外部链接对象的指针。<br>
注：浮点数和类对象（class-type)是不允许作为非类型模板参数的。</p>
</blockquote>
<blockquote>
<p>之所以不能使用浮点数（包括简单的常量浮点表达式）作为模板实参是有历史原因的。然而以后可能会支持这个特性。<br>
另外，由于字符串文字是内部链接对象（因为两个具有相同名称但出于不同模块的字符串，是两个完全不同的对象），所以你不能使用它们来作为模板实参</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> <span class="keyword">const</span>* name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">MyClass&lt;<span class="string">"hello"</span>&gt; x;   <span class="comment">// ERROR:不允许使用字符文字"hello"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//另外，你也不能使用全局指针作为模板参数：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> <span class="keyword">const</span>* name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* s = <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">MyClass&lt;s&gt; x;   <span class="comment">// s是一个指向内部链接对象的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//然而，你可以这样使用：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> <span class="keyword">const</span>* name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> <span class="keyword">const</span> s[] = <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">MyClass&lt;s&gt; x;   <span class="comment">// OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//全局字符数组s由“hello”初始化，是一个外部链接对象。</span></span></pre></td></tr></table></figure>
<h4 id="技巧性基础知识"><a class="markdownIt-Anchor" href="#技巧性基础知识"></a> 技巧性基础知识</h4>
<h5 id="关键字typename"><a class="markdownIt-Anchor" href="#关键字typename"></a> 关键字typename:</h5>
<p>C++标准化过程中，引入关键字typename是为了说明：模板内部的标识符可以是一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这里的typename被用来说明：T::SubType是定义于类T内部的一种类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typename</span> T::SubType* ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="使用this-"><a class="markdownIt-Anchor" href="#使用this-"></a> 使用this-&gt;</h5>
<p>考虑例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base&lt;T&gt;    <span class="comment">// 模板基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             <span class="built_in">exit</span>();    <span class="comment">// 调用外部的exit()或者出现错误，而不会调用模板基类的exit()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<blockquote>
<p>对于那些在基类中声明，并且依赖于模板参数的符号（函数或者变量等），你应该在它们前面使用this-&gt;或者Base<t>::限定符。如果希望完全避免不确定性，你可以（使用诸如this-&gt;和Base<t>::等）限定（模板中）所有的成员访问。（这两种限定符的详细信息会在本系列文章后面讲解）</t></t></p>
</blockquote>
<h5 id="成员模板"><a class="markdownIt-Anchor" href="#成员模板"></a> 成员模板</h5>
<p>对于类模板而言，其实例化只有在类型完全相同才能相互赋值。我们通过定义一个身为模板的赋值运算符（成员模板），来达到两个不同类型（但类型可以转换）的实例进行相互赋值的目的，如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="模板的模板参数"><a class="markdownIt-Anchor" href="#模板的模板参数"></a> 模板的模板参数</h5>
<p>还是以Stack为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ELEM,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> ALLOC = <span class="built_in">std</span>::allocator&lt;ELEM&gt; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                        class CONT = <span class="built_in">std</span>::<span class="built_in">deque</span> &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Stack</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<ol>
<li>上面作为模板参数里面的class 不能用typename代替；</li>
<li>还有一个要知道：函数模板并不支持模板的模板参数。</li>
<li>之所以需要定义“ALLOC”，是因为模板的模板实参“std::deque”具有一个缺省模板参数，为了精确匹配模板的模板参数；</li>
</ol>
<h5 id="零初始化"><a class="markdownIt-Anchor" href="#零初始化"></a> 零初始化</h5>
<p>对于int、double或者指针等基本类型，并不存在“用一个有用的缺省值来对它们进行初始化”的缺省构造函数；相反，任何未被初始化的局部变量都具有一个不确定值。如果我们希望我们的模板类型的变量都已经用缺省值初始化完毕，那么针对内建类型，我们需要做一些处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T x = T();   <span class="comment">// 如果T是内建类型，x是0或者false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;；</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板：初始化列表来初始化模板成员</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClass() : x() &#123;&#125;  <span class="comment">// 确认x已被初始化，内建类型对象也是如此</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="使用字符串作为函数模板的实参"><a class="markdownIt-Anchor" href="#使用字符串作为函数模板的实参"></a> 使用字符串作为函数模板的实参</h5>
<p>有时，把字符串传递给函数模板的引用参数会导致出人意料的运行结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，method1:引用参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//method2:非引用参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">max2</span><span class="params">(T a, T  b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 引用参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max(<span class="string">"apple"</span>, <span class="string">"peach"</span>);    <span class="comment">// OK, 相同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max(<span class="string">"apple"</span>, <span class="string">"tomato"</span>);    <span class="comment">// ERROR, 不同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max(<span class="string">"apple"</span>, s);      <span class="comment">// ERROR, 不同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 非引用参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max2(<span class="string">"apple"</span>, <span class="string">"peach"</span>);    <span class="comment">// OK, 相同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max2(<span class="string">"apple"</span>, <span class="string">"tomato"</span>);    <span class="comment">// OK, 退化(decay)为相同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ::max2(<span class="string">"apple"</span>, s);      <span class="comment">// ERROR, 不同类型的实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>method1的问题在于：由于长度的区别，这些字符串属于不同的数值类型。也就是说，“apple”和“peach”具有相同的类型char const[6]；然而“tomato”的类型则是char const[7]。</p>
</blockquote>
<blockquote>
<p>method2调用正确的原因是：对于非引用类型的参数，在实参演绎的过程中，会出现数组到指针的类型转换（这种转型通常也被称为decay）。</p>
</blockquote>
<p><strong>小结：</strong><br>
如果遇到一个关于字符数组和字符指针之间不匹配的问题，你会意外地发现和这个问题会有一定的相似之处。这个问题并没有通用的解决方法，根据不同情况，可以：</p>
<ol>
<li>使用非引用参数，取代引用参数（然而，这可能会导致无用的拷贝）；</li>
<li>进行重载，编写接收引用参数和非引用参数的两个重载函数（然而，这可能会导致二义性）；</li>
<li>对具体类型进行重载（譬如对std::string进行重载）；</li>
<li>重载数组类型，譬如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N, <span class="keyword">int</span> M&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(T <span class="keyword">const</span> (&amp;a)[N], T <span class="keyword">const</span> (&amp;b)[M])</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ol start="5">
<li>强制要求应用程序程序员使用显式类型转换。<br>
对于当前的例子，最好的方法是为字符串重载max().无论如何，为字符串提供重载都是必要的，否则比较的将是两个字符串的地址。</li>
</ol>
<h4 id="模板术语"><a class="markdownIt-Anchor" href="#模板术语"></a> 模板术语</h4>
<p><strong>类模板__还是__模板类</strong></p>
<blockquote>
<p>在C++中，类和联合（union）都被称为类类型（class type）。如果不加额外的限定，我们通常所说的“类（class）”是指：用关键字class或者struct引入的类类型。需要特别注意的一点就是：类类型包括联合，而“类”不包括联合。</p>
</blockquote>
<p><strong>实例化__和__特化</strong></p>
<blockquote>
<p>模板实例化是一个通过使用具体值替换模板实参，从模板产生出普通类、函数或者成员函数的过程。这个过程最后获得的实体（譬如类、函数或成员函数）就是我们通常所说的特化。<br>
然而，在C++中，实例化过程并不是产生特化的唯一方式。程序员可以使用其他机制来显式地指定某个声明，该声明对模板参数进行特定的替换，从而产生特化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;     <span class="comment">// 基本的类模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;    <span class="comment">// 显式特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;std::string, float&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面就是我们通常所讲的显式特化（区别于实例化特化或者其他方式产生的特化）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// 基本的类模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T, T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 局部特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;bool, T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<blockquote>
<p>当谈及（显式或隐式）特化的时候，我们把普通模板称为基本模板。</p>
</blockquote>
<h3 id="深入模板基础"><a class="markdownIt-Anchor" href="#深入模板基础"></a> 深入模板基础</h3>
<h4 id="参数化声明"><a class="markdownIt-Anchor" href="#参数化声明"></a> 参数化声明</h4>
<p>函数模板和类模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>      // 作为名字空间作用域的类模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List(List&lt;T2&gt; <span class="keyword">const</span>&amp;);     <span class="comment">// 成员函数模板（构造函数）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;T&gt;::List(List&lt;T2&gt; <span class="keyword">const</span>&amp; b)&#123;&#125; <span class="comment">// 位于类外部的成员函数模板定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 位于外部名字空间作用域的函数模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(List&lt;T&gt; <span class="keyword">const</span>&amp;)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 联合（Union）模板，往往被看作类模板的一种</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> AllocChunk</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T object;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    usigned <span class="keyword">char</span> bytes[<span class="keyword">sizeof</span>(T)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>两种基本类型的模板之外，还可以使用相似的符号来参数化其他的3种声明。这3种声明分别都有与之对应的类模板成员的定义：</p>
<ol>
<li>类模板的成员函数的定义；</li>
<li>类模板的嵌套类成员的定义；</li>
<li>类模板的静态数据成员的定义；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CupBoard</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Shelf</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> total_weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CupBoard&lt;I&gt;::open()&#123; ... &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CupBoard</span>&lt;I&gt;:</span>:Shelf &#123; ... &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> CupBoard&lt;I&gt;::total_weight = <span class="number">0.0</span>;</span></pre></td></tr></table></figure>
<blockquote>
<p>Template parameters may be of any of the three kinds of C++ entities: values, types, or templates:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>;</span>                        <span class="comment">// N is a value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span>;</span>              <span class="comment">// T is a type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">X</span>&gt; <span class="title">struct</span> <span class="title">Zip</span>;</span>  <span class="comment">// X is a template</span></span></pre></td></tr></table></figure>
<p>usage:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="number">10</span>&gt; a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bar&lt;<span class="keyword">int</span>&gt; b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Zip&lt;Bar&gt; c;</span></pre></td></tr></table></figure>
<p>Note that this corresponds to the three ways of disamiguating dependent names:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X::a = <span class="number">10</span>;              <span class="comment">// X::a is a value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> X::B n = <span class="number">10</span>;   <span class="comment">// X::B is a type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X::<span class="keyword">template</span> C&lt;<span class="keyword">int</span>&gt; m;   <span class="comment">// X::C is a template</span></span></pre></td></tr></table></figure>
<h4 id="虚成员函数"><a class="markdownIt-Anchor" href="#虚成员函数"></a> 虚成员函数</h4>
<p><strong>成员函数模板不能被声明为虚函数</strong>。<br>
这是一种需要强制执行的限制，因为虚函数调用机制的普遍实现都使用了一个大小固定的表，每个虚函数都对应表的一个入口。然而，成员函数模板的实例化个数，要等到整个程序都翻译完毕才能确定，这就和表的大小（是固定的）发生了冲突。如果（将来）要支持虚成员函数模板，将需要一种全新的C++编译器和链接器机制。</p>
<p><strong>类模板的普通成员可以是虚函数</strong>，因为当类被实例化之后，它们的个数是固定的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dynamic</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">virtual</span> ~Dynamic();      <span class="comment">// ok：类模板的普通成员函数，每个Dynamic只对应一个析构函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(T2 <span class="keyword">const</span>&amp;)</span></span>;     <span class="comment">// 错误，在确定Dynamic&lt;T&gt;实例的时候，并不知道copy()的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="模板的链接"><a class="markdownIt-Anchor" href="#模板的链接"></a> 模板的链接</h4>
<p>每个模板都必须有一个名字，而且在它所属的作用域下，该名字必须是唯一的；除非函数模板可以被重载。特别是，类模板不能和另外一个实体共享一个名称，这一点和class类型是不同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> C;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>       <span class="comment">// 正确：类名称和非类名称位于不同的名字空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> X;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>;</span>        <span class="comment">//Error: Redefinition of 'X' as different kind of symbol</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>;</span>           <span class="comment">//Error：Redefinition of 'S' as different kind of symbol</span></span></pre></td></tr></table></figure>
<p>模板名字是具有链接的，当它们不能具有C链接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normal</span><span class="params">()</span></span>;        <span class="comment">// 这是缺省情况，上面的链接规范可以不写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// ERROR: Templates must have C++ linkage</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"Xroma"</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xroma_link</span><span class="params">()</span></span>;        <span class="comment">// 非标准的，当某些编译器将来可能支持写Xroma语言的链接兼容性</span></span></pre></td></tr></table></figure>
<p>模板通常具有外部链接，唯一的例外就是__前面有static修饰符的名字空间作用域下的函数模板__：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为一个声明，引用位于其他文件的、具有相同名称的实体；即引用位于其他文件的external()函数模板，也称前置声明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">external</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 与其他文件中具有相同名称的模板没有关系，即不是外部链接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal</span><span class="params">()</span></span>;</span></pre></td></tr></table></figure>
<blockquote>
<p>因此我们知道（由于外部链接）：不能在函数内部声明模板。</p>
</blockquote>
<h4 id="基本模板"><a class="markdownIt-Anchor" href="#基本模板"></a> 基本模板</h4>
<p>如果模板声明的是一个普通声明，我们就称它声明的是一个基本模板。这类模板声明是指：没有在模板名称后面添加一对尖括号（和里面实参）的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Box</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">(T*)</span></span>;</span></pre></td></tr></table></figure>
<p>显然，当声明局部特化的时候，声明的就是非基本模板。另外，函数模板必须是基本模板。</p>
<h4 id="模板参数-2"><a class="markdownIt-Anchor" href="#模板参数-2"></a> 模板参数</h4>
<p>存在3种模板参数：</p>
<ul>
<li>
<p>类型参数<br>
类型参数是通过关键字typename或者class引入的:它们两者几乎是等同的。在模板声明内部，类型参数的作用类似于typedef（类型定义）名称。例如，如果T是一个模板参数，就不能使用诸如class T 等形式的修饰名称，即使T是一个要被class类型替换的参数也不可以。</p>
</li>
<li>
<p>非类型参数<br>
非类型参数表示的是：在编译期或链接期可以确定的常值。这种参数的类型必须是下面的一种</p>
<ol>
<li>整型或者枚举类型</li>
<li>指针类型（包含普通对象的指针类型、函数指针类型、指向成员的指针类型）</li>
<li>引用类型（指向对象或者指向函数的引用都是允许的)</li>
</ol>
<p>函数和数值类型也可以被指定为非模板参数，但要把它们先隐式地转换为指针类型，这种转型也称为decay:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> buf[<span class="number">5</span>]&gt; <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>;</span>   <span class="comment">// buf实际上是一个int*类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>* buf&gt; <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>;</span>    <span class="comment">// 正确：这是上面的重新声明</span></span></pre></td></tr></table></figure>
<p>非类型模板参数的声明和变量的声明很相似，但它们不能具有static、mutable等修饰符；只能具有const和volatile限定符。但如果这两个限定符限定的如果是最外层的参数类型，编译器将会忽略它们：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> <span class="keyword">const</span> length&gt; <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span>;</span>      <span class="comment">// 这里的const是没用的，被忽略了</span></span></pre></td></tr></table></figure>
<p><strong>非类型模板参数只能是右值：它们不能被取址，也不能被赋值。</strong></p>
</li>
<li>
<p>模板的模板参数<br>
模板的模板参数是代表类模板的占位符（placeholder）。它的声明和类模板的声明很类似，但不能使用关键字struct和union：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">C</span>&lt;int&gt;* <span class="title">p</span>);</span></span></pre></td></tr></table></figure>
<p><strong>对于模板的模板参数而言，它的参数名称只能被自身其他参数的声明使用。</strong></p>
<h4 id="模板实参"><a class="markdownIt-Anchor" href="#模板实参"></a> 模板实参</h4>
<p>模板实参是指：在实例化模板时，用来替换模板参数的值。下面几种机制可以来确定这些值：</p>
<ol>
<li>显式模板实参：紧跟在模板名称后面，在一对尖括号内部的显式模板实参值。所组成的整个实体称为template-id。</li>
<li>注入式(injecter)类名称：对于具有模板参数P1、P2……的类模板X，在它的作用域中，模板名称（即X）等同于template-id：X&lt;P1, P2, ……&gt;。</li>
<li>缺省模板实参：如果提供缺省模板实参的话，在类模板的实例中就可以省略显式模板实参。然而，即使所有的模板参数都具有缺省值，一对尖括号还是不能省略的（即使尖括号内部为空，也要保留尖括号）。</li>
<li>实参演绎：对于不是显式指定的函数模板实参，可以在函数的调用语句中，根据函数调用实参的类型来演绎出函数模板实参。</li>
</ol>
<h5 id="函数模板实参"><a class="markdownIt-Anchor" href="#函数模板实参"></a> 函数模板实参</h5>
<p><strong>显式指定或者实参演绎</strong>。</p>
<blockquote>
<p>对于某些模板实参永远也得不到演绎的机会（比如函数返回值类型）。于是我们最好把这些实参所对应的参数放在模板参数列表的开始处（为了显式指定模板参数T，需要把T放到参数列表最前；为了提供T的缺省模板实参，需要确保参数列表中位于T后面的模板参数也都提供了缺省实参），从而可以显式指定这些参数，而其他参数仍可以进行实参演绎</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">func</span><span class="params">(T <span class="keyword">const</span> &amp;)</span></span>&#123; ... &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> RT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">func1</span><span class="params">(T <span class="keyword">const</span> &amp;)</span></span>&#123; ... &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> value1 = func&lt;<span class="keyword">double</span>&gt;(<span class="number">-1</span>);   <span class="comment">// double 显式指定RT类型，-1实参演绎T类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> value2 = func1&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;(<span class="number">-1</span>);   <span class="comment">// 要显式指定RT的类型，必须同时显式指定它前面的类型T</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h6 id="类型实参"><a class="markdownIt-Anchor" href="#类型实参"></a> 类型实参</h6>
<p>模板的类型实参是一些用来指定模板类型参数的值。我们平时使用的大多数类型都可以被用作模板的类型实参。但有两种情况例外：</p>
<ol>
<li>局部类和局部枚举（换句话说，指在函数定义内部声明的类型）不能作为模板的类型实参；</li>
<li>未命名的class类型或者未命名的枚举类型不能作为模板的类型实参（然而，通过typedef声明给出的未命名类和枚举是可以作为模板类型实参的）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> x, y, z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;Point;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; red, green, blue &#125; *ColorPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Association</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>* p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>* q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	 <span class="comment">// 错误：模板实参中使用了局部类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Association*&gt; error1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 错误：模板实参中使用了未命名的类型，因为typedef定义的是*ColorPtr，并非ColorPtr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;ColorPtr&gt; error2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	 <span class="comment">// 正确：通过使用typedef定义的未命名类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Point&gt; ok;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="非类型实参"><a class="markdownIt-Anchor" href="#非类型实参"></a> 非类型实参</h5>
<p>非类型模板实参是那些替换非类型参数的值。这个值必须是以下几种中的一种：</p>
<ol>
<li>某一个具有正确类型的非类型模板参数；</li>
<li>一个编译期整型常值（或枚举值）；这只有在参数类型和值的类型能够进行匹配，或者值的类型可以隐式地转换为参数类型的前提下，才是合法的。</li>
<li>前面有单目运算符&amp;（即取址）的外部变量或者函数的名称。对于函数或数组变量，&amp;运算符可以省略。这类模板实参可以匹配指针类型的非类型参数。</li>
<li>对于引用类型的非类型模板参数，前面没有&amp;运算符的外部变量和外部函数也是可取的；</li>
<li>一个指向成员的指针常量；换句话说，类似&amp;C::m的表达式，其中C是一个class类型，m是一个非静态成员（成员变量或者函数）。这类实参只能匹配类型为“成员指针”的非类型参数。</li>
</ol>
<p>当实参匹配“指针类型或者引用类型的参数”时，用户定义的类型转换（例如单参数的构造函数和重载类型转换运算符）和由派生类到基类的类型转换，都是不会被考虑的;即使在其他的情况下，这些隐式类型指针是有效的，但在这里都是无效的。隐式类型转换的唯一应用只能是：给实参加上关键字const或者volatile。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T nontyep_param&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span>, <span class="number">33</span>&gt;* c1;  <span class="comment">// 整型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span>*, &amp;a&gt;* c2;         <span class="comment">// 外部变量的地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">void</span>(*)(<span class="keyword">int</span>), f&gt;* c3;     <span class="comment">// 函数名称：在这个例子中，重载解析会选择f(int)，f前面的&amp;隐式省略了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">bool</span>&amp;, X::b&gt;* c4;    <span class="comment">// 静态成员是可取的变量（和函数）名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span> X::*, &amp;X::n&gt;* c5;        <span class="comment">// 指向成员的指针常量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templ_func</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">void</span>(), &amp;templ_func&lt;<span class="keyword">double</span>&gt; &gt;* c6;  <span class="comment">// 函数模板实例同时也是函数</span></span></pre></td></tr></table></figure>
<blockquote>
<p>模板实参的一个普遍约束是：在程序创建的时候，编译器或者链接器要能够确定实参的值。如果实参的值要等到程序运行时才能够确定（譬如，局部变量的地址），就不符合“<strong>模板是在程序创建的时候进行实例化</strong>”的概念了。（模板实参是一个在编译期可以确定的值，这样才符合“模板是在程序创建的时候进行实例化”的概念。）</p>
</blockquote>
<blockquote>
<p>另一方面，有些常值不能作为有效的非类型实参：空指针常量、浮点型值、字符串。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T nontyep_param&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;base;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;derived_obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;Base*, &amp;derived_obj&gt;* err1;       <span class="comment">// 错误：这里不会考虑派生类到基类的类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span>&amp;, base.i&gt;* err2;          <span class="comment">// 错误：域运算符（.）后面的变量不会被看成变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span>*, &amp;a[<span class="number">10</span>]&gt;* err3;      <span class="comment">// 错误：单一数组元素的地址并不是可取的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">C&lt;<span class="keyword">int</span>*, a&gt;* ok;</span></pre></td></tr></table></figure>
<h3 id="模板特化"><a class="markdownIt-Anchor" href="#模板特化"></a> 模板特化</h3>
<h4 id="重载函数模板-2"><a class="markdownIt-Anchor" href="#重载函数模板-2"></a> 重载函数模板</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(T)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(T*)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如果我们用int*来替换第1个模板的T，用int来替换第2个模板的T，那么将会获得两个具有相同参数类型（和返回类型）的同名函数。也就是说，不仅是同名模板可以同时存在，同名各自的实例化体也可以同时存在，即使这些实例化体具有相同的参数类型和返回类型。可以如下调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f&lt;<span class="keyword">int</span>*&gt;((<span class="keyword">int</span>*)<span class="number">0</span>); <span class="comment">//ouputs 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>*)<span class="number">0</span>);  <span class="comment">//outpus 2</span></span></pre></td></tr></table></figure>
<blockquote>
<p>调用f&lt;int*&gt;((int*)0)。语法f&lt;int*&gt;说明我们希望用int<em>来替换模板f的第1个模板参数，而且这种替换并不依赖于模板实参演绎。在这个例子中，有两个f模板，因此所生成的重载集包含了两个函数：f&lt;int</em>&gt;(int*)（生成自第1个模板）和f&lt;int*&gt;(int**)（生成自第2个模板）。然而，调用实参(int*)0的类型是int*，因此它将会和第1个模板生成的函数更好地匹配，最后也就调用这个函数。 类似的分析也可以用于第2个调用。</p>
</blockquote>
<h4 id="显式特化全局特化"><a class="markdownIt-Anchor" href="#显式特化全局特化"></a> 显式特化（全局特化）</h4>
<ol>
<li>类模板和函数模板都可以被全局特化；</li>
<li>类模板能局部特化，不能被重载；</li>
<li>函数模板能被重载，不能被局部特化。</li>
</ol>
<p>特化具有对函数模板进行重载的这种能力，再加上可以利用局部排序规则选择最佳匹配的函数模板，我们就能够给泛型实现添加更加特殊的模板，从而可以透明地获得具有更高效率的代码。</p>
<p>然而，类模板不能被重载；我们可以选择另一种替换的机制来实现这种透明自定义类模板的能力，那就是显式特化。C++标准的“显式特化”概念指的是一种语言特性，我们通常也称之为全局特化。它为模板提供了一种使模板参数可以被全局替换的实现，而没有剩下模板参数。</p>
<p>事实上，类模板和函数模板都是可以被全局特化的，而且类模板的成员（包括成员函数、嵌入类、静态成员变量等，它们的定义可以位于类定义的外部）也可以被全局特化。</p>
<p>局部特化和全局特化有些类似，但局部特化并没有替换所有的模板参数，就是说某些参数化实现仍然保留在模板的（另一种）实现中。实际上，全局特化和局部特化都没有引入一个全新的模板或者模板实例。它们只是对原来的泛型（或者非特化）模板中已经隐式声明的实例提供另一种定义。在概念上，这是一个相对比较重要的现象，也是特化区别于重载模板的关键之处。</p>
<h5 id="全局的类模板特化"><a class="markdownIt-Anchor" href="#全局的类模板特化"></a> 全局的类模板特化</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"generic (S&lt;T&gt;::info() \n)"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fully specialized (S&lt;void&gt;::msg()) \n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<ul>
<li>全局特化的实现不需要与（原来的）泛型实现有任何关联，这就允许我们可以包含不同名称的成员函数（info相对msg）。实际上，全局特化只和类模板的名称有关联。</li>
<li>指定的模板实参列表必须和相应的模板参数列表一一对应。例如，我们不能用一个非类型值来替换一个模板类型参数。然而，如果模板参数具有缺省模板实参，那么用来替换的模板实参就是可选的（即不是必须的）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Types</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">typename</span> Types&lt;T&gt;::I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class S;       <span class="comment">// (1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;void&gt;   // (2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;char, char&gt;;</span>   <span class="comment">// (3)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;char, 0&gt;;</span>         <span class="comment">// 错误：不能用0来替换U</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">int</span>&gt;*       pi;       <span class="comment">// 正确：使用（1），这里不需要定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">int</span>&gt;           e1;       <span class="comment">// 错误：使用（1），需要定义，但找不到定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">void</span>&gt;*     pv;       <span class="comment">// 正确：使用（2）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">void</span>, <span class="keyword">int</span>&gt;       sv;       <span class="comment">// 正确：使用（2），这里定义是存在的，因为模板特化的第2个参数的缺省类型为int类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">void</span>, <span class="keyword">char</span>&gt;       e2;       <span class="comment">// 错误：使用（1），需要定义，但找不到定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    S&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;       e3;       <span class="comment">// 错误：使用（3），需要定义，但找不到定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;char, char&gt;   // (3)处的定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>可见，（模板）全局特化的声明并不一定是定义。另外，当一个全局特化声明之后，针对该（特化的）模板实参列表的调用，将不再使用模板的泛型定义，而是使用这个全局特化的定义。因此，如果在调用处需要该特化的定义，而在这之前并没有提供这个定义，那么程序将会出现错误。对于类模板特化而言，“前置声明”类型有时候是很有用的，因为这样就可以构造相互依赖的类型。另外，以这种方式获得的全局特化声明（应该记住它并不是模板声明）和普通的类声明是类似的，唯一的区别在于语法以及该特化的声明必须匹配前面的模板声明。对于特化声明而言，因为它并不是模板声明，所以应该使用（位于类外部）的普通成员定义语法，来定义全局类模板特化的成员（也就是说，不能指定template&lt;&gt;前缀）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>&lt;char**&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的定义不能使用template&lt;&gt;前缀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> S&lt;<span class="keyword">char</span>**&gt;::print() <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer to pointer to char \n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="全局的函数模板特化"><a class="markdownIt-Anchor" href="#全局的函数模板特化"></a> 全局的函数模板特化</h5>
<p>就语法及其后所蕴涵的原则而言，（显式的）全局函数模板特化和类模板特化大体上是一致的，唯一的区别在于：函数模板特化引入了重载和实参演绎这两个概念。借助实参演绎（用实参类型来演绎声明中给出的参数类型）来确定模板的特殊化版本，那么全局特化就可以不声明显式的模板实参。</p>
<p>注意：全局函数模板特化不能包含缺省的实参值。然而，对于基本（即要被特化的）模板所指定的任何缺省实参，显式特化版本都可以应用这些缺省实参值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(T, T x = <span class="number">42</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> = <span class="number">35</span>)</span>     <span class="comment">// 错误，不能包含缺省实参值,但如果没有指定第2个实参，则会使用基本模板的缺省参数值</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(T, T x = <span class="number">42</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> y/<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g(<span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 正确，输出21</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="全局成员特化"><a class="markdownIt-Anchor" href="#全局成员特化"></a> 全局成员特化</h5>
<p>除了成员模板之外，类模板的成员函数和普通的静态成员变量也可以被全局特化；实现特化的语法会要求给每个外围类模板加上template&lt;&gt;前缀。如果要对一个成员模板进行特化，也必须加上另一个template&lt;&gt;前缀，来说明该声明表示的是一个特化。为了说明这些含义，让我们假设具有下面的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>      // (1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>         // (2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> count;      <span class="comment">// (3)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> code;         <span class="comment">// (4)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span>      <span class="comment">// (5)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"generic"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Outer&lt;T&gt;::code = <span class="number">6</span>;        <span class="comment">// (6)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Outer&lt;T&gt;::Inner&lt;U&gt;::count = <span class="number">7</span>;       <span class="comment">// (7)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>&lt;bool&gt;         // (8)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>       // (9)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> count;         <span class="comment">// (10)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;             <span class="comment">// (11)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在（1）处的泛型模板Outer中，（4）处的code和（5）处print()，这两个普通成员都具有一个外围类模板。因此，需要使用一个template&lt;&gt;前缀说明：后面将用一个模板实参集来对它进行全局特化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Outer&lt;<span class="keyword">void</span>&gt;::code = <span class="number">12</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Outer&lt;<span class="keyword">void</span>&gt;::print() <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer&lt;void&gt;"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这些定义将会用于替代类Outer<void>在（4）处和（5）处的泛型定义；但是，类Outer<void>的其他成员仍然默认地产生自（1）处的模板。另外，在提供了上面的声明之后，就不能再次提供Outer<void>的显式特化。</void></void></void></p>
<p>类似于全局函数模板特化，我们需要一种可以在不指定定义的前提下（为了避免多处定义），可以声明类模板普通成员特化的。尽管对于普通类的成员函数和静态成员变量而言，非定义的类外声明在C++中是不允许的；但如果是针对类模板的特化成员，该声明则是合法的。也就是说，前面的定义可以具有如下声明:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Outer&lt;<span class="keyword">void</span>&gt;::code;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Outer&lt;<span class="keyword">void</span>&gt;::print() <span class="keyword">const</span>;</span></pre></td></tr></table></figure>
<h3 id="动多态和静多态"><a class="markdownIt-Anchor" href="#动多态和静多态"></a> 动多态和静多态</h3>
<p>多态是一种能够令单一的泛型标记关联不同特定行为的能力。在C<ins>中，多态主要是通过继承和虚函数来实现的。由于这两个机制（继承和虚函数）都是（至少一部分）在运行期进行处理的，因此我们把这种多态称为动多态；我们平常所谈论的C</ins>多态指的就是这种动多态。然而，模板也允许我们使用单一的泛型标记，来关联不同的特定行为；但这种（借助于模板的）关联是在编译期进行处理的，因此我们把这种（借助于模板的）多态称为静多态，从而和上面的动多态区分开来。</p>
<h4 id="动多态"><a class="markdownIt-Anchor" href="#动多态"></a> 动多态</h4>
<p>使用继承和虚函数，在这种情况下，多态的设计思想主要在于：对于几个相关对象的类型，确定它们之间的一个共同功能集；然后在基类中，把这些共同的功能声明为多个虚函数接口。每个具体类都派生自基类，生成了具体对象之后，客户端代码就可以通过指向基类的引用或指针来操作这些对象，并且能够通过这些引用或者指针来实现虚函数的调度机制。也就是说，利用一个指向基类（子对象）的指针或者引用来调用虚成员函数，实际上将可以调用（指针或者引用实际上所代表的）具体类对象的相应成员。这种动多态是C++程序设计里面最常见的，这里不过多的阐述。</p>
<h4 id="静多态"><a class="markdownIt-Anchor" href="#静多态"></a> 静多态</h4>
<p>模板也能够被用于实现多态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"coord.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的几何对象类Circle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// - 并没有派生自任何其他的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的几何对象类Line</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// - 并没有派生自任何其他的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 画出任意GeoObj</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// method2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeoObj&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDraw</span><span class="params">(GeoObj <span class="keyword">const</span>&amp; obj)</span>     <span class="comment">// GeoObj是模板参数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    obj.draw();      <span class="comment">// 根据对象的类型调用相应的draw()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// method1:如果使用动多态，myDraw函数会是如下形式：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDraw</span><span class="params">(GeoObj <span class="keyword">const</span>&amp; obj)</span>      <span class="comment">// GeoObj是一个抽象基类</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    obj.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Line l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Circle c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    myDraw(l);         <span class="comment">// myDraw&lt;Line&gt;(GeoObj&amp;) =&gt; Line::draw()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    myDraw(c);         <span class="comment">// myDraw&lt;Circle&gt;(GeoObj&amp;) =&gt; Circle::draw()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>比较myDraw()的两个实现，主要的区别在于method2的GeoObj的规范是模板参数，而不是一个公共基类。</p>
<ul>
<li>使用动多态（method1），我们在运行期只具有一个myDraw()函数，</li>
<li>使用模板，我们则可能具有多个不同的函数，诸如myDraw<line>()和myDraw<circle>()。</circle></line></li>
</ul>
<h3 id="trait与policy类"><a class="markdownIt-Anchor" href="#trait与policy类"></a> trait与policy类</h3>
<p>模板让我们可以针对多种类型对类和函数进行参数，但我们并不希望为了能够最大程度地参数化而引入太多的模板参数，同时在客户端指定所有的相应实参往往也是烦人的。我们希望引入的大多数额外参数都具有合理的缺省值。在某些情况下额外参数还可以有几个主参数来确定。</p>
<p>policy类和trait（或者称为trait模板）是两种C++程序设计机制。它们有助于对某些额外参数的管理，<br>
这里的额外参数是指：在具有工业强度的模板设计中所出现的参数。</p>
<p>trait类：提供所需要的关于模板参数的类型的所有必要信息；(STL源码大量运用了这种技巧)<br>
policy类：有点像策略模式，通过policy类挂接不同的算法；</p>
<h4 id="fixed-traits"><a class="markdownIt-Anchor" href="#fixed-traits"></a> fixed traits</h4>
<p>针对每个typename T类型都创建一个关联，所关联的类型就是用来存储累加和的类型。这种关联可以被看作是类型T的一个特征，因此，我们也把这个存储累加和的类型称为T的trait。于是，我们可以导出我们的第一个trait类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;char&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;char&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;short&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;int&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;unsigned int&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;float&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">double</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在上面代码中，模板AccumulationTraits被称为一个trait模板，因为它含有它的参数类型的一个trait（通常而言，可以存在多个trait和多个参数）。对这个模板，我们并不提供一个泛型的定义，因为在我们不知道参数类型的前提下，并不能确定应该选择什么样的类型作为和的类型。然而，我们可以利用某个实参类型，而T本身通常都能够作为这样的一个候选类型。这样，我们可以改写accum()模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ordinary version</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T total  = T();      <span class="comment">// 假设T()事实上会产生一个等于0的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(beg != end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += *beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//trait version</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> AccumulationTraits&lt;T&gt;::<span class="function">AccT <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回值的类型是一个元素类型的trait</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulationTraits&lt;T&gt;::AccT Acct;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    AccT total = AccT();        <span class="comment">// 假设AccT()实际上生成了一个0值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(beg != end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += *beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 于是，现在例子程序的输入完全符合我们的期望，如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">the average value of the integer values is <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">the average value of the characters in <span class="string">"templates"</span> is <span class="number">108</span></span></pre></td></tr></table></figure>
<h4 id="value-trait"><a class="markdownIt-Anchor" href="#value-trait"></a> value trait</h4>
<p>到目前为止，我们已经看到了trait可以用来表示：“主”类型所关联的一些额外的类型信息。在这一小节里，我们将阐明这个额外的信息并不局限于类型，常数和其他类型的值也可以和一个类型进行关联。</p>
<p>我们前面的accum()模板使用了缺省构造函数的返回值来初始化结果变量（即total），而且我们期望该返回值是一个类似0的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AccT total = AccT();       <span class="comment">// 假设AccT()实际上生成了一个0值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> total;</span></pre></td></tr></table></figure>
<p>显然，我们并不能保证上面的构造函数会返回一个符合条件的值，可以用来开始这个求和循环。而且，类型AccT也不一定具有一个缺省构造函数。</p>
<p>在此，我们可以再次使用trait来解决这个问题。对于上面的例子，我们需要给AccumulationTraits添加一个value trait</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccumulationTraits</span>&lt;char&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 之所以选择使用静态函数返回一个值，原因如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 方案1: 直接定义“static AccT const zero = 0;”，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//  缺点:  在所在类的内部，C++只允许我们对整型和枚举类型初始化成静态成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 方案2: 类内声明“static double const zero;”</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//            源文件进行初始化“double const AccumulationTraits&lt;float&gt;::zero = 0.0;”，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">　 <span class="comment">// 缺点:  这种解决方法对编译器而言是不可知的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//           在处理客户端文件的时候，编译器通常都不会知道位于其他文件的定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 综上，选择了下面使用静态函数返回所需要的值的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> AccT <span class="title">zero</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 其他内建类型的特化版本类似</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">......</span></pre></td></tr></table></figure>
<p>对于应用程序代码而言，唯一的区别只是这里使用了函数调用语法（而不是访问一个静态数据成员）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AccT total = AccumulationTraits&lt;T&gt;::zero();</span></pre></td></tr></table></figure>
<p>显然，trait还可以代表更多的类型。在我们的例子中，trait可以是一个机制，用于提供accum()所需要的、关于元素类型的所有必要信息；实际上，这个元素类型就是调用accum()的类型，即模板参数的类型。下面是trait概念的关键部分：trait提供了一种配置具体元素（通常是类型）的途径，而该途径主要是用于泛型计算。</p>
<p>在上一节所使用的trait被称为fixed trait，因为一旦定义了这个分离的trait，就不能再算法中对它进行改写。然而，在有些情况下我们需要对trait进行改写。从原则上讲，参数化trait主要的目的在于：添加一个具有缺省值的模板参数，而且该缺省值是由我们前面介绍的trait模板决定的。在这种具有缺省值的情况下，许多用户就可以不需要提供这个额外的模板实参；但对于有特殊需求的用户，也可以改写这个预设的类型。</p>
<p>对于这个特殊的解决方案，唯一的不足在于：我们并不能对函数模板预设缺省模板实参。可以通过把算法实现为一个类，绕过这个不足。这同时也说明了：除了函数模板之外，在类模板中也可以很容易地使用trait，唯一的确点就是：类模板不能对它的模板参数进行演绎，而是必须显式提供这些模板参数。因此，我们需要编写如下形式的代码： Accum<char>::accum(&amp;name[0], &amp;name[length]) 前面例子的代码修改如下：</char></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> AT = AccumulationTraits&lt;T&gt; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Accum</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">static</span> <span class="keyword">typename</span> AT::AccT accum(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">typename</span> AT::AccT total = AT::zero();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (beg != end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                total += *beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>通常而言，大多数使用这个模板的用户都不必显式地提供第2个模板实参，因为我们可以针对第1个实参的类型，为每种类型都配置一个合适的缺省值。<br>
和大多数情况一样，我们可以引入一个辅助函数，来简化上面基于类的接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> AccumulationTraits&lt;T&gt;::<span class="function">AccT <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 第2个实参由类模板的缺省实参提供</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Accum&lt;T&gt;::accum(beg, end);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Traits, <span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> Traits&lt;T&gt;::<span class="function">AccT <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 第2个实参由Traits实参提供，替换缺省实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Accum&lt;T, Traits&gt;::accum(beg, end);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="policy-和-policy类"><a class="markdownIt-Anchor" href="#policy-和-policy类"></a> policy 和 policy类</h4>
<p>到目前为止，我们把累积（accumulation）与求和（summation）等价起来了。事实上，还可以有其他种类的累积。例如，我们可以对序列中的给定值进行求积；如果这些值是字符串的话，还可以对它们进行连接。甚至于在一个序列中找到一个最大值，也可以被看成是累积问题的一种形式。</p>
<p>在这所有的情况中，针对accum()的所有操作，唯一需要改变的只是“total += *beg;” 操作。于是，我们就把这个操作称为该累积过程的一个policy。</p>
<p>因此，一个policy类就是一个提供了一个接口的类，该接口能够在算法中应用一个或多个policy。</p>
<blockquote>
<p>policy，核心操作的一个代理，通过替换policy，达到改变算法核心操作，从而改变算法行为的目的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"accumtraits4.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sumpolicy1.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> Policy = SumPolicy,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> Traits = AccumulationTraits&lt;T&gt; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Accum</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::AccT AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> AccT <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccT total = Traits::zero();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (beg != end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Policy::accumulate(total, *beg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>其中SumPolicy类可以编写如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumPolicy</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">// 成员模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(T1&amp; total, T2 <span class="keyword">const</span> &amp; value)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            total += value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在这个例子中，我们把policy实现为一个具有一个成员函数模板的普通类（也就是说，类本身不是模板，而且该成员函数是隐式内联的）。后面我们还会讨论另一种实现方案。<br>
通过给累积值指定一个不同的policy，我们就可以进行不同的计算。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiPolicy</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(T1&amp; total, T2 <span class="keyword">const</span> &amp; value)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            total *= value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建含有具有5个整型值的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> num[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出所有值的乘积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the product of the integer values is "</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	              &lt;&lt; Accum&lt;<span class="keyword">int</span>,MultiPolicy&gt;::accum(&amp;num[<span class="number">0</span>], &amp;num[<span class="number">5</span>]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 程序的输出结果却出乎我们意料：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">the product of the integer values is <span class="number">0</span></span></pre></td></tr></table></figure>
<p>显然，这里的问题是我们对初始值的选择不当所造成的：因为对于求和，0是一个合适的初值；但对于求积，0却是一个错误的初值。可以在policy实现zero()的trait，也可以把这个初值作为参数传递进来。</p>
<h4 id="trait和policy"><a class="markdownIt-Anchor" href="#trait和policy"></a> trait和policy</h4>
<p>大多数人接受Andrei Alexandrescu在Modern C++ Design中给出的声明：</p>
<blockquote>
<p>policyhe trait具有许多共同点，但是policy更加注重于行为，而trait则更加注重于类型。</p>
</blockquote>
<p>此外，作为引入了trait技术的第1人，Nathan Myers给出了下面这个更加开放的定义：</p>
<blockquote>
<p>trait class:是一种用于代替模板参数的类。<br>
作为一个类，它可以是有用的类型，也可以是常量；<br>
作为一个模板，它提供了一种实现“额外层次间接性”的途径，而正是这种“额外层次间接性”解决了所有的软件问题。</p>
</blockquote>
<p>因此，我们通常会使用下面这些（并不是非常准确的）定义：</p>
<ol>
<li>trait表述了模板参数的一些自然的额外属性；</li>
<li>policy表述了泛型函数和泛型类的一些可配置行为（通常都具有被经常使用的缺省值）。</li>
</ol>
<p>为了更深入地分析这两个概念之间可能的区别，我们给出下面针对trait的一些事实：</p>
<ol>
<li>trait可以是fixed trait（也就是说，不需要通过模板参数进行传递的trait）。</li>
<li>trait参数通常都具有很自然的缺省值（该缺省值很少会被改写的，或者是不能被改写的）。</li>
<li>trait参数可以紧密依赖于一个或多个主参数。</li>
<li>trait通常都是用trait模板来实现的。</li>
</ol>
<p>对于policy class，我们将会发现下列事实：</p>
<ol>
<li>如果不以模板参数的形式进行传递的话，policy class几乎不起作用。</li>
<li>policy 参数并不需要具有缺省值，而且通常都是显式指定这个参数（尽管许多泛型组件都配置了使用频率很高的缺省policy）。</li>
<li>policy参数和属于同一个模板的其他模板参数通常都是正交的。</li>
<li>policy class一般都包含了成员函数。</li>
<li>policy既可以用普通类来实现，也可以用类模板来实现。</li>
</ol>
<h4 id="成员模板和模板的模板参数"><a class="markdownIt-Anchor" href="#成员模板和模板的模板参数"></a> 成员模板和模板的模板参数</h4>
<p>为了实现一个累积policy，在前面我们选择把Sumpolicy和MutPolicy实现为具有成员模板的普通类。<br>
另外，还存在另一种实现方法，即使用类模板来设计这个policy class接口，而这个policy class也就被用作模板的模板实参。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumPolicy</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulate</span> <span class="params">(T1&amp; total, T2 <span class="keyword">const</span> &amp; value)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        total += value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>于是，可以对Accum的接口进行修改，从而使用一个模板的模板参数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 模板的模板参数一般不会在类里面使用到，故而可以匿名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Policy</span> = <span class="title">SumPolicy</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">            <span class="title">typename</span> <span class="title">Traits</span> = <span class="title">AccumulationTraits</span>&lt;T&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">class</span> <span class="title">Accum</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::AccT AccT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> AccT <span class="title">accum</span><span class="params">(T <span class="keyword">const</span>* beg, T <span class="keyword">const</span>* end)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AccT total = Traits::zero();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (beg != end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Policy&lt;AccT, T&gt;::accumulate(total, *beg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>我们也可以不把AccT类型显式地传递给policy类型，而是只传递上面的累积trait，并且根据这个trait参数来确定返回结果的类型，而且这样做在某些情况下（诸如需要给trait其他的一些信息）是有利的。</p>
<p>通过模板的模板参数访问policy class的主要优点在于：</p>
<blockquote>
<p>借助于某个依赖于模板参数的类型，就可以很容易地让policy class携带一些状态信息（也就是静态成员变量）。</p>
</blockquote>
<p>而在我们的第1种解决方案中，却不得不把静态成员变量嵌入到成员类模板中。<br>
然而，这种利用模板的模板参数的解决方案也存在一个缺点：</p>
<blockquote>
<p>policy类现在必须被写成模板，而且我们的接口中还定义了模板参数的确切个数。<br>
遗憾的是，这个定义会让我们无法在policy中添加额外的模板参数。<br>
例如，我们希望给SumPolicy添加一个Boolean型的非类型模板实参，从而可以选择是用 += 运算符来进行求和，还是只用 + 运算符来进行求和。</p>
</blockquote>
<h4 id="组合多个policie和或-trait"><a class="markdownIt-Anchor" href="#组合多个policie和或-trait"></a> 组合多个policie和/或 trait</h4>
<p>从我们上面的开发过程可以看出，trait和policy通常都不能完全代替多个模板参数；<br>
然而，trait和policy确实可以减少模板参数的个数，并把个数限制在可控制的范围以内。</p>
<p>一种简单的策略就是根据缺省值使用频率递增地对各个参数进行排序。<br>
显然，这意味着：trait参数将位于policy参数的后面（即右边），因为我们在客户端代码中通常都会对policy参数进行改写。</p>
<h3 id="模板与继承"><a class="markdownIt-Anchor" href="#模板与继承"></a> 模板与继承</h3>
<p>许多模板技术往往让类模板拖着一长串类型参数；不过许多参数都设有合理的缺省值，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> policy1 = DefaultPolicy1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> policy2 = DefaultPolicy2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> policy3 = DefaultPolicy3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> policy4 = DefaultPolicy4&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class BreadSlicer</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .......</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>一般情况下使用缺省模板实参BreadSlicer&lt;&gt;就足够了。不过，如果必须指定某个非缺省的实参，还必须明白地指定在它之前的所有实参（即使这些实参正好是缺省类型，也不能偷懒）。跟BreadSlicer&lt;DefaultPolicy1, DefaultPolicy2, Custom&gt;相比，BreadSlicer&lt;Policy3 = Custom&gt;显然更有吸引力</p>
<p>我们的考虑主要是设法将缺省类型值放到一个基类中，再根据需要通过派生覆盖掉某些类型值。这样，我们就不再直接指定类型实参了，而是通过辅助类完成。如BreadSlicer&lt;Policy3_is&lt;Custom&gt;&gt;。既然用辅助类做模板参数，每个辅助类都可以描述上述4个policy中的任意一个，故所有模板参数的缺省值均相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PolicySetter1 = DefaultPolicyArgs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> PolicySetter2 = DefaultPolicyArgs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> PolicySetter3 = DefaultPolicyArgs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> PolicySetter4 = DefaultPolicyArgs&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class BreadSlicer</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> PolicySelector&lt;PolicySetter1, PolicySetter2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                     PolicySetter3, PolicySetter4&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Policies;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 使用Policies::P1, Policies::P2, ……来引用各个Policies</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>剩下的麻烦事就是实现模板PolicySelector。</p>
<p>这个模板的任务是利用typedef将各个模板实参合并到一个单一的类型（即Discriminator），该类型能够根据指定的非缺省类型（如policy1-is的Policy），改写缺省定义的typedef成员（如Default Policies的DefaultPolicy1）。其中合并的事情可以让继承来干</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PolicySelector&lt;A, B, C, D&gt;生成A, B, C, D作为基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discriminator&lt;&gt;使Policy Selector可以多次继承自相同的基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// PolicySelector不能直接从Setter继承</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Base, <span class="keyword">int</span> D&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span> :</span> <span class="keyword">public</span> Base&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Setter1, <span class="keyword">typename</span> Setter2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> Setter3, <span class="keyword">typename</span> Setter4&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicySelector</span> :</span> <span class="keyword">public</span> Discriminator&lt;Setter1, <span class="number">1</span>&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">public</span> Discriminator&lt;Setter2, <span class="number">2</span>&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">public</span> Discriminator&lt;Setter3, <span class="number">3</span>&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">public</span> Discriminator&lt;Setter4, <span class="number">4</span>&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>由于中间模板Discriminator的引入，我们就可以一致处理各个Setter类型（不能直接从多个相同类型的基类继承，但可以借助中间类间接继承）。<br>
如前所述，我们还需要把缺省值集中到一个基类中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别命名缺省policies为P1, P2, P3, P4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultPolicies</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> DefaultPolicy1 P1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> DefaultPolicy2 P2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> DefaultPolicy3 P3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> DefaultPolicy4 P4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>不过由于会多次从这个基类继承，我们必须小心以避免二义性，故用虚拟继承：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个为了使用缺省policy值的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们多次派生自DefaultPolicies，下面的虚拟继承就避免了二义性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">DefaultPolicyArgs</span> : <span class="symbol">virtual</span> <span class="symbol">public</span> <span class="symbol">DefaultPolicies</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>最后，我们只需要写几个模板覆盖掉缺省的policy参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Policy&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy1_is</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Policy P1;           <span class="comment">//改写缺省的typedef</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Policy&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy2_is</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Policy P2;           <span class="comment">//改写缺省的typedef</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Policy&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy3_is</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Policy P3;           <span class="comment">//改写缺省的typedef</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Policy&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy4_is</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Policy P4;           <span class="comment">//改写缺省的typedef</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>最后，我们把模板BreadSlicer实例化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BreadSlicer&lt;Policy3_is&lt;CustomPolicy&gt; &gt; bc;</span></pre></td></tr></table></figure>
<p>这时模板BreadSlicer中的类型Polices被定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PolicySelector&lt;Policy3_is&lt;CustomPolicy&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    DefaultPolicyArgs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    DefaultPolicyArgs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    DefaultPolicyArgs&gt;</span></pre></td></tr></table></figure>
<p>所有的模板实参都是基类，而它们有共同的虚基类DefaultPolicies，正是这个共同的虚基类定义了P1, P2, P3和P4的缺省类型；不过，其中一个派生类Policy3_is&lt;&gt;重定义了P3。根据优势规则，重定义的类型隐藏了基类中的定义，这里没有二义性问题。</p>
<h3 id="模板元编程"><a class="markdownIt-Anchor" href="#模板元编程"></a> 模板元编程</h3>
<p>meta programming含有“对一个程序进行编程”的意思。换句话说，编程系统将会执行我们所写的代码，来生成新的代码，而这些新代码才真正实现了我们所期望的功能。通常而言，meta programming这个概念意味着一种反射的特性：metaprogramminig组件只是程序的一部分，而且它也只生成一部分代码或者程序。</p>
<p>使用metaprogramming的目的是为了实现更多的功能，并且是花费的开销更小。<br>
另一方面，metaprogramming的最大特点在于：某些用户自定义的计算可以在程序翻译期进行。而这通常都能够在性能或接口简单性方面带来好处；甚至为两方面同时带来好处。</p>
<h4 id="递归模板"><a class="markdownIt-Anchor" href="#递归模板"></a> 递归模板</h4>
<p>模板实例化机制是一种基本的递归语言机制，可以用于在编译期执行复杂的计算。因此，这种随着模板实例化所出现的编译期计算通常就被称为template meta programming。</p>
<p>如何在编译期计算3的幂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于计算3的N次方的基本模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow3</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; result = <span class="number">3</span> * Pow3&lt;N<span class="number">-1</span>&gt;::result &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于结束递归的全局特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow3</span>&lt;0&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; result = <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//斐波拉切数列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value; <span class="comment">// recursive!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// template specialisation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt; // <span class="title">required</span> <span class="title">for</span> <span class="title">terminating</span> <span class="title">condition</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>Pow3&lt;&gt;模板（包含它的特化）就被称为一个template metaprogramming。它描述一些可以在翻译期（编译期）进行求值的计算，而这整个求值过程属于模板实例化过程的一部分。</p>
<p><strong>枚举值 VS 静态常量</strong></p>
<blockquote>
<p>静态成员变量只能是左值，若编译器将必须传递Pow3&lt;7&gt;::result的地址，便会强制编译器实例化静态成员的定义，并为该定义分配内存。于是，该计算将不再局限于完全的“编译期”效果。然而，<strong>枚举值却不是左值（也就是说，它们并没有地址）</strong>。因此，当你通过引用传递枚举值的时候，并不会使用任何静态内存，就像是以文字常量的形式传递这个完成计算的值一样。所以，下面的所有例子，我们使用枚举值而不是静态常量。</p>
</blockquote>
<h3 id="表达式模板"><a class="markdownIt-Anchor" href="#表达式模板"></a> 表达式模板</h3>
<p>表达式模板解决的问题是：</p>
<blockquote>
<p>在编译时进行复杂的表达式计算。对于一个数值数组类，它需要为基于整个数组对象的数值操作提供支持</p>
</blockquote>
<p>谈到表达式模板，自然联想到前面的template metaprogramming。</p>
<ul>
<li>表达式模板有时依赖于深层的嵌套模板实例化，而这种实例化又和我们在template metaprogramming中遇到的递归实例化非常相似；</li>
<li>表达式模板、元编程两种实例化技术都是为了支持高性能的数组操作。侧面说明了metaprogramming和表达式模板是息息相关的。当然，这两种技术还是互补的。例如，metaprogramming主要用于小的，大小固定的数组，而表达式模板则适用于能够在运行期确定大小、中等大小的数组。</li>
</ul>
<h4 id="点乘"><a class="markdownIt-Anchor" href="#点乘"></a> 点乘</h4>
<p>向量的点乘可以看作组合体设计模式的一个特例。点乘可以分成两个部分：叶结点是一维 向量的积，而组合体是剩下N-1维向量的点乘。<br>
<img alt="dot product figure" data-src="/assets/2019/12/09/compose_figure_2.jpg"></p>
<p>显而易见，这是组合体的某种简并（degenerate）形式，每个组合体包含一个叶结点和一 个组合体。使用面向对象编程的技术，我们可以用一个基类和两个派生类来表示点乘：<br>
<img alt="dot product figure" data-src="/assets/2019/12/09/compose_figure_3.jpg"></p>
<p>基类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DotProduct</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">virtual</span> ~DotProduct () &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> T <span class="title">eval</span><span class="params">()</span> </span>= <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>组合体:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeDotProduct</span>  :</span> <span class="keyword">public</span> DotProduct&lt;T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CompositeDotProduct (T* a, T* b, <span class="keyword">size_t</span> dim) :</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s(<span class="keyword">new</span> SimpleDotProduct&lt;T&gt;(a, b)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c((dim == <span class="number">1</span>) ? <span class="number">0</span> : <span class="keyword">new</span> CompositeDotProduct&lt;T&gt;(a + <span class="number">1</span>, b + <span class="number">1</span>, dim - <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">virtual</span> ~CompositeDotProduct ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">eval</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ( s-&gt;eval() + ((c) ? c-&gt;eval() : <span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SimpleDotProduct&lt;T&gt;* s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CompositeDotProduct&lt;T&gt;* c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>叶节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleDotProduct</span>  :</span> <span class="keyword">public</span> DotProduct&lt;T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   SimpleDotProduct (T* a, T* b) : v1(a), v2(b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">virtual</span> T <span class="title">eval</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">   </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> (*v1)*(*v2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   T* v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   T* v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>辅助函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">dot</span><span class="params">(T* a, T* b, <span class="keyword">size_t</span> dim)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (dim == <span class="number">1</span>) ?</span></pre></td></tr><tr><td class="code"><pre><span class="line">              SimpleDotProduct&lt;T&gt;(a, b).eval() :</span></pre></td></tr><tr><td class="code"><pre><span class="line">              CompositeDotProduct&lt;T&gt;(a, b, dim).eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> b[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; dot(a, b, <span class="number">4</span>);</span></pre></td></tr></table></figure>
<p>当然，这不是计算点乘的最有效途径。我们可以通过在派生类中消去叶结点和组合体来简化实现。这样，不在构造函数里传递且保存需要计算的向量，以便之后的计算，而是直接将向量传递给求值函数。将构造函数和求值函数由</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SimpleDotProduct&lt;T&gt;::SimpleDotProduct (T* a, T* b) : v1(a), v2(b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> T SimpleDotProduct&lt;T&gt;::eval()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (*v1)*(*v2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>修改为一个带参数的求值函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">T SimpleDotProduct::eval(T* a, T* b, <span class="keyword">size_t</span> dim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (*a)*(*b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>现在让我们将面向对象的实现转化成为编译时计算的实现。叶结点和组合体对应的两个类 共用了一个用来表示它们的共同操作的基类——这是面向对象编程的常用技巧：共同点用相 同的基类来表示。在模板编程中，共同点则是用命名的一致性来表现的。在面向对象编程 中的虚函数将不再为虚，而变为一个普通的，有着特定名称的函数。两个派生类不再是从 一个基类中派生的两个类，而是变为独立的，有着相同名称和相通记号成员函数的两个类 。也就是说，我们不再需要基类了。</p>
<p>现在我们来通过在模板的参数中保存结构信息的方式来实现组合体。我们需要保存的结构 信息是这个向量的维度。回忆一下之前我们计算阶乘和平方根的代码：函数实现中函数的 参数变为了编译时处理的模板参数。我们在这里也采用相同的手法，原来在面向对象实现 中传递给求值函数的向量的维度，在这里变为编译时确定的模板参数。因此在组合体中， 这个维度数据将变为模板中的一个常量参数。</p>
<p>叶结点则需要通过组合体类在一维情况下的模板特化类来实现。正如以往一样，我们将运 行时的递归转变为编译时的递归：将对求值虚函数的递归调用转变为模板类在递归实例化 的过程中对一个静态的求值函数的递归调用。如下是编译时计算点乘代码的类图：<br>
<img alt="dot product figure" data-src="/assets/2019/12/09/compose_figure_4.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N, <span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DotProduct</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">eval</span><span class="params">(T* a, T* b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>  DotProduct&lt;<span class="number">1</span>,T&gt;::eval(a,b) + DotProduct&lt;N<span class="number">-1</span>,T&gt;::eval(a+<span class="number">1</span>,b+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DotProduct</span>&lt;1,T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">eval</span><span class="params">(T* a, T* b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (*a)*(*b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N, <span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">dot</span><span class="params">(T* a, T* b)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DotProduct&lt;N,T&gt;::eval(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dot&lt;<span class="number">4</span>&gt;(a,b);</span></pre></td></tr></table></figure>
<blockquote>
<p>注意到在运行时计算中，点乘函数的调用方法是dot(a, b, 4)，而编译时计算中，点乘函 数的调用方法是dot&lt;4&gt;(a, b)</p>
</blockquote>
<ul>
<li>dot(a, b, 4)等价于CompositeDotProduct&lt;int&gt;().eval(a, b, 4)，递归式的引发如下函数在运行时的调用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SimpleDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a, b, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">CompositeDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">1</span>, b + <span class="number">1</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SimpleDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">1</span>, b + <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">CompositeDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">2</span>, b + <span class="number">2</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SimpleDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">2</span>, b + <span class="number">2</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">CompositeDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">3</span>, b + <span class="number">3</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SimpleDotProduct&lt;<span class="keyword">int</span>&gt;().eval(a + <span class="number">3</span>, b + <span class="number">3</span>, <span class="number">1</span>);</span></pre></td></tr></table></figure>
<ul>
<li>dot&lt;4&gt;(a, b)通过计算DotProduct&lt;4, int&gt;::eval(a, b)，从而递归式的引发下列模板依次实例化展开：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DotProduct&lt;<span class="number">4</span>, <span class="keyword">size_t</span>&gt;::eval(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">DotProduct&lt;<span class="number">1</span>, <span class="keyword">size_t</span>&gt;::eval(a, b) + DotProduct&lt;<span class="number">3</span>, <span class="keyword">size_t</span>&gt;::eval(a + <span class="number">1</span>, b + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">(*a) * (*b) + DotProduct&lt;<span class="number">1</span>, <span class="keyword">size_t</span>&gt;::eval(a + <span class="number">1</span>, b + <span class="number">1</span>) + DotProduct&lt;<span class="number">2</span>, <span class="keyword">size_t</span>&gt;::eval(a + <span class="number">2</span>, b + <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">(*a) * (*b) + (*a + <span class="number">1</span>) * (*b + <span class="number">1</span>) + DotProduct&lt;<span class="number">1</span>, <span class="keyword">size_t</span>&gt;::eval(a + <span class="number">2</span>, b + <span class="number">2</span>) + DotProduct&lt;<span class="number">1</span>, <span class="keyword">size_t</span>&gt;::eval(a + <span class="number">3</span>, b + <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">(*a) * (*b) + (*a + <span class="number">1</span>) * (*b + <span class="number">1</span>) + (*a + <span class="number">2</span>) * (*b + <span class="number">2</span>) + (*a + <span class="number">3</span>) * (*b + <span class="number">3</span>)</span></pre></td></tr></table></figure>
<p>在可执行文件中，只会有(*a) * (*b)  +  (*a + 1) * (*b + 1)  +  (*a + 2) * (*b + 2)  +  (*a + 3) * (*b + 3)对应的代码；具体的展开过程是在编译时完成的。</p>
<p>很明显，模板编程提升了运行时的计算性能，但是代价是延长了编译的时间。递归的模板 实例化展开所造成的编译时间延长是以数量级形式进行的。而面向对象的代码虽然编译时 间短，却花费了更多的运行时间。</p>
<p>编译时计算的另一个局限性在于，向量的维度必须在编译时就已知，因为这个值需要通过 模板参数来传递。实际上这反而不是太大的问题，因为通常这个值在编码的时候的确是已 知的，例如，我们如果要计算空间中的向量，那么向量的维度显然是3。</p>
<p>点乘的代码未必能给读者留下深刻印象，因为事实上我们只需要手工展开乘法，就能带来和模板编程带来的相同的性能提升。然而这里所提及的技术并不仅仅局限于点乘，而是可以扩展到高阶矩阵的算术计算上去。这样的编码将大大简化编程的复杂性。如果定义a为 10x20的矩阵，b为20x10的矩阵，而c为10x10的矩阵，那么使用a * b + c来表达 计算将显得非常简洁明了。程序员显然宁愿让编译器自动的，同时也是可靠的处理这个问题，而不愿意手工展开如此高阶的矩阵。</p>
<h4 id="算术表达式"><a class="markdownIt-Anchor" href="#算术表达式"></a> 算术表达式</h4>
<p>形如(a + 1) * c或者log(abs(x - N))的算术表达式将由语法树来实现。共有两种终点表 达式：常数（literial）与数值变量（variable）。常数对应的是已知的数值，而数值变 量则可能在每次求值时取不同的值。非终点表达式则由一元或者二元运算符组成，每个非 终点表达式可能包含一到两个终点表达式。表达式中可能有各种不同语义的运算符，比如+ ，-，*，/，++，–，exp，log，sqrt等等</p>
<p>我们通过(x + 2) * 3这个具体实例来分析。组合体的结构，也就是语法树的结构，如下图所示：<br>
<img alt="expression_figure" data-src="/assets/2019/12/09/expression_figure_1.jpg"></p>
<p>设计如下类图所示：<br>
<img alt="expression_figure" data-src="/assets/2019/12/09/expression_figure_2.jpg"></p>
<p>面向对象方式下的算术表达式的解释器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractExpr</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpr</span> :</span> <span class="keyword">public</span> AbstractExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonTerminalExpr</span> :</span> <span class="keyword">public</span> AbstractExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literal</span> :</span> <span class="keyword">public</span> TerminalExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Literal(<span class="keyword">double</span> v) : _val(v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span> :</span> <span class="keyword">public</span> TerminalExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Variable(<span class="keyword">double</span>&amp; v) : _val(v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span>&amp; _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExpr</span> :</span> <span class="keyword">public</span> NonTerminalExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinaryExpr(<span class="keyword">const</span> AbstractExpr* e1, <span class="keyword">const</span> AbstractExpr* e2) : _expr1(e1),_expr2(e2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">virtual</span> ~BinaryExpr ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> <span class="keyword">const_cast</span>&lt;AbstractExpr*&gt;(_expr1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> <span class="keyword">const_cast</span>&lt;AbstractExpr*&gt;(_expr2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> AbstractExpr* _expr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> AbstractExpr* _expr2; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> :</span> <span class="keyword">public</span> BinaryExpr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Sum(<span class="keyword">const</span> AbstractExpr* e1, <span class="keyword">const</span> AbstractExpr* e2) : BinExpr(e1,e2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _expr1-&gt;eval() + _expr2-&gt;eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>使用解释器来处理算术表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">double</span> x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Product <span class="title">expr</span><span class="params">(<span class="keyword">new</span> Sum(<span class="keyword">new</span> Variable(x), <span class="keyword">new</span> Literal(<span class="number">2</span>)), <span class="keyword">new</span> Literal(<span class="number">3</span>))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; expr.eval() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>首先创造了一个表达式对象，用以表示(x + 2) * 3。之后该对象对自身进行求值 。自然而然的，我们觉得这是一个极其低效的计算方法。现在我们将它转化为表达式模板 。</p>
<p>正如之前点乘的例子中所示，我们首先要消除所有的虚基类。因为模板类中没有继承，取 而代之的是相同的成员名称。因此，我们不再使用基类，而将所有的终点表达式和非终点 表达式都用单独的类来表示，它们共有一个相同的名为eval的函数。</p>
<p>下一步，我们将通过类模板UnaryExpr和BinaryExpr来生成所有的形如Sum和Product的非终 点表达式。这里结构信息将全部保存在类模板的参数中。这些类模板将其子表达式的类型 作为其类型模板。另外，我们将具体的运算符操作抽象为类模板中一个类型，通过仿函数 对象传递。</p>
<p>实现，与面向对象实现没有很大的差别。</p>
<p>同样的，运行时递归将由编译时递归所代替：我们将虚的求值函数的递归调用改为表达式 模板的递归实例化。</p>
<p>基于模板实现表达式求值问题的类图：<br>
<img alt="expression_figure" data-src="/assets/2019/12/09/expression_figure_3.jpg"></p>
<p>基于模板的算术表达式解释器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literal</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Literal(<span class="keyword">const</span> <span class="keyword">double</span> v) : _val(v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Variable(<span class="keyword">double</span>&amp; v) : _val(v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span>&amp; _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExprT1, <span class="keyword">typename</span> ExprT2, <span class="keyword">typename</span> BinOp&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExpr</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinaryExpr(ExprT1 e1, ExprT2 e2,BinOp op=BinOp()) :</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _expr1(e1),_expr2(e2),_op(op)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _op(_expr1.eval(),_expr2.eval());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ExprT1 _expr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ExprT2 _expr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinOp  _op;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>UnaryExpr的类模板与BinaryExpr的类模板相似。对于实际操作，我们可以使用已经编写好 的STL的仿函数类plus，minus，等等，或者我们也可以自行编写。一个用来表示和的二元 表达式的类型是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BinaryExpr&lt;ExprT1, ExprT2, <span class="built_in">std</span>::plus&lt;<span class="keyword">double</span>&gt;&gt;</span></pre></td></tr></table></figure>
<p>这样的类 型使用起来较为复杂，因此我们写一个产生函数，方便以后的使用。</p>
<h5 id="产生函数"><a class="markdownIt-Anchor" href="#产生函数"></a> 产生函数</h5>
<p>产生函数是在模板编程中广泛使用的一种技巧。在STL中有大量的产生函数，例如 make_pair()。产生函数的优势在于，可以利用编译器对函数模板参数的自动推导来简化 编程，而对类模板，编译器是无法进行自动推导的。</p>
<p>每次我们从一个类模板中创建一个对象的时候，我们需要给出完整的类模板参数的实例化信息。在很多情况下，这些信息非常复杂，难于理解。例如包含pair的pair：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt;&gt;</span></pre></td></tr></table></figure>
<p>产生函数可以简化这个问题：它将生成给定类型的对象，而无需我们写出冗长的类型声明信息。</p>
<p>更准确的说，产生函数是一类函数模板。这种函数模板与它生成的对象对应的模板类有着相同的模板参数。以pair为例，pair类模板有两个类型参数T1和T2，表示它所包含的两个 元素的类型，而make_pair()产生函数同样包含这两个类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pair(T1 t1, T2 t2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pair&lt;T1,T2&gt; make_pair(t1 t1, T2 t2) </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> pair&lt;T1,T2&gt;(t1, t2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>产生函数与构造函数非常相似：我们传递给产生函数的参数和我们传递给构造函数的 参数是一样的。因为编译器能够自动推导函数模板中模板参数所表示的类型，我们可以借 此省去这个声明，而把这一繁重的工作交给编译器来进行。因此，我们不用通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt; pair&lt;<span class="built_in">string</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt;, pair&lt;<span class="built_in">string</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt;&gt;(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; &gt;(<span class="string">"origin"</span>, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; &gt;(<span class="string">"saddle"</span>, aCalculation()))</span></pre></td></tr></table></figure>
<p>来声明一个复杂的pair，而通过产生函数进行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make_pair(make_pair(<span class="string">"origin"</span>, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>)), make_pair(<span class="string">"saddle"</span>, aCalculation()))</span></pre></td></tr></table></figure>
<p>我们将用产生函数来简化表达式对象的生成。列表12给出了产生函数的两个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> ExprT1, <span class="keyword">typename</span> ExprT2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">BinaryExpr&lt;ExprT1,ExprT2,plus&lt;<span class="keyword">double</span>&gt;&gt; makeSum(ExprT1 e1, ExprT2 e2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> BinaryExpr&lt;ExprT1,ExprT2,plus&lt;<span class="keyword">double</span>&gt; &gt;(e1,e2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> ExprT1, <span class="keyword">typename</span> ExprT2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">BinaryExpr &lt;ExprT1,ExprT2,multiplies&lt;<span class="keyword">double</span>&gt;&gt; makeProd(ExprT1 e1, ExprT2 e2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> BinaryExpr&lt;ExprT1,ExprT2,multiplies&lt;<span class="keyword">double</span>&gt; &gt;(e1,e2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>基于模板实现的解释器解析(x + 2) * 3的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span> <span class="params">(<span class="keyword">double</span> x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinaryExpr&lt; BinaryExpr &lt; Variable, Literal, plus&lt;<span class="keyword">double</span>&gt; &gt;, multiplies&lt;<span class="keyword">double</span>&gt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            expr = makeProd (makeSum (Variable(x), Literal(<span class="number">2</span>)), Literal(<span class="number">3</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr.eval() &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>首先生成了一个代表(x + 2) * 3的表达式对象，然后这个对象对自身进行求值。表达式对 象的结构本身即是语法树的结构。<br>
我们其实完全不必给出如此冗长的类型信息，而是可以直接使用产生函数来自动生成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; makeProd(makeSum(Variable(x),Literal(<span class="number">2</span>)),Literal(<span class="number">3</span>)).eval() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>通过模板来实现解释器这个设计模式的优越性是什么呢？</p>
<p>倘若所有的产生函数，构造函数 和求值函数都能被编译器内联的话（这应该是可以办到的，因为这些函数本身都很简单） ，表达式makeProd(makeSum(Variable(x),Literal(2)),Literal(3)).eval()最终将被编 译器转化为(x + 2) * 3进行编译。</p>
<p>回过头来看前面的代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Product expr(new Sum(new Variable(x),new Literal(2)), new Literal(3)).eval()</span></pre></td></tr></table></figure>
<p>仅仅这一小段中就包含了大量的堆上的内存申请和对象构造，同时也引入了不少对虚函数eval()的调用。这些虚函数调用很难被内联，因为编译器一般不会内联通过指针调用的函数。</p>
<blockquote>
<p><strong>基于模板的实现将比面向对象的实现效率高上许多。</strong></p>
</blockquote>
<p>为了使用上的方便，我们进一步的修改表达式模板。首先要考虑的是增加可读性。</p>
<ol>
<li>将产生函数修改为重载的运算符。也就是说，将makeSum改为operator+，将 makeProd改为operator*，等等。这样产生的效果就是将</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//from</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">makeProd(makeSum(Variable(x), Literal(<span class="number">2</span>)), Literal(<span class="number">3</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">((Variable(x) + Literal(<span class="number">2</span>)) * Literal(<span class="number">3</span>))</span></pre></td></tr></table></figure>
<p>这已经是一大进步了。但是距离我们所希望的直接写(x + 2) * 3还有一定差距。因此我们 需要设法消除Variable和Literal的构造函数的直接调用。</p>
<ol start="2">
<li>将产生函数从makeSum改 为operator+</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExprT1, <span class="keyword">typename</span> ExprT2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">BinaryExpr&lt;ExprT1, ExprT2, plus&lt;<span class="keyword">double</span>&gt;&gt; <span class="keyword">operator</span>+(ExprT1 e1, ExprT2 e2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> BinaryExpr&lt;ExprT1, ExprT2, plus&lt;<span class="keyword">double</span>&gt;&gt;(e1,e2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我们希望x + 2可以和之前的makeSum(x, 2)，如今的operator+(x, 2)相对应。x + 2应当创造一个代表求和的二元表达式对象，而这个对象的构造函数将以double类型的变量x以及 整形常量2作为构造参数。</p>
<p>更准确的说，这将生成一个<code>BinaryExpr&lt;double, int, plus&lt;double&gt;&gt;(x, 2)</code>的匿名对象。然而我们所期望的类型并非如此：需要的是<code>BinaryExpr &lt;Variable, Literal, plus&lt;double&gt;&gt;</code>类型的对象。可是，自动模板参数类型推导并不知道x是一个变量，而2是一个常量。编译器只能检查传递给函数的参数类型，从而从x中推导出double类型，从2中推导出int类型。</p>
<p>看起来我们需要稍稍给编译器一些更多的信息，从而得到我们所需要的结果。如果我们给函数传递的不是double类型的x，而是一个Variable类型的参数，那么编译器应该能够自动产生<code>BinaryExpr&lt;Variable, int, plus&lt;double&gt;&gt;</code>，这将更接近我们的目标。（我们将很快解决int到Literal的转换问题）因此，用户不得不对代码做一些小小的改动：他们需要用Variable类来包装他们的变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span> <span class="params">(<span class="keyword">double</span> x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Variable v = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((v + <span class="number">2</span>) * <span class="number">3</span>).eval() &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过使用Variable对象v来代替一个数值类型的参数，我们可以将v + 2转化为一个等价于<code>BinaryExpr&lt;Variable, int, plus&lt;double&gt;&gt;(v, 2)</code>的匿名对象。这样的BinaryExpr对象有两个数据成员，一个是Variable，一个是int。</p>
<p>求值函数<code>BinaryExpr&lt;Variable, int, plus&lt;double&gt;&gt;::eval()</code>将计算并且返回两个数据成员的和。问题是，int类型的数据无法自行转化为可以自动求值的对象，我们必须将常数2转化为Literal类型，才能进行自动求值。如何做到这种自动转化呢？我们需要使用traits。</p>
<blockquote>
<p>Traits <em>TRAITS</em><br>
在模板编程中，traits是另一种常用的技术。traits类是一种只与另外一种类型配合，保存这种类型的具体信息的影子类（shadow class）。</p>
</blockquote>
<blockquote>
<p>C++ STL中有多个traits的例子，字符traits就是其中之一。读者大约知道标准库中的string类其实是一个类模板，这个类模板的参数是具体的字符类型。这就使得string可以处理普通的字符和宽字符。实际上，string类的实际名称是basic_string。basic_string可以通过实例化来接受任何类型的字符，而不仅仅是上述提及的两种。倘若有人需要保存以Jchar定义的日文字符，那么他就可以用basic_string模板实现：basic_string<jchar>。</jchar></p>
</blockquote>
<blockquote>
<p>读者可以自己设想如何设计这样的string类模板。有一些必须的信息并不能由字符的类型本身所提供。例如，如何计算字符串的长度？这可以通过数一下字符串里的所有字符个数来实现。这样就需要知道字符串的结束记号是什么。但是如何知道这一点呢？虽然我们知道对于一般的字符，’\0’是结束符；宽字符wchar_t有它自己定义的结束符，但是对于Jchar呢？很明显，结束符这个信息与字符的类型直接相关，但是却不包括在类型本身所能提供的信息之中。这时traits就派上了用场：它们可以提供这些额外的，却是必须的信息。</p>
</blockquote>
<blockquote>
<p>traits类型是一种可以被具体的一组类型实例化或者特化的影子（shadow）类模板，在实例化或者特化的时候，它们包含了额外的信息。C++标准库中字符的traits，即是char_traits类模板，就包含了一个静态的字符常量，用以表示这种字符对应的字符串结束符的值。</p>
</blockquote>
<p>我们使用traits技术来解决常数到Literal类型的转换问题。对于每一种表达式的类型，我们定义表达式的traits用以保存它们在各种运算符对象中的存储方式。所有的常数类型都应该以Literal类型的对象保存；所有的Variable对象都应该以本身的类型保存在Variables之中；而所有的非终端表达式都应该按照本身类型保存。</p>
<p>表达式traits</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExprT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exprTraits</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> ExprT expr_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exprTraits</span>&lt;double&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> Literal expr_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exprTraits</span>&lt;int&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> Literal expr_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>表达式traits类定义了一个嵌套类型expr_type，代表表达式对象的具体类型。未特化的traits模板类将所有常用的表达式类型保存为其本身。但是对于C++语言内置的数值类型，例如short，int，long，float，double等则进行了特化，它们在表达式中对应的类型均为Literal。</p>
<p>在BinaryExpr和UnaryExpr类中，我们将使用表达式traits来确认存有子表达式的数据成员的类型。</p>
<p>使用表达式traits</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExprT1, <span class="keyword">typename</span> ExprT2, <span class="keyword">typename</span> BinOp&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExpr</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinaryExpr(ExprT1 e1, ExprT2 e2,BinOp op=BinOp()) :</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _expr1(e1), _expr2(e2), _op(op)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _op(_expr1.eval(),_expr2.eval());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exprTraits&lt;ExprT1&gt;::expr_type _expr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exprTraits&lt;ExprT2&gt;::expr_type _expr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BinOp  _op;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>通过使用表达式traits，<code>BinaryExpr&lt;Variable, int, plus&lt;double&gt;&gt;</code>可以将它的两个运算元的类型分别保存为Variable和Literal。</p>
<p>现在我们已经可以使用((v + 2) * 3).eval()来进行求值了。在这里v是一个Variable类型，其中封装了一个double类型的对象x。这样，实际上的求值就是(x + 2) * 3了。我们可以为可读性着想，稍稍再做进一步的改进。人们通常觉得调用表达式的一个成员函数进行求值看上去很古怪。不过我们可以设计一个辅助函数，将((v + 2) * 3).eval()变为eval((v + 2) * 3)。这两段代码虽然事实上是等价的，但是却更符合诸君的阅读习惯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ExprT</span>&gt; <span class="title">double</span> <span class="title">eval</span>(<span class="title">ExprT</span> <span class="title">e</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> e.eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下图给出了表达式((v + 2) * 3).eval()在v作为Variable封装了一个double类型的x的情况下，在编译过程中是如何逐步的展开为(x + 2) * 3的。<br>
<img alt="compose_figure" data-src="/assets/2019/12/09/compose_figure_4.jpg"><br>
<img alt="compose_figure" data-src="/assets/2019/12/09/compose_figure_5.jpg"></p>
<h5 id="表达式对象的反复计算"><a class="markdownIt-Anchor" href="#表达式对象的反复计算"></a> 表达式对象的反复计算:</h5>
<p>我们所用到的语法树都是静态的。每个语法树在构造之后，只被调用一次。然而我们可以通过给定一个语法树，并传入不同的参数值，来动态的使用这个模型。如上文所述，我们希望能够用如下的近似函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ExprT</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">double</span> <span class="title">integrate</span> (<span class="title">ExprT</span> <span class="title">e</span>,<span class="title">double</span> <span class="title">from</span>,<span class="title">double</span> <span class="title">to</span>,<span class="title">size_t</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> step = (to - from) / n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> i = from + step / <span class="number">2</span>; i &lt; to; i += step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += e.eval(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> step * sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>计算类似下面的积分式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\int_&#123;1.0&#125;^&#123;5.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  \frac&#123;x&#125;&#123;1 + x&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   \,dx</span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Identity&lt;<span class="keyword">double</span>&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; integrate(x / (<span class="number">1.0</span> + x), <span class="number">1.0</span>, <span class="number">5.0</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>这里我们需要的是一个被反复调用的表达式对象，然而我们现有的代码尚不支持这样的操作。不过一些小小的修改即可满足我们的要求。只要让我们的eval函数接受一个值作为参数即可。非终端的表达式将把参数传递给它们的子表达式。Literal类只需要形式上的接受这个参数即可，它们的值不受这个参数所影响。Variable将不再返回Variable的值，而是它所接受到的这个参数的值。出于这个目的，我们把Variable改名为Identity。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literal</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Literal(<span class="keyword">double</span> v) : _val(v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span>)</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Identity</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">T <span class="title">eval</span><span class="params">(T d)</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ExprT1</span>,<span class="title">class</span> <span class="title">ExprT2</span>, <span class="title">class</span> <span class="title">BinOp</span>&gt; <span class="title">class</span> <span class="title">BinExpr</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> d)</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> _op(_expr1.eval(d),_expr2.eval(d));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>如果编写sqrt()，sqr()，exp()，log()等等数值函数的非终点表达式代码，甚至可以计算高斯分布：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> sigma = <span class="number">2.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> mean = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="number">3.141593</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; integrate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="number">1.0</span> / (<span class="built_in">sqrt</span>(<span class="number">2</span> * Pi) * sigma) * <span class="built_in">exp</span>(sqr(x - mean) / (<span class="number">-2</span> * sigma * sigma)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="number">2.0</span>, <span class="number">10.0</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>我们可以通过调用C标准库里的相应函数来实现这些非终点表达式，只要增加相应的一元或者二元运算符的产生函数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> ExprT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">UnaryExpr&lt;ExprT, <span class="keyword">double</span>(*)(<span class="keyword">double</span>)&gt; <span class="built_in">sqrt</span>(<span class="keyword">const</span> ExprT&amp; e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> UnaryExpr&lt;ExprT, <span class="keyword">double</span>(*)(<span class="keyword">double</span>)&gt;(e, ::<span class="built_in">std</span>::<span class="built_in">sqrt</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> ExprT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">UnaryExpr&lt;ExprT, <span class="keyword">double</span>(*)(<span class="keyword">double</span>)&gt; <span class="built_in">exp</span>(<span class="keyword">const</span> ExprT&amp; e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> UnaryExpr&lt;ExprT,<span class="keyword">double</span>(*)(<span class="keyword">double</span>)&gt;(e,::<span class="built_in">std</span>::<span class="built_in">exp</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过这些修改，我们得到了一个有力的高性能数值表达式计算库。利用前述所述的技术，不难为这个库增添逻辑计算的功能。如果将求值函数eval()改为括号算符的重载operator()()，我们可以很容易的将表达式对象转换为仿函数对象，这样就可以应用在STL的算法库中。下面是一个将逻辑表达式应用于计算链表中符合条件的元素个数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Identity&lt;<span class="keyword">int</span>&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">count_if(l.begin(), l.end(), x &gt;= <span class="number">10</span> &amp;&amp; x &lt;= <span class="number">100</span>);</span></pre></td></tr></table></figure>
<p>一旦编写好相应的表达式模板，就可以如上述例子所示一般，令代码兼具高度可读性和高效的运行时表现。建立这样的表达式模板库则相当复杂，需要使用本文尚未提及的许多模板编程技巧。但是无论如何，本文中涉及的编程原理已经覆盖了所有的模板库。</p>
<h3 id="类型区分"><a class="markdownIt-Anchor" href="#类型区分"></a> 类型区分</h3>
<blockquote>
<p>开发某些相对较小、并且互相独立的功能，而且对于这些简单功能而言，模板是最好的实现方法：</p>
</blockquote>
<ol>
<li>一个用于类型区分的框架；</li>
<li>智能指针</li>
<li>tuple</li>
<li>仿函数</li>
</ol>
<h4 id="辨别基本类型"><a class="markdownIt-Anchor" href="#辨别基本类型"></a> 辨别基本类型</h4>
<p>主要介绍用模板实现对类型的辨识，判断其是内建类型、指针类型、class类型或者其他类型中的哪一种。</p>
<p>缺省情况下，我们一方面假定一个类型不是一个基本类型，另一方面我们为所有的基本类型都特化给模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本模板：一般情况下T不是基本类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFundaT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span>, No = <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于特化基本类型的宏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MK_FUNDA_TYPE(T)                 \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">IsFundaT</span>&lt;T&gt; &#123;</span>            \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:                                                \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">1</span>, No = <span class="number">0</span> &#125;;                \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">void</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">bool</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">char</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">signed</span> <span class="keyword">char</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">wchar_t</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">signed</span> <span class="keyword">short</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">signed</span> <span class="keyword">int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">signed</span> <span class="keyword">long</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LONGLONG_EXISTS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   <span class="comment">// LONGLONG_EXISTS</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">float</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">double</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">MK_FUNDA_TYPE(<span class="keyword">long</span> <span class="keyword">double</span>)</span></pre></td></tr></table></figure>
<h4 id="辨别组合类型"><a class="markdownIt-Anchor" href="#辨别组合类型"></a> 辨别组合类型</h4>
<p>组合类型是指一些构造自其他类型的类型。简单的组合类型包括：</p>
<ul>
<li>普通类型</li>
<li>指针类型</li>
<li>引用类型</li>
<li>数组类型</li>
</ul>
<p>它们都是构造自单一的基本类型。同时，class类型和函数类型也是组合类型，但这些组合类型通常都会涉及到多种类型（例如参数或者成员的类型）。在此，我们先考虑简单的组合类型；</p>
<p>另外，我们还将使用局部特化对简单的组合类型进行区分。接下来，我们将定义一个trait类，用于描述简单的组合类型；而class类型和枚举类型将在最后考虑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>                // 基本模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">0</span>, IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>成员类型BaseT指的是：用于构造模板参数类型T的（直接）类型；而BottomT指的是最终去除指针、引用和数组之后的、用于构造T的原始类型。例如，如果T是int**,那么BaseT将是int*，而BottomT将会是int类型。对于成员指针类型，BaseT将会是成员的类型，而ClassT将会是成员所属的类的类型。例如，如果T是一个类型为int(X:😗)()的成员函数指针，那么BaseT将会是函数类型int()，而ClassT的类型则为X。如果T不是成员指针类型，那么ClassT将会是CompoundT<void>（这个选择并不是必须的，也可以使用一个noclass来作为ClassT）。</void></p>
<p>其中，针对指针和引用的局部特化是相当直接的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>&lt;T&amp;&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">1</span>, IsArrayT = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> CompoundT&lt;T&gt;::BottomT BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>&lt;T*&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">1</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> CompoundT&lt;T&gt;::BottomT BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>对于成员指针和数组，我们可能会使用同样的技术来处理。但是，在下面的代码中我们将发现，与基本模板相比，这些局部特化将会涉及到更多的模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>&lt;T[N]&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> CompoundT&lt;T&gt;::BottomT BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>&lt;T[]&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> CompoundT&lt;T&gt;::BottomT BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>&lt;T C::*&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = <span class="number">0</span>, IsPtrMemT = <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> CompoundT&lt;T&gt;::BottomT BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> C ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="辨别函数类型"><a class="markdownIt-Anchor" href="#辨别函数类型"></a> 辨别函数类型</h4>
<p>使用SFINAE原则的解决方案：</p>
<p>一个重载函数模板的后面可以是一些显式模板实参；而且对于某些重载函数类型而言，该实参是有效的，但对于其他的重载函数类型，该实参则可能是无效的。实际上，后面使用重载解析对枚举类型进行辨别的技术也使用到了这种方法。</p>
<p>SFINAE原则在这里的主要用处是：</p>
<ol>
<li>找到一种构造，该构造对函数类型是无效的，但是对于其他类型都是有效的；或者完全相反。由于前面我们已经能够辨别出几种类型了，所以我们在此可以不再考虑这些（已经可以辨别的）类型。</li>
<li>因此，针对上面这种要求，数组类型就是一种有效的构造；因为数组的元素是不能为void值、引用或者函数的。故而可以编写如下代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">char</span> One;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">char</span> a[<span class="number">2</span>]; &#125; Two;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">static</span> One <span class="title">test</span> <span class="params">( ... )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">static</span> Two <span class="title">test</span> <span class="params">( U (*)[<span class="number">1</span>] )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 不理解，下面的IsFunctionT&lt;T&gt;::test&lt;T&gt;(0)怎么匹配？</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="keyword">sizeof</span>(IsFunctionT&lt;T&gt;::test&lt;T&gt;(<span class="number">0</span>)) == <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>借助于上面这个模板定义，只有对于那些不能作为数组元素类型的类型，IsFunctionT::Yes才是非零值（即为1）。另外，我们应该知道该方法也有一个不足之处；并非只有函数类型不能作为数组元素类型，引用类型和void类型同样也不能作为数组元素类型。<br>
幸运的是，我们可以通过为引用类型提供局部特化，以及为void类型提供显式特化，来解决这个不足：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;T&amp;&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;void const&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>至此，我们可以重新改写基本的CompoundT模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">char</span> One;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">char</span> a[<span class="number">2</span>]; &#125; Two;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">static</span> One <span class="title">test</span> <span class="params">( ... )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">static</span> Two <span class="title">test</span> <span class="params">( U (*)[<span class="number">1</span>] )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="keyword">sizeof</span>(IsFunctionT&lt;T&gt;::test&lt;T&gt;(<span class="number">0</span>)) == <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;T&amp;&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsFunctionT</span>&lt;void const&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; Yes = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于void volatile 和 void const volatile类型也是一样的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundT</span>                // 基本模板</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; IsPtrT = <span class="number">0</span>, IsRefT = <span class="number">0</span>, IsArrayT = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsFuncT = IsFunctionT&lt;T&gt;::Yes, IsPtrMemT = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T BottomT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CompoundT&lt;<span class="keyword">void</span>&gt; ClassT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="运用重载解析辨别枚举类型"><a class="markdownIt-Anchor" href="#运用重载解析辨别枚举类型"></a> 运用重载解析辨别枚举类型</h4>
<p>重载解析是一个过程，它会根据函数参数的类型，在多个同名函数中选择出一个合适的函数。<br>
接下来我们将看到，即使没有进行实际的函数调用，我们也能够利用重载解析来确定所需要的结果。</p>
<p>总之，对于测试某个特殊的隐式转型是否存在的情况，利用重载解析的方法是相当有用的。<br>
在此，我们将要利用从枚举类型到整型的隐式转型：它能够帮助我们分辨枚举类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SizeOverOne</span> &#123;</span> <span class="keyword">char</span> c[<span class="number">2</span>]; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">bool</span> convert_possible = !CompoundT&lt;T&gt;::IsFuncT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                   !CompoundT&lt;T&gt;::IsArrayT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class ConsumeUDC</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在ConsumeUDC模板中已经强制定义了一个到T的自定义转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">operator</span> T() <span class="keyword">const</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 到函数类型的转型是不允许的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 如果由基本模板得到的convert_possible为false,则匹配此特化；不转型--&gt;无自定义转型操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeUDC</span>&lt;T, false&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 到void类型的转型是不允许的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> convert_possible&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeUDC</span>&lt;void, convert_possible&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">char</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">wchar_t</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">short</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">long</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LONGLONG_EXISTS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>     <span class="comment">// LONGLONG_EXISTS</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 避免从float到int的意外转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">enum_check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">SizeOverOne <span class="title">enum_check</span><span class="params">( ... )</span></span>;         <span class="comment">// 捕获剩余所有情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsEnumT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Yes = IsFundaT&lt;T&gt;::No &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsRefT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsPtrT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsPtrMemT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">sizeof</span>(enum_check(ConsumeUDC&lt;T&gt;())) == <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面代码的核心在于后面的一个sizeof表达式，它的参数是一个函数调用。也就是说，该sizeof表达式将会返回函数调用返回值的类型的大小；其中，将应用重载解析原则来处理enum_check()调用；但另一方面，我们并不需要函数定义，因为实际上并没有真正调用该函数。在上面的例子中，如果实参可以转型为一个整型，那么enum_check()将返回一个char值，其大小为1。对于其他的所有类型，我们使用了一个省略号函数（即enum_check( … ) ），然而，根据重载解析原则的优先顺序，省略号函数将会是最后的选择。在此，我们对enum_check()的省略号版本进行了特殊的处理，让它返回一个大小大于一个字节的类型（即SizeOverOne）。</p>
<p>对于函数enum_check的调用实参，我们必须仔细地考虑。首先，我们并不知道T是如何构造的，或许将会调用一个特殊的构造函数。为了解决这个问题，我们可以声明一个返回类型为T的函数，然后通过调用这个函数来创建一个T。由于处于sizeof表达式内部，因此该函数实际上并不需要具有函数定义。事实上，更加巧妙的是：对于一个class类型T，重载解析是有可能选择一个针对整型的enum_check()声明的，但前提是该class必须定义一个到整型的自定义转型（有时也称为UDC）函数。到此，问题已经解决了。因为我们在ConsumeUDC模板中已经强制定义了一个到T的自定义转型，该转型运算符同时也为sizeof运算符生成了一个类型为T的实参。下面我们详细分析下：</p>
<ol>
<li>最开始的实参是一个临时的ConsumeUDC<t>对象；</t></li>
<li>如果T是一个基本整型，那么将会借助于（ConsumeUDC的）转型运算符来创建一个enum_check()的匹配，该enum_check()以T为实参；</li>
<li>如果T是一个枚举类型，那么将会借助于（ConsumeUDC的）转型运算符，先把类型转化为T，然后调用（从枚举类型到整型的）类型提升，从而能够匹配一个接收转型参数的enum_check()函数（通常而言是enum_check(int)）；</li>
<li>如果T是一个class类型，而且已经为该class自定义了一个到整型的转型运算符，那么这个转型运算符将不会被考虑。因为对于以匹配为目的的自定义转型而言，最多只能调用一次；而且在前面已经使用了一个从ConsumeUDC<t>到T的自定义转型，所以也就不允许再次调用自定义转型。也就是说，对enum_check()函数而言，class类型最终还是未能转型为整型。</t></li>
<li>如果最终还是不能让类型T于整型互相匹配，那么将会选择enum_check()函数的省略号版本。</li>
</ol>
<p>最后，由于我们这里只是为了辨别枚举类型，而不是基本类型或者指针类型，所有我们使用了前面已经开放的IsFundaT和CompoundT类型，从而能够排除这些令IsEnumT<t>::Yes成为非零的其他类型，最后使得只有枚举类型的IsEnumT::Yes才等于1。</t></p>
<h4 id="辨别class类型"><a class="markdownIt-Anchor" href="#辨别class类型"></a> 辨别class类型</h4>
<p>使用排除原理：如果一个类型不是一个基本类型，也不是枚举类型和组合类型，那么该类型就只能是class类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsClassT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Yes = IsFundaT&lt;T&gt;::No &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IsEnumT&lt;T&gt;::No &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsPtrT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsRefT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsArrayT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsPtrMemT &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    !CompoundT&lt;T&gt;::IsFuncT</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; No = !Yes &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h3 id="模板元编程与可变模板编程"><a class="markdownIt-Anchor" href="#模板元编程与可变模板编程"></a> 模板元编程与可变模板编程</h3>
<h4 id="模版元基本概念"><a class="markdownIt-Anchor" href="#模版元基本概念"></a> 模版元基本概念</h4>
<p>模版元程序由元数据和元函数组成，元数据就是元编程可以操作的数据，即C++编译器在编译期可以操作的数据。<br>
元数据不是运行期变量，只能是编译期常量，不能修改，常见的元数据有</p>
<ul>
<li>enum枚举常量</li>
<li>静态常量</li>
<li>基本类型</li>
<li>自定义类型</li>
</ul>
<p>元函数是模板元编程中用于操作处理元数据的“构件”，可以在编译期被“调用”，因为它的功能和形式和运行时的函数类似，而被称为元函数，它是元编程中最重要的构件。元函数实际上表现为C++的一个类、模板类或模板函数，它的通常形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">int</span> M&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_func</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = N+M;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>调用元函数获取value值：<code>cout&lt;&lt;meta_func&lt;1, 2&gt;::value&lt;&lt;endl;</code><br>
meta_func的执行过程是在编译期完成的，实际执行程序时，是没有计算动作而是直接使用编译期的计算结果的。元函数只处理元数据，元数据是编译期常量和类型，所以下面的代码是编译不过的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">meta_func&lt;i, j&gt;::value; <span class="comment">//错误，元函数无法处理运行时普通数据</span></span></pre></td></tr></table></figure>
<p>模板元编程产生的源程序是在编译期执行的程序，因此它首先要遵循C<ins>和模板的语法，但是它操作的对象不是运行时普通的变量，因此不能使用运行时的C</ins>关键字（如if、else、for），可用的语法元素相当有限，最常用的是：</p>
<p>enum、static const，用来定义编译期的整数常量；</p>
<ul>
<li>typedef/using，用于定义元数据；</li>
<li>T、Args…，声明元数据类型；</li>
<li>template，主要用于定义元函数；</li>
<li>“::”，域运算符，用于解析类型作用域获取计算结果（元数据）</li>
</ul>
<p>如果模板元编程中需要if-else、for等逻辑时该怎么办呢？</p>
<blockquote>
<p><strong>模板元中的if-else可以通过type_traits来实现</strong>。<br>
<strong>type_traits不仅仅可以在编译期做判断，还可以做计算、查询、转换和选择</strong>。</p>
</blockquote>
<blockquote>
<p><strong>模板元中的for等逻辑可以通过递归、重载、和模板特化（偏特化）等方法实现</strong>。</p>
</blockquote>
<h4 id="type_traits"><a class="markdownIt-Anchor" href="#type_traits"></a> type_traits</h4>
<p>type_traits是C++11提供的模板元基础库，通过type_traits可以实现在编译期计算、查询、判断、转换和选择，提供了模板元编程需要的一些常用元函数。下面来看看一些基本的type_traits的基本用法。</p>
<p>最简单的一个type_traits是定义编译期常量的元函数integral_constant，它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">v</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">struct</span> <span class="title">integral_constant</span>;</span></span></pre></td></tr></table></figure>
<p>借助这个简单的trait，我们可以很方便地定义编译期常量，比如定义一个值为1的int常量可以这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> one_type = <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, <span class="number">1</span>&gt;;</span></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">struct</span> <span class="title">one_type</span> :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, <span class="number">1</span>&gt;&#123;&#125;;</span></pre></td></tr></table></figure>
<p>获取常量则通过one_type::value来获取，这种定义编译期常量的方式相比C<ins>98/03要简单，在C</ins>98/03中定义编译期常量一般是这样定义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">struct</span> <span class="title">one_type</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123;value = <span class="number">1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">struct</span> <span class="title">one_type</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>可以看到，通过C<ins>11的type_traits提供的一个简单的integral_constant就可以很方便的定义编译期常量，而无需再去通过定义enum和static const变量方式去定义编译期常量了，这也为定义编译期常量提供了另外一种方法。C</ins>11的type_traits已经提供了编译期的true和false，是通过integral_constant来定义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt; true_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type;</span></pre></td></tr></table></figure>
<p>除了这些基本的元函数之外，type_traits还提供了丰富的元函数，比如用于编译期判断的元函数：<br>
<img alt="c++11_type_traits" data-src="/assets/2019/12/09/c++11_type_traits.png"></p>
<p>这只是列举一小部分的type_traits元函数，<a href="http://en.cppreference.com/w/cpp/header/type_traits" target="_blank" rel="noopener">c++11 type_traits</a>提供了上百个方便的元函数<br>
这些基本的元函数用法比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"const int: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//判断类型是否相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value&lt;&lt;<span class="string">"\n"</span>;<span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, unsignedint&gt;::value&lt;&lt;<span class="string">"\n"</span>;<span class="comment">// false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//添加、移除const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">const</span> <span class="keyword">int</span>, add_const&lt;<span class="keyword">int</span>&gt;::type&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, remove_const&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;::type&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//添加引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>&amp;, add_lvalue_reference&lt;<span class="keyword">int</span>&gt;::type&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>&amp;&amp;, add_rvalue_reference&lt;<span class="keyword">int</span>&gt;::type&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//取公共类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::common_type&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>, <span class="keyword">short</span>, <span class="keyword">int</span>&gt;::type NumericType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, NumericType&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>type_traits还提供了编译期选择traits：std::conditional，它在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似于一个三元表达式。它的原型是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">F</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">struct</span> <span class="title">conditional</span>;</span></span></pre></td></tr></table></figure>
<p>用法很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;<span class="literal">true</span>,<span class="keyword">int</span>,<span class="keyword">float</span>&gt;::type A;               <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;<span class="literal">false</span>,<span class="keyword">int</span>,<span class="keyword">float</span>&gt;::type B;              <span class="comment">// float</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;(<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &gt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">double</span>&gt;::type <span class="keyword">max_size_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">max_size_t</span>).name()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//long double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>另外一个常用的type_traits是std::decay(朽化)，它对于普通类型来说std::decay（朽化）是移除引用和cv符，大大简化了我们的书写。除了普通类型之外，std::decay还可以用于数组和函数，具体的转换规则是这样的：</p>
<p>先移除T类型的引用，得到类型U，U定义为remove_reference<t>::type。</t></p>
<ul>
<li>如果is_array&lt;U&gt;::value为 true，修改类型type为remove_extent&lt;U&gt;::type *。</li>
<li>否则，如果is_function&lt;U&gt;::value为 true，修改类型type将为add_pointer&lt;U&gt;::type。</li>
<li>否则，修改类型type为 remove_cv&lt;U&gt;::type。</li>
</ul>
<p>std::decay的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">int</span>&gt;::type A;           <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">int</span>&amp;&gt;::type B;          <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">int</span>&amp;&amp;&gt;::type C;         <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;constint&amp;&gt;::type D;    <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">int</span>[<span class="number">2</span>]&gt;::type E;        <span class="comment">// int*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;::type F;      <span class="comment">// int(*)(int)</span></span></pre></td></tr></table></figure>
<p>std::decay除了移除普通类型的cv符的作用之外，还可以将函数类型转换为函数指针类型，从而将函数指针变量保存起来，以便在后面延迟执行，比如下面的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpFunction</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> FnType = <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;F&gt;::type;<span class="comment">//先移除引用再添加指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SimpFunction(F&amp; f) : m_fn(f)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_fn();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FnType m_fn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>如果要保存输入的函数，则先要获取函数对应的函数指针类型，这时就可以用std::decay来获取函数指针类型了，using FnType = typename std::decay&lt;F&gt;::type;实现函数指针类型的定义。type_traits还提供了获取可调用对象返回类型的元函数：std::result_of，它的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">int</span>();&#125;                            <span class="comment">// function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(&amp;fn_ref)</span><span class="params">(<span class="keyword">int</span>)</span></span>;                             <span class="comment">// function reference</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*fn_ptr)</span><span class="params">(<span class="keyword">int</span>)</span></span>;                             <span class="comment">// function pointer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fn_class</span> &#123;</span> <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> i;&#125; &#125;;  <span class="comment">// function-like class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;<span class="keyword">decltype</span>(fn)&amp;(<span class="keyword">int</span>)&gt;::type A;  <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;fn_ref(<span class="keyword">int</span>)&gt;::type B;         <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;fn_ptr(<span class="keyword">int</span>)&gt;::type C;         <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;fn_class(<span class="keyword">int</span>)&gt;::type D;       <span class="comment">// int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>type_traits还提供了一个很有用的元函数std::enable_if，它利用SFINAE(substitude failure is not an error)特性，根据条件选择重载函数的元函数std::enable_if，它的原型是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt; <span class="title">struct</span> <span class="title">enable_if</span>;</span></span></pre></td></tr></table></figure>
<p>根据enable_if的字面意思就可以知道，它使得函数在判断条件B仅仅为true时才有效，它的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, T&gt;::<span class="function">type <span class="title">foo</span><span class="params">(T t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = foo(<span class="number">1</span>); <span class="comment">//返回整数1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r1 = foo(<span class="number">1.2</span>); <span class="comment">//返回浮点数1.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r2 = foo(“test”); <span class="comment">//compile error</span></span></pre></td></tr></table></figure>
<p>在上面的例子中对模板参数T做了限定，即只能是arithmetic（整型和浮点型）类型，如果为非arithmetic类型，则编译不通过，因为std::enable_if只对满足判断式条件的函数有效，对其他函数无效。</p>
<p>可以通过enable_if来实现编译期的if-else逻辑，比如下面的例子通过enable_if和条件判断式来将入参分为两大类，从而满足所有的入参类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, <span class="keyword">int</span>&gt;::<span class="function">type <span class="title">foo1</span><span class="params">(T t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;!<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, <span class="keyword">int</span>&gt;::<span class="function">type <span class="title">foo1</span><span class="params">(T &amp;t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>对于arithmetic类型的入参则返回0，对于非arithmetic的类型则返回1，通过arithmetic将所有的入参类型分成了两大类进行处理。从上面的例子还可以看到，std::enable_if可以实现强大的重载机制，因为通常必须是参数不同才能重载，如果只有返回值不同是不能重载的，而在上面的例子中，返回类型相同的函数都可以重载。</p>
<p>C<ins>11的type_traits提供了近百个在编译期计算、查询、判断、转换和选择的元函数，为我们编写元程序提供了很大的便利。如果说C</ins>11的type_traits让模版元编程变得简单，那么C++11提供的可变模板参数和tuple则进一步增强了模板元编程。</p>
<h4 id="可变模板参数"><a class="markdownIt-Anchor" href="#可变模板参数"></a> 可变模板参数</h4>
<h5 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h5>
<p>C<ins>11的新特性–可变模版参数（variadic templates）是C</ins>11新增的最强大的特性之一，它对参数进行了高度泛化，它能表示0到任意个数、任意类型的参数。相比C++98/03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。</p>
<p>然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以它也是C<ins>11中最难理解和掌握的特性之一。虽然掌握可变模版参数有一定难度，但是它却是C</ins>11中最有意思的一个特性。</p>
<h5 id="可变模版参数的展开"><a class="markdownIt-Anchor" href="#可变模版参数的展开"></a> 可变模版参数的展开</h5>
<p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“…”。比如我们常常这样声明一个可变模版参数：template&lt;typename…&gt;或者template&lt;class…&gt;，一个典型的可变模版参数的定义是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span></pre></td></tr></table></figure>
<p>可变模版参数的定义当中，省略号的作用有两个：</p>
<ol>
<li>声明一个参数包T… args，这个参数包中可以包含0到任意个模板参数；</li>
<li>在模板定义的右边，可以将参数包展开成一个一个独立的参数。</li>
</ol>
<p>参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;=0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。</p>
<p>可变模版参数和普通的模版参数语义是一致的，所以可以应用于函数和类，即可变模版参数函数和可变模版参数类，然而，模版函数不支持偏特化，所以可变模版参数函数和可变模版参数类展开可变模版参数的方法还不尽相同，下面我们来分别看看他们展开可变模版参数的方法</p>
<h6 id="可变模版参数函数"><a class="markdownIt-Anchor" href="#可变模版参数函数"></a> 可变模版参数函数</h6>
<p>一个简单的可变模版参数函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>... <span class="title">args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印变参的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">f();               <span class="comment">//0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">//2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">""</span>);  <span class="comment">//3</span></span></pre></td></tr></table></figure>
<p>f()没有传入参数，所以参数包为空，输出的size为0，后面两次调用分别传入两个和三个参数，故输出的size分别为2和3。由于可变模版参数的类型和个数是不固定的，所以我们可以传任意类型和个数的参数给函数f。</p>
<p>这个例子只是简单的将可变模版参数的个数打印出来，如果我们需要将参数包中的每个参数打印出来的话就需要通过一些方法了。展开可变模版参数函数的方法一般有两种：</p>
<ol>
<li>是通过递归函数来展开参数包</li>
<li>是通过逗号表达式来展开参数包。</li>
</ol>
<p>####### 递归函数方式展开参数包<br>
通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数，递归终止函数正是用来终止递归的，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//递归终止函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//展开函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> ...<span class="title">Args</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">head</span>, <span class="title">Args</span>... <span class="title">rest</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"parameter "</span> &lt;&lt; head &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   print(rest...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上例会输出每一个参数，直到为空时输出empty。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包Args…在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。</p>
<p>递归调用的过程是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print();</span></pre></td></tr></table></figure>
<p>上面的递归终止函数还可以写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">t</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">```cpp</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="number">4</span>);</span></pre></td></tr></table></figure>
<p>当参数包展开到最后一个参数时递归为止。再看一个通过可变模版参数求和的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">sum</span> <span class="params">(T first, Types ... rest)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//10</span></span></pre></td></tr></table></figure>
<p>sum在展开参数包的过程中将各个参数相加求和，参数的展开方式和前面的打印参数包的方式是一样的。</p>
<p>####### 逗号表达式展开参数包<br>
递归函数展开参数包是一种标准做法，也比较好理解，但也有一个__缺点,就是必须要一个重载的递归终止函数__，即__必须要有一个同名的终止函数来终止递归__，这样可能会感觉稍有不便。</p>
<p>有没有一种更简单的方式呢？<br>
其实还有一种方法可以不通过递归方式来展开参数包，这种方式需要__借助逗号表达式__和__初始化列表__。比如前面print的例子可以改成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">printarg</span>(<span class="title">T</span> <span class="title">t</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">expand</span>(<span class="title">Args</span>... <span class="title">args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">int</span> arr[] = &#123;(printarg(args), <span class="number">0</span>)...&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">expand(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr></table></figure>
<p>这个例子将分别打印出1,2,3,4四个数字。这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。</p>
<p>这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">d = (a = b, c);</span></pre></td></tr></table></figure>
<p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p>
<p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。</p>
<p>同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成<br>
((printarg(arg1),0),<br>
(printarg(arg2),0),<br>
(printarg(arg3),0),<br>
etc… )，<br>
最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。<br>
由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。我们可以把上面的例子再进一步改进一下，将函数作为参数，就可以支持lambda表达式了，从而可以少写一个递归终止函数了，具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;<span class="title">void</span> <span class="title">expand</span>(<span class="title">const</span> <span class="title">F</span>&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;...<span class="title">args</span>) </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123;(f(<span class="built_in">std</span>::forward&lt; Args&gt;(args)),<span class="number">0</span>)...&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">expand([](<span class="keyword">int</span> i)&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span></pre></td></tr></table></figure>
<p>上面的例子将打印出每个参数，这里如果再使用C++14的新特性泛型lambda表达式的话，可以写更泛化的lambda表达式了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">expand([](<span class="keyword">auto</span> i)&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;, <span class="number">1</span>,<span class="number">2.0</span>,”test”);</span></pre></td></tr></table></figure>
<h6 id="可变模版参数类"><a class="markdownIt-Anchor" href="#可变模版参数类"></a> 可变模版参数类</h6>
<p>可变参数模板类是一个带可变模板参数的模板类，比如C++11中的元祖std::tuple就是一个可变模板类，它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">Types</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">class</span> <span class="title">tuple</span>;</span></span></pre></td></tr></table></figure>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>&gt; tp1 = <span class="built_in">std</span>::make_tuple(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; tp2 = <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">string</span>&gt; tp3 = <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">""</span>);</span></pre></td></tr></table></figure>
<p>可变参数模板的模板参数个数可以为0个，所以下面的定义也是也是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;&gt; tp;</span></pre></td></tr></table></figure>
<p>可变参数模板类的参数包展开的方式和可变参数模板函数的展开方式不同，<br>
可变参数模板类的参数包展开需要通过__模板特化__和__继承__方式去展开，展开方式比可变参数模板函数要复杂。下面我们来看一下展开可变模版参数类中的参数包的方法。</p>
<p>####### 模版偏特化和递归方式来展开参数包<br>
可变参数模板类的展开一般需要定义两到三个类，包括__类声明__和__偏特化的模板类__。<br>
如下方式定义了一个基本的可变参数模板类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前向声明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基本定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;First, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; value = Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//递归终止</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Last&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;Last&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="keyword">sizeof</span> (Last) &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>这个Sum类的作用是在编译期计算出参数包中参数类型的size之和，通过sum&lt;int,double,short&gt;::value就可以获取这3个类型的size之和为14。这是一个简单的通过可变参数模板类计算的例子，可以看到一个基本的可变参数模板应用类由三部分组成。</p>
<p>第一部分是：它是前向声明，声明这个sum类是一个可变参数模板类；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum</span></span></span></pre></td></tr></table></figure>
<p>第二部分是类的定义：<br>
它定义了一个部分展开的可变模参数模板类，告诉编译器如何递归展开参数包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;First, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; value = Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>第三部分是特化的递归终止类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Last&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;last&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="keyword">sizeof</span> (First) &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过这个特化的类来终止递归：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Args&gt;<span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span></pre></td></tr></table></figure>
<p>这个前向声明要求sum的模板参数至少有一个，因为可变参数模板中的模板参数可以有0个，有时候0个模板参数没有意义，就可以通过上面的声明方式来限定模板参数不能为0个。<br>
上面的这种三段式的定义也可以改为两段式的，可以将前向声明去掉，这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; value = Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Last&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;Last&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123; value = <span class="keyword">sizeof</span>(Last) &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面的方式只要一个基本的模板类定义和一个特化的终止函数就行了，而且限定了模板参数至少有一个。递归终止模板类可以有多种写法，比如上例的递归终止模板类还可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, typenameLast&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;First, Last&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123; value = <span class="keyword">sizeof</span>(First) +<span class="keyword">sizeof</span>(Last) &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在展开到最后两个参数时终止。<br>
还可以在展开到0个参数时终止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;&gt; &#123;</span> <span class="keyword">enum</span>&#123; value = <span class="number">0</span> &#125;; &#125;;</span></pre></td></tr></table></figure>
<p>还可以使用std::integral_constant来消除枚举定义value。<br>
利用std::integral_constant可以获得编译期常量的特性，可以将前面的sum例子改为这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前向声明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基本定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;First, Rest...&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//递归终止</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Last&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;Last&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, <span class="keyword">sizeof</span>(Last)&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">sum&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">short</span>&gt;::value;<span class="comment">//值为14</span></span></pre></td></tr></table></figure>
<p>####### 继承方式展开参数包<br>
还可以通过继承方式来展开参数包，比如下面的例子就是通过继承的方式去展开参数包：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整型序列的定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>...&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexSeq</span>&#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//继承方式，开始展开参数包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span> :</span> MakeIndexes&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Indexes...&gt; &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 模板特化，终止展开参数包的条件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span>&lt;0, Indexes...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    typedefIndexSeq&lt;Indexes...&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> T = MakeIndexes&lt;<span class="number">3</span>&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其中MakeIndexes的作用是为了生成一个可变参数模板类的整数序列，最终输出的类型是：struct IndexSeq&lt;0,1,2&gt;。</p>
<p>MakeIndexes继承于自身的一个特化的模板类，这个特化的模板类同时也在展开参数包，这个展开过程是通过继承发起的，直到遇到特化的终止条件展开过程才结束。<br>
MakeIndexes&lt;1,2,3&gt;::type的展开过程是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MakeIndexes&lt;<span class="number">3</span>&gt; : MakeIndexes&lt;<span class="number">2</span>, <span class="number">2</span>&gt;&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">MakeIndexes&lt;<span class="number">2</span>, <span class="number">2</span>&gt; : MakeIndexes&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">MakeIndexes&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&gt; : MakeIndexes&lt;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> IndexSeq&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过不断的继承递归调用，最终得到整型序列IndexSeq&lt;0, 1, 2&gt;。<br>
如果不希望通过继承方式去生成整形序列，则可以通过下面的方式生成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes3</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> MakeIndexes3&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Indexes...&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes3</span>&lt;0, Indexes...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> IndexSeq&lt;Indexes...&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>我们看到了如何利用递归以及偏特化等方法来展开可变模版参数，下面来看看可变模版参数的一些应用。</p>
<h5 id="可变参数模版消除重复代码"><a class="markdownIt-Anchor" href="#可变参数模版消除重复代码"></a> 可变参数模版消除重复代码</h5>
<p>C++11之前如果要写一个泛化的工厂函数，这个工厂函数能接受任意类型的入参，并且参数个数要能满足大部分的应用需求的话，我们不得不定义很多重复的模版定义，比如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T0&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(T0 arg0)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(T0 arg0, T1 arg1)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg0, arg1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(T0 arg0, T1 arg1, T2 arg2)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg0, arg1, arg2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(T0 arg0, T1 arg1, T2 arg2, T3 arg3)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg0, arg1, arg2, arg3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg0, arg1, arg2, arg3, arg4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    A(<span class="keyword">int</span>)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">int</span>,<span class="keyword">double</span>)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">A* pa = Instance&lt;A&gt;(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">B* pb = Instance&lt;B&gt;(<span class="number">1</span>,<span class="number">2</span>);</span></pre></td></tr></table></figure>
<p>可以看到这个泛型工厂函数存在大量的重复的模板定义，并且限定了模板参数。<br>
通过可变参数模版优化后的工厂函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>…  Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(Args&amp;&amp;… args)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)…);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">A* pa = Instance&lt;A&gt;(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">B* pb = Instance&lt;B&gt;(<span class="number">1</span>,<span class="number">2</span>);</span></pre></td></tr></table></figure>
<h5 id="可变参数模版实现泛化的delegate"><a class="markdownIt-Anchor" href="#可变参数模版实现泛化的delegate"></a> 可变参数模版实现泛化的delegate</h5>
<p>C++中没有类似C#的委托，我们可以借助可变模版参数来实现一个。C#中的委托的基本用法是这样的：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">AggregateDelegate</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;<span class="comment">//声明委托类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>&#123;<span class="keyword">return</span> x+y;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>&#123;<span class="keyword">return</span> x-y;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">AggregateDelegate <span class="keyword">add</span> = Add;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">add</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//调用委托对象求和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">AggregateDelegate sub = Sub;</span></pre></td></tr><tr><td class="code"><pre><span class="line">sub(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">// 调用委托对象相减</span></span></pre></td></tr></table></figure>
<p>C#中的委托的使用需要先定义一个委托类型，这个委托类型不能泛化，即委托类型一旦声明之后就不能再用来接受其它类型的函数了，比如这样用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z</span>)</span>&#123;<span class="keyword">return</span> x+y+z;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun1</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> r</span>)</span>&#123;<span class="keyword">return</span> s.Length+r.Length; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">AggregateDelegate fun = Fun; <span class="comment">//编译报错，只能赋值相同类型的函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">AggregateDelegate fun1 = Fun1;<span class="comment">//编译报错，参数类型不匹配</span></span></pre></td></tr></table></figure>
<p>这里不能泛化的原因是声明委托类型的时候就限定了参数类型和个数，在C<ins>11不存在这个问题了。因为有了可变模版参数，它就代表了任意类型和个数的参数了，下面让我们来看一下如何实现一个功能更加泛化的C</ins>版本的委托（这里为了简单起见只处理成员函数的情况，并且忽略const、volatile和const volatile成员函数的处理）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">R</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">class</span>  <span class="title">MyDelegate</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyDelegate(T* t, R  (T::*f)(Args...) ):<span class="keyword">m_t</span>(t),m_f(f) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">m_t</span>-&gt;*m_f)(<span class="built_in">std</span>::forward&lt;Args&gt;(args) ...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T* <span class="keyword">m_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    R  (T::*m_f)(Args...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;   </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">R</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">MyDelegate</span>&lt;T, R, Args...&gt; <span class="title">CreateDelegate</span>(<span class="title">T</span>* <span class="title">t</span>, <span class="title">R</span> (<span class="title">T</span>:</span>:*f)(Args...))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MyDelegate&lt;T, R, Args...&gt;(t, f);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> j)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;i+j&lt;&lt;<span class="built_in">endl</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> d = CreateDelegate(&amp;a, &amp;A::Fun); <span class="comment">//创建委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d(<span class="number">1</span>); <span class="comment">//调用委托，将输出1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> d1 = CreateDelegate(&amp;a, &amp;A::Fun1); <span class="comment">//创建委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d1(<span class="number">1</span>, <span class="number">2.5</span>); <span class="comment">//调用委托，将输出3.5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>MyDelegate实现的关键是内部定义了一个能接受任意类型和个数参数的“万能函数”：R  (T::*m_f)(Args…)，正是由于可变模版参数的特性，所以我们才能够让这个m_f接受任意参数。</p>
<h5 id="编译期获取最大值"><a class="markdownIt-Anchor" href="#编译期获取最大值"></a> 编译期获取最大值</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取最大的整数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg, <span class="keyword">size_t</span>... rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>&lt;arg&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">size_t</span>, arg&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg1, <span class="keyword">size_t</span> arg2, <span class="keyword">size_t</span>... rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>&lt;arg1, arg2, rest...&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">size_t</span>, arg1 &gt;= arg2 ? IntegerMax&lt;arg1, rest...&gt;::value :</span></pre></td></tr><tr><td class="code"><pre><span class="line">    IntegerMax&lt;arg2, rest...&gt;::value &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>这个IntegerMax的实现用到了type_traits中的std::integral_const，它在展开参数包的过程中，不断的比较，直到所有的参数都比较完，最终std::integral_const的value值即为最大值。它的使用很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; IntegerMax&lt;<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//value为7</span></span></pre></td></tr></table></figure>
<p>我们可以在IntegerMax的基础上轻松的实现获取最大内存对齐值的元函数MaxAlign。</p>
<h5 id="编译期获取最大的align"><a class="markdownIt-Anchor" href="#编译期获取最大的align"></a> 编译期获取最大的align</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxAlign</span> :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, IntegerMax&lt;<span class="built_in">std</span>::alignment_of&lt;Args&gt;::value...&gt;::value&gt;&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; MaxAlign&lt;<span class="keyword">int</span>, <span class="keyword">short</span>, <span class="keyword">double</span>, <span class="keyword">char</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//value为8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译判断是否包含了某种类型：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span>... List &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Rest &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>&lt;T, Head, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    :</span> <span class="built_in">std</span>::conditional&lt; <span class="built_in">std</span>::is_same&lt;T, Head&gt;::value, <span class="built_in">std</span>::true_type, Contains&lt;T, Rest... &gt;&gt; ::type&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>&lt;T&gt; :</span> <span class="built_in">std</span>::false_type&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;Contains&lt;<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">short</span>&gt;::value&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出true</span></span></pre></td></tr></table></figure>
<p>这个Contains的实现用到了type_traits的std::conditional、std::is_same、std::true_type和std::false_type，它的实现思路是在展开参数包的过程中不断的比较类型是否相同，如果相同则设置值为true，否则设置为false。</p>
<h5 id="编译期获取类型的索引"><a class="markdownIt-Anchor" href="#编译期获取类型的索引"></a> 编译期获取类型的索引</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span>... List &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Rest &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T, Head, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123; value = IndexOf&lt;T, Rest...&gt;::value+<span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T, T, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123; value = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span>&#123;value = <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt; IndexOf&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">short</span>, <span class="keyword">char</span>, <span class="keyword">int</span>, <span class="keyword">float</span>&gt;::value&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出3</span></span></pre></td></tr></table></figure>
<p>这个IndexOf的实现比较简单，在展开参数包的过程中看是否匹配到特化的IndexOf&lt;T, T, Rest…&gt;，如果匹配上则终止递归将之前的value累加起来得到目标类型的索引位置，否则将value加1，如果所有的类型中都没有对应的类型则返回-1；</p>
<h5 id="编译期根据索引位置查找类型"><a class="markdownIt-Anchor" href="#编译期根据索引位置查找类型"></a> 编译期根据索引位置查找类型</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> index, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> index, <span class="keyword">typename</span> First, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>&lt;index, First, Types...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> At&lt;index - <span class="number">1</span>, Types...&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>&lt;0, T, Types...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> type = T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> T = At&lt;<span class="number">1</span>, <span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">char</span>&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出double</span></span></pre></td></tr></table></figure>
<p>At的实现比较简单，只要在展开参数包的过程中，不断的将索引递减至0时为止即可获取对应索引位置的类型。</p>
<h5 id="编译期遍历类型"><a class="markdownIt-Anchor" href="#编译期遍历类型"></a> 编译期遍历类型。</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printarg</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_each</span><span class="params">()</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123;(printarg&lt;Args&gt;(), <span class="number">0</span>)...&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">for_each&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;();<span class="comment">//将输出int double</span></span></pre></td></tr></table></figure>
<p>这里for_each的实现是通过初始化列表和逗号表达式来遍历可变模板参数的。</p>
<p>可以看到，借助__可变模板参数__和__type_traits__以及__模板偏特化__和__递归等方式__我们可以实现一些有用的编译期算法。这些算法为我们编写应用层级别的代码奠定了基础，后面模板元编程的具体应用中将会用到这些元函数。</p>
<h5 id="tuple与模版元"><a class="markdownIt-Anchor" href="#tuple与模版元"></a> tuple与模版元</h5>
<p>C++11的tuple本身就是一个可变模板参数组成的元函数，它的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>...<span class="title">Types</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">class</span> <span class="title">tuple</span>;</span></span></pre></td></tr></table></figure>
<p>tuple在模版元编程中的一个应用场景是将可变模板参数保存起来，因为可变模板参数不能直接作为变量保存起来，需要借助tuple保存起来，保存之后再在需要的时候通过一些手段将tuple又转换为可变模板参数。这个过程有点类似于化学中的“氧化还原反应”。</p>
<p>看看下面的例子中，可变模板参数和tuple是如何相互转换的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义整形序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>...&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexSeq</span>&#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//生成整形序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span> :</span> MakeIndexes&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Indexes...&gt;&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span>&lt;0, indexes...&gt;&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> IndexSeq&lt;indexes...&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printargs</span><span class="params">(Args... args)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//先将可变模板参数保存到tuple中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print_helper(<span class="keyword">typename</span> MakeIndexes&lt;<span class="keyword">sizeof</span>... (Args)&gt;::type(), <span class="built_in">std</span>::make_tuple(args...));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... Indexes, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_helper</span><span class="params">(IndexSeq&lt;Indexes...&gt;, <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp;&amp; tup)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//再将tuple转换为可变模板参数，将参数还原回来，再调用print</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="built_in">std</span>::get&lt;Indexes&gt;(tup)...); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t, Args... args)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(args...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">printargs(<span class="number">1</span>, <span class="number">2.5</span>, “test”); <span class="comment">//将输出1 2.5 test</span></span></pre></td></tr></table></figure>
<p>上面的例子print实际上是输出可变模板参数的内容，具体做法是</p>
<ol>
<li>将可变模板参数保存到tuple中</li>
<li>通过元函数MakeIndexes生成一个整形序列，这个整形序列就是IndexSeq&lt;0,1,2&gt;<br>
整形序列代表了tuple中元素的索引，</li>
<li>生成整形序列之后再调用print_helper，在print_helper中展开这个整形序列<br>
展开的过程中根据具体的索引从tuple中获取对应的元素，</li>
<li>最终将从tuple中取出来的元素组成一个可变模板参数，从而实现了tuple“还原”为可变模板参数</li>
<li>最终调用print打印可变模板参数。</li>
</ol>
<p>tuple在模板元编程中的另外一个应用场景是用来实现一些编译期算法，比如常见的遍历、查找和合并等算法，实现的思路和可变模板参数实现的编译期算法类似。</p>
<h5 id="模版元实现function_traits"><a class="markdownIt-Anchor" href="#模版元实现function_traits"></a> 模版元实现function_traits</h5>
<p>function_traits用来获取函数语义的可调用对象的一些属性，比如函数类型、返回类型、函数指针类型和参数类型等。下面来看看如何实现function_traits</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;Ret(Args...)&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; arity = <span class="keyword">sizeof</span>...(Args) &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">typedef</span> Ret <span class="title">function_type</span><span class="params">(Args...)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> Ret return_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> stl_function_type = <span class="built_in">std</span>::function&lt;function_type&gt;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">Ret</span><span class="params">(*pointer)</span><span class="params">(Args...)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">size_t</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">args</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">static_assert</span>(I &lt; arity, <span class="string">"index is out of range, index must less than sizeof Args"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">using</span> type = <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;I, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;Ret(*)(Args...)&gt; :</span> function_traits&lt;Ret(Args...)&gt;&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//std::function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;std::function&lt;Ret(Args...)&gt;&gt; :</span> function_traits&lt;Ret(Args...)&gt;&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//member function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_TRAITS(...) \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span> ClassType, <span class="keyword">typename</span>... Args&gt;\</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;ReturnType(ClassType::*)(Args...) __VA_ARGS__&gt; :</span> function_traits&lt;ReturnType(Args...)&gt;&#123;&#125;; \</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FUNCTION_TRAITS()</span></pre></td></tr><tr><td class="code"><pre><span class="line">FUNCTION_TRAITS(<span class="keyword">const</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">FUNCTION_TRAITS(<span class="keyword">volatile</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">FUNCTION_TRAITS(<span class="keyword">const</span> <span class="keyword">volatile</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//函数对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span> :</span> function_traits&lt;<span class="keyword">decltype</span>(&amp;Callable::<span class="keyword">operator</span>())&gt;&#123;&#125;;</span></pre></td></tr></table></figure>
<p>由于可调用对象可能是普通的函数、函数指针、lambda、std::function和成员函数，所以我们需要针对这些类型分别做偏特化，然后萃取出可调用对象的元信息。</p>
<p>其中，成员函数的偏特化稍微复杂一点，因为涉及到cv符的处理，这里通过定义一个宏来消除重复的模板类定义。参数类型的获取我们是借助于tuple，将参数转换为tuple类型，然后根据索引来获取对应类型。它的用法比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [](<span class="keyword">int</span> a)&#123;<span class="keyword">return</span> a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//打印函数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PrintType&lt;function_traits&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt;::function_type&gt;(); <span class="comment">//将输出int __cdecl(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//打印函数的第一个参数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PrintType&lt;function_traits&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt;::args&lt;<span class="number">0</span>&gt;::type&gt;();<span class="comment">//将输出int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//打印函数的返回类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PrintType&lt;function_traits&lt;<span class="keyword">decltype</span>(f)&gt;::return_type&gt;(); <span class="comment">//将输出int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="comment">//打印函数指针类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PrintType&lt;function_traits&lt;<span class="keyword">decltype</span>(f)&gt;::pointer&gt;(); <span class="comment">//将输出int (__cdecl*)(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>可以看到这个function_traits通过类型萃取，可以很方便地获取可调用对象（函数、函数指针、函数对象、std::function和lambda表达式）的一些元信息，功能非常强大，这个function_traits经常会用到是更高层模版元程序的基础。</p>
<p>比如Variant类型的实现就要用到这个function_traits，下面来看看Variant的实现。</p>
<h5 id="模版元实现vairant类型"><a class="markdownIt-Anchor" href="#模版元实现vairant类型"></a> 模版元实现Vairant类型</h5>
<p>借助上面的function_traits和前文实现的一些元函数，我们就能方便的实现一个“万能类型”—Variant，Variant实际上一个泛化的类型，这个Variant需要预定义一些类型作为可接受的类型。</p>
<p>通过C++11模版元实现的Variant将改进值的获取，将获取实际值的方式改为内置的，即通过下面的方式来访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">string</span>, <span class="keyword">int</span>&gt; cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv v = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v.Visit([&amp;](<span class="keyword">double</span> i)&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;, [](<span class="keyword">short</span> i)&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;, [=](<span class="keyword">int</span> i)&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;,[](<span class="keyword">const</span> <span class="built_in">string</span>&amp; i)&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;);<span class="comment">//结果将输出10</span></span></pre></td></tr></table></figure>
<p>Variant完整实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeindex&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 获取最大的整数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg, <span class="keyword">size_t</span>... rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>&lt;arg&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">size_t</span>, arg&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> arg1, <span class="keyword">size_t</span> arg2, <span class="keyword">size_t</span>... rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntegerMax</span>&lt;arg1, arg2, rest...&gt; :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">size_t</span>, arg1 &gt;= arg2 ? IntegerMax&lt;arg1, rest...&gt;::value </span></pre></td></tr><tr><td class="code"><pre><span class="line">    : IntegerMax&lt;arg2, rest...&gt;::value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 获取最大的align */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxAlign</span> :</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, IntegerMax&lt;<span class="built_in">std</span>::alignment_of&lt;Args&gt;::value...&gt;::value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** 是否包含某个类型 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... List&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>&lt;T, Head, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">	:</span> <span class="built_in">std</span>::conditional&lt;<span class="built_in">std</span>::is_same&lt;T, Head&gt;::value, <span class="built_in">std</span>::true_type, Contains&lt;T, Rest... &gt;&gt; ::type</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contains</span>&lt;T&gt; :</span> <span class="built_in">std</span>::false_type</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... List&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T, Head, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">enum</span> &#123; value = IndexOf&lt;T, Rest...&gt;::value + <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T, T, Rest...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">enum</span> &#123; value = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexOf</span>&lt;T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">enum</span>&#123;value = <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> index, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> index, <span class="keyword">typename</span> First, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>&lt;index, First, Types...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> type = <span class="keyword">typename</span> At&lt;index - <span class="number">1</span>, Types...&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">At</span>&lt;0, T, Types...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> type = T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variant</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">enum</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		data_size = IntegerMax&lt;<span class="keyword">sizeof</span>(Types)...&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		align_size = MaxAlign&lt;Types...&gt;::value</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> <span class="keyword">data_t</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::aligned_storage&lt;data_size, align_size&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">int</span> index&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> IndexType = <span class="keyword">typename</span> At&lt;index, Types...&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Variant(<span class="keyword">void</span>) :type_index_(<span class="keyword">typeid</span>(<span class="keyword">void</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	~Variant()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		destroy(type_index_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Variant(Variant&lt;Types...&gt;&amp;&amp; old) : type_index_(old.type_index_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		move(old.type_index_, &amp;old.data_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Variant(<span class="keyword">const</span> Variant&lt;Types...&gt;&amp; old) : type_index_(old.type_index_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		copy(old.type_index_, &amp;old.data_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Variant&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Variant&amp; old)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		copy(old.type_index_, &amp;old.data_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		type_index_ = old.type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Variant&amp; <span class="keyword">operator</span>=(Variant&amp;&amp; old)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		move(old.type_index_, &amp;old.data_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		type_index_ = old.type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">	<span class="title">class</span> = <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;Contains&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Variant(T&amp;&amp; value) : type_index_(<span class="keyword">typeid</span>(<span class="keyword">void</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			destroy(type_index_, &amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type U;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">new</span>(&amp;data_) U(<span class="built_in">std</span>::forward&lt;T&gt;(value));</span></pre></td></tr><tr><td class="code"><pre><span class="line">			type_index_ = <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(U));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> (type_index_ == <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(T)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> type_index_ == <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(<span class="keyword">void</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="function">type_index <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::<span class="function">type&amp; <span class="title">get</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">using</span> U = <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (!is&lt;U&gt;())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(U).name() &lt;&lt; <span class="string">" is not defined. "</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;&lt; <span class="string">"current type is "</span> &lt;&lt; type_index_.name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::bad_cast&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> *(U*)(&amp;data_);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> IndexOf&lt;T, Types...&gt;::value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Variant&amp; rhs) <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> type_index_ == rhs.type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Variant&amp; rhs) <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> type_index_ &lt; rhs.type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; index, <span class="keyword">void</span> *buf)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [](Types&amp;&amp;...)&#123;&#125;((destroy0&lt;Types&gt;(index, buf), <span class="number">0</span>)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy0</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; id, <span class="keyword">void</span> *data)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (id == <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(T)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(data)-&gt;~T();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; <span class="keyword">old_t</span>, <span class="keyword">void</span> *old_v, <span class="keyword">void</span> *new_v)</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [](Types&amp;&amp;...)&#123;&#125;((move0&lt;Types&gt;(<span class="keyword">old_t</span>, old_v, new_v), <span class="number">0</span>)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">move0</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; <span class="keyword">old_t</span>, <span class="keyword">void</span> *old_v, <span class="keyword">void</span> *new_v)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (<span class="keyword">old_t</span> == <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(T)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">new</span> (new_v)T(<span class="built_in">std</span>::move(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(old_v)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; <span class="keyword">old_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *old_v, <span class="keyword">void</span> *new_v)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [](Types&amp;&amp;...)&#123;&#125;((copy0&lt;Types&gt;(<span class="keyword">old_t</span>, old_v, new_v), <span class="number">0</span>)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">copy0</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::type_index&amp; <span class="keyword">old_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *old_v, <span class="keyword">void</span> *new_v)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (<span class="keyword">old_t</span> == <span class="built_in">std</span>::type_index(<span class="keyword">typeid</span>(T)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">new</span> (new_v)T(*<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(old_v));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">data_t</span> data_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::type_index type_index_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>实现Variant首先需要定义一个足够大的缓冲区用来存放不同的类型的值，这个缓类型冲区实际上就是用来擦除类型，不同的类型都通过placement new在这个缓冲区上创建对象，因为类型长度不同，所以需要考虑内存对齐，C++11刚好提供了内存对齐的缓冲区aligned_storage：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="built_in">std</span>::<span class="keyword">size_t</span> Len, <span class="built_in">std</span>::<span class="keyword">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct aligned_storage;</span></pre></td></tr></table></figure>
<p>它的第一个参数是缓冲区的长度，第二个参数是缓冲区内存对齐的大小，由于Varaint可以接受多种类型，所以我们需要获取最大的类型长度，保证缓冲区足够大，然后还要获取最大的内存对齐大小，这里我们通过前面实现的MaxInteger和MaxAlign就可以了，Varaint中内存对齐的缓冲区定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data_size &#x3D; IntegerMax&lt;sizeof(Types)...&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        align_size &#x3D; MaxAlign&lt;Types...&gt;::value</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using data_t &#x3D; typename std::aligned_storage&lt;data_size, align_size&gt;::type; &#x2F;&#x2F;内存对齐的缓冲区类型</span></pre></td></tr></table></figure>
<p>其次，我们还要实现对缓冲区的构造、拷贝、析构和移动，因为Variant重新赋值的时候需要将缓冲区中原来的类型析构掉，拷贝构造和移动构造时则需要拷贝和移动。这里以析构为例，我们需要根据当前的type_index来遍历Variant的所有类型，找到对应的类型然后调用该类型的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">const</span> type_index&amp; index, <span class="keyword">void</span> * buf)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123;(Destroy0&lt;Types&gt;(index, buf), <span class="number">0</span>)...&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy0</span><span class="params">(<span class="keyword">const</span> type_index&amp; id, <span class="keyword">void</span>* data)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (id == type_index(<span class="keyword">typeid</span>(T)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(data)-&gt;~T();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里，我们通过初始化列表和逗号表达式来展开可变模板参数，在展开的过程中查找对应的类型，如果找到了则析构。在Variant构造时还需要注意一个细节是，Variant不能接受没有预先定义的类型，所以在构造Variant时，需要限定类型必须在预定义的类型范围当中，这里通过type_traits的enable_if来限定模板参数的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">		<span class="title">class</span> = <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;Contains&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt; Variant(T&amp;&amp; value) : m_typeIndex(<span class="keyword">typeid</span>(<span class="keyword">void</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Destroy(m_typeIndex, &amp;m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type U;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span>(&amp;m_data) U(<span class="built_in">std</span>::forward&lt;T&gt;(value));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_typeIndex = type_index(<span class="keyword">typeid</span>(U));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<p>这里enbale_if的条件就是前面实现的元函数Contains的值，当没有在预定义的类型中找到对应的类型时，即Contains返回false时，编译期会报一个编译错误。</p>
<p>最后还需要实现内置的Vistit功能，Visit的实现需要先通过定义一系列的访问函数，然后再遍历这些函数，遍历过程中，判断函数的第一个参数类型的type_index是否与当前的type_index相同，如果相同则获取当前类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(F&amp;&amp; f)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> T = <span class="keyword">typename</span> Function_Traits&lt;F&gt;::<span class="keyword">template</span> arg&lt;<span class="number">0</span>&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (Is&lt;T&gt;())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		f(Get&lt;T&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Rest&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(F&amp;&amp; f, Rest&amp;&amp;... rest)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> T = <span class="keyword">typename</span> Function_Traits&lt;F&gt;::<span class="keyword">template</span> arg&lt;<span class="number">0</span>&gt;::type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (Is&lt;T&gt;())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Visit(<span class="built_in">std</span>::forward&lt;F&gt;(f));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Visit(<span class="built_in">std</span>::forward&lt;Rest&gt;(rest)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Visit功能的实现利用了可变模板参数和function_traits，通过可变模板参数来遍历一系列的访问函数，遍历过程中，通过function_traits来获取第一个参数的类型，和Variant当前的type_index相同时则取值。</p>
<p>为什么要获取访问函数第一个参数的类型呢？因为Variant的值是唯一的，只有一个值，所以获取的访问函数的第一个参数的类型就是Variant中存储的对象的实际类型。</p>
<h5 id="模版元实现bind"><a class="markdownIt-Anchor" href="#模版元实现bind"></a> 模版元实现bind</h5>
<p>C++11中新增的std::bind是一个很灵活且功能强大的绑定器，std::bind用来将可调用对象与其参数进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。<br>
下面是它的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(output, <span class="number">1</span>, <span class="number">2</span>)();                          <span class="comment">// 输出: 1 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(output, <span class="built_in">std</span>::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);     <span class="comment">// 输出: 1 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(output, <span class="number">2</span>, <span class="built_in">std</span>::placeholders::_1)(<span class="number">1</span>);     <span class="comment">// 输出: 2 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>std:: placeholders::_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。因为有了占位符的概念，std::bind的使用非常灵活，我们可以用它来替代任意位置的参数，延迟到后面再传入实际参数。bind的原理图:<br>
<img alt="bind figure" data-src="/assets/2019/12/09/bind_figure_1.png"></p>
<p>从上图中可以看到bind把参数和占位符保存起来了，然后在后面调用的时候再按照顺序去替换占位符，最终实现延迟执行。</p>
<p>我们可以通过模板元来实现一个简单的bind，实现bind需要解决两个问题：</p>
<ol>
<li>将tuple展开为可变模板参数<br>
bind绑定可调用对象时，需要将可调用对象的形参（可能含占位符）保存起来，保存到tuple中了。到了调用阶段，我们就要反过来将tuple展开为可变参数，因为这个可变参数才是可调用对象的形参，否则就无法实现调用了。这里我们会借助于一个整形序列来将tuple变为可变参数，在展开tuple的过程中我们还需要根据占位符来选择合适实参，即占位符要替换为调用实参。这里要用到前文中实现的MakeIndexes。</li>
<li>根据占位符来选择合适的实参<br>
这个地方比较关键，因为tuple中可能含有占位符，我们展开tuple时，如果发现某个元素类型为占位符，则从调用的实参生成的tuple中取出一个实参，用来作为变参的一个参数；当某个类型不为占位符时，则直接从绑定时生成的形参tuple中取出参数，用来作为变参的一个参数。最终tuple被展开为一个变参列表，这时，这个列表中没有占位符了，全是实参，就可以实现调用了。这里还有一个细节要注意，替换占位符的时候，如何从tuple中选择合适的参数呢，因为替换的时候要根据顺序来选择。这里是通过占位符的模板参数I来选择，因为占位符place_holder&lt;I&gt;的实例_1实际上place_holder&lt;1&gt;, 占位符实例_2实际上是palce_holder&lt;2&gt;,我们是可以根据占位符的模板参数来获取其顺序的。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>...&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexTuple</span>&#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span> :</span> MakeIndexes&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Indexes...&gt;&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... indexes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexes</span>&lt;0, indexes...&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> IndexTuple&lt;indexes...&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Placeholder</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Placeholder&lt;<span class="number">1</span>&gt; _1; Placeholder&lt;<span class="number">2</span>&gt; _2; Placeholder&lt;<span class="number">3</span>&gt; _3; Placeholder&lt;<span class="number">4</span>&gt; _4; Placeholder&lt;<span class="number">5</span>&gt; _5; </span></pre></td></tr><tr><td class="code"><pre><span class="line">Placeholder&lt;<span class="number">6</span>&gt; _6; Placeholder&lt;<span class="number">7</span>&gt; _7;Placeholder&lt;<span class="number">8</span>&gt; _8; Placeholder&lt;<span class="number">9</span>&gt; _9; Placeholder&lt;<span class="number">10</span>&gt; _10;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// result type traits</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_traits</span> :</span> result_traits&lt;<span class="keyword">decltype</span>(&amp;F::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_traits</span>&lt;T*&gt; :</span> result_traits&lt;T&gt; &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* check function */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_traits</span>&lt;R(*)(P...)&gt; &#123;</span> <span class="keyword">typedef</span> R type; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* check member function */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C, <span class="keyword">typename</span>... P&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_traits</span>&lt;R(C::*)(P...)&gt; &#123;</span> <span class="keyword">typedef</span> R type; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">inline</span> <span class="title">auto</span> <span class="title">select</span>(<span class="title">T</span>&amp;&amp; <span class="title">val</span>, <span class="title">Tuple</span>&amp;)-&gt;<span class="title">T</span>&amp;&amp;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I, <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">inline</span> <span class="title">auto</span> <span class="title">select</span>(<span class="title">Placeholder</span>&lt;I&gt;&amp;, <span class="title">Tuple</span>&amp; <span class="title">tp</span>) -&gt; <span class="title">decltype</span>(<span class="title">std</span>:</span>:get&lt;I - <span class="number">1</span>&gt;(tp))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;I - <span class="number">1</span>&gt;(tp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// The invoker for call a callable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_pointer_noref</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    :</span> <span class="built_in">std</span>::is_pointer&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_memfunc_noref</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    :</span> <span class="built_in">std</span>::is_member_function_pointer&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;is_pointer_noref&lt;F&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">R&gt;::<span class="function">type <span class="title">invoke</span><span class="params">(F&amp;&amp; f, P&amp;&amp;... par)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (*<span class="built_in">std</span>::forward&lt;F&gt;(f))(<span class="built_in">std</span>::forward&lt;P&gt;(par)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> P1, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;is_memfunc_noref&lt;F&gt;::value &amp;&amp; is_pointer_noref&lt;P1&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">R&gt;::<span class="function">type <span class="title">invoke</span><span class="params">(F&amp;&amp; f, P1&amp;&amp; this_ptr, P&amp;&amp;... par)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::forward&lt;P1&gt;(this_ptr)-&gt;*<span class="built_in">std</span>::forward&lt;F&gt;(f))(<span class="built_in">std</span>::forward&lt;P&gt;(par)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> P1, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;is_memfunc_noref&lt;F&gt;::value &amp;&amp; !is_pointer_noref&lt;P1&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">R&gt;::<span class="function">type <span class="title">invoke</span><span class="params">(F&amp;&amp; f, P1&amp;&amp; this_obj, P&amp;&amp;... par)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::forward&lt;P1&gt;(this_obj).*<span class="built_in">std</span>::forward&lt;F&gt;(f))(<span class="built_in">std</span>::forward&lt;P&gt;(par)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!is_pointer_noref&lt;F&gt;::value &amp;&amp; !is_memfunc_noref&lt;F&gt;::value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">R&gt;::<span class="function">type <span class="title">invoke</span><span class="params">(F&amp;&amp; f, P&amp;&amp;... par)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;F&gt;(f)(<span class="built_in">std</span>::forward&lt;P&gt;(par)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bind_t</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> decay&lt;Fun&gt;::type FunType;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::tuple&lt;<span class="keyword">typename</span> decay&lt;Args&gt;::type...&gt; ArgType;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> result_traits&lt;FunType&gt;::type     result_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">BArgs</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    <span class="title">Bind_t</span>(<span class="title">F</span>&amp; <span class="title">f</span>,  <span class="title">BArgs</span>&amp;... <span class="title">args</span>) :</span> m_func(f), m_args(args...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... BArgs&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Bind_t(F&amp;&amp; f, BArgs&amp;&amp;... par) : m_func(<span class="built_in">std</span>::move(f)), m_args(<span class="built_in">std</span>::move(par)...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... CArgs&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(CArgs&amp;&amp;... args)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> do_call(MakeIndexes&lt;<span class="built_in">std</span>::tuple_size&lt;ArgType&gt;::value&gt;::type(), </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_as_tuple(<span class="built_in">std</span>::forward&lt;CArgs&gt;(args)...));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ArgTuple, <span class="keyword">int</span>... Indexes &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">result_type <span class="title">do_call</span><span class="params">(IndexTuple&lt; Indexes... &gt;&amp; in, ArgTuple&amp; argtp)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> simple::invoke&lt;result_type&gt;(m_func, select(<span class="built_in">std</span>::get&lt;Indexes&gt;(m_args), </span></pre></td></tr><tr><td class="code"><pre><span class="line">argtp)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//return m_func(select(std::get&lt;Indexes&gt;(m_args), argtp)...);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FunType m_func;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ArgType m_args;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Bind_t&lt;F, P...&gt; Bind(F&amp;&amp; f, P&amp;&amp;... par)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Bind_t&lt;F, P...&gt;(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;P&gt;(par)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... P&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Bind_t&lt;F, P...&gt; Bind(F&amp; f, P&amp;... par)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Bind_t&lt;F, P...&gt;(f, par...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>由于只是展示bind实现的关键技术，很多的实现细节并没有处理，比如参数是否是引用、右值、cv符、绑定非静态的成员变量都还没处理，仅仅用来展示如何综合运用一些模版元技巧和元函数，并非是重复发明轮子，只是展示bind是如何实现, 实际项目中还是使用c++11的std::bind为好。</p>
<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h3>
<p>在管理动态分配的内存时，一个最棘手的问题就是决定何时释放这些内存，而智能指针就是用来简化内存管理的编程方式。智能指针一般有独占和共享两种所有权模型。</p>
<p>holder和trule两种智能指针类型：</p>
<ul>
<li>holder类型独占一个对象；</li>
<li>trule可以使对象的拥有者从一个holder传递给另一个holder。</li>
</ul>
<h4 id="holder"><a class="markdownIt-Anchor" href="#holder"></a> holder</h4>
<p>智能指针会在下面两种情况下释放所指向的对象：</p>
<ul>
<li>本身被释放</li>
<li>把另一个指针赋值给它</li>
</ul>
<p>下面我们模拟实现一个智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T* ptr;         <span class="comment">// 引用它所持有的对象（前提是该对象存在）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 缺省构造函数：让该holder引用一个空对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder() : ptr(<span class="number">0</span>) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 针对指针的构造函数：让该holder引用该指针所指向的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这里使用explicit，禁止隐式转型(也即禁止了使用赋值语法来初始化Holder对象，如“holderObj = originObj”形式的赋值语法)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 但依然可以通过对象构造的形式来给对象初始化，如"Holder holderObj(originObj)"，这里是显式转型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        explicit Holder (T* p) : ptr(p) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 析构函数：释放所引用的对象（前提是该对象存在）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ~Holder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 针对新指针的赋值运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder&lt;T&gt;&amp; <span class="keyword">operator</span>= (T* p)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 指针运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        T&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        T* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取所引用的对象（前提是该对象存在）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 释放对所引用对象的所有权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 与另一个holder交换所有权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">exchange_with</span><span class="params">(Holder&lt;T&gt;&amp; h)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            swap(ptr, h.ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 与其他的指针交换所有权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">exchange_twith</span><span class="params">(T*&amp; p)</span> </span>&#123;       <span class="comment">// 参数是什么语法？传入指针p的引用？</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            swap(ptr, p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不想外提供拷贝构造函数和拷贝赋值运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不允许一个Holder对象A赋值给另一个Holder对象B.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder(Holder&lt;T&gt; <span class="keyword">const</span>&amp;); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder&lt;T&gt;&amp; <span class="keyword">operator</span>= (Holder&lt;T&gt; <span class="keyword">const</span>&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>从语义上讲，该holder独占ptr所引用对象的所有权。而且，这个对象一定要用new操作来创建，因为在销毁holder所拥有对象的时候，需要用到delete。</p>
<p>release()成员函数释放holder对其持有对象的所有权。另外，上面的普通赋值运算符也设计得比较巧妙，它会销毁和释放任何被拥有的对象，因为另一个对象会替代原先的对象被holder所拥有，而且赋值运算符也不会返回原先对象的一个holder或指针（而是返回新对象的一个holder）。</p>
<p>最后，我们添加了两个exchange_with()成员函数，从而可以在不销毁原有对象的前提下，方便地替换该holder所拥有的对象。<br>
所以，我们可以如下使用上面的Holder创建两个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Holder&lt;Something&gt; first(<span class="keyword">new</span> Something);</span></pre></td></tr><tr><td class="code"><pre><span class="line">firsh-&gt;perform();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Holder&lt;Something&gt; second(<span class="keyword">new</span> Something);</span></pre></td></tr><tr><td class="code"><pre><span class="line">second-&gt;perform();</span></pre></td></tr></table></figure>
<h5 id="作为成员的holder"><a class="markdownIt-Anchor" href="#作为成员的holder"></a> 作为成员的holder</h5>
<p>我们也可以在类中使用holder来避免资源泄漏。要注意的是，只有那些完成构造之后的对象，它的析构函数才会被调用。因此，如果在构造函数内部产生异常，那么只有那些构造函数已正常执行完毕的成员对象，它的析构函数才会被调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"holder.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefMembers</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder&lt;MemType&gt; ptr1;       <span class="comment">// 所引用的成员</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder&lt;MemType&gt; ptr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 缺省构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// - 不可能出现资源泄漏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        RefMembers() : ptr1(<span class="keyword">new</span> MemType), ptr2(<span class="keyword">new</span> MemType) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 拷贝构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// - 不可能出现资源泄漏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        RefMembers (RefMembers <span class="keyword">const</span>&amp; x) : ptr1(<span class="keyword">new</span> MemType(*x.ptr1)), ptr2(<span class="keyword">new</span> MemType(*x.ptr2)) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 赋值运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">const</span> RefMembers&amp; <span class="keyword">operator</span>= (RefMembers <span class="keyword">const</span>&amp; x)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            *ptr1 = *x.ptr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            *ptr2 = *x.ptr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不需要析构函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// （缺省的析构函数将会让ptr1和ptr2删除它们所引用的对象）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>要注意的是，我们在这里可以省略用户定义的析构函数，但一定要编写拷贝构造函数和赋值运算符</p>
<blockquote>
<p>Holder所用到的基本思想是一种称为“资源获取即初始化”或RAII的模式</p>
</blockquote>
<h4 id="trule"><a class="markdownIt-Anchor" href="#trule"></a> trule</h4>
<p>为了解决holder在参数传递，返回值处理时的不足之处，以及复制holder、跨函数调用来复制holder所会产生的问题，引入trule。</p>
<blockquote>
<p><strong>trule</strong>: 一个专门用于传递holder的辅助类模板，并把它称为trule</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Holder</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trule</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T* ptr;        <span class="comment">// trule所引用的对象（如果有的话）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 构造函数，确保trule只能作为返回类型，用于将holder从被调用函数传递给调用函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 显式构造函数（会自动屏蔽默认无参构造函数），只能通过Holder构造Trule对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Trule (Holder&lt;T&gt;&amp; h)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = h.get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            h.release();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 拷贝构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// trule通常是作为那些想传递holders的函数的返回类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 也就是说trule对象总是作为临时对象（rvalues，右值）出现；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 因此它们的类型也就只能是常引用（reference-to-const）类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Trule (Trule&lt;T&gt; <span class="keyword">const</span>&amp; t)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = t.ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 由于Trule不能作为一份拷贝，也不能含有一份拷贝，如果希望实现类似于拷贝操作，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		    <span class="comment">// 就必须移除原trule的所有权。我们是通过将被封装指针置为空来实现这种移除操作的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 而最后这个置空操作显然只能针对non-const对象。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 所以才有了这种把const强制转型为non-const的做法。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 另外，由于原来的对象实际上并没有被定义为常类型，所以即使这样做有些别扭，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 但在这种情况下这种转型却能合法地实现。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 因此，对于最后需要把一个holder转换为trule，并且将其返回的函数，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 如果要声明这类函数的返回类型，我们就必须把它声明为trule&lt;T&gt;类型，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 而绝对不能声明为trule&lt;T&gt; const，这点需特别注意。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">　　　  <span class="comment">// 如下面例子中的函数load_something()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">const_cast</span>&lt;Trule&lt;T&gt;&amp;&gt;(t).ptr = <span class="number">0</span>;   <span class="comment">// 置空操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 析构函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ~Trule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对于trule的用法，除了作为传递holder对象的返回类型，我们要防止把它用于其他地方。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 一个接收non-const引用对象的拷贝构造函数和一个类似的拷贝赋值运算符，都被声明为私用函数，防止外界直接调用。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 通过禁止将trule作为左值的方法，因为左值允许取址和赋值操作，这种特性容易导致其用于其他地方而没有报错。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Trule(Trule&lt;T&gt;&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Trule&lt;T&gt;&amp; <span class="keyword">operator</span>= (Trule&lt;T&gt;&amp;);         <span class="comment">// 私有声明禁止拷贝赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;T&gt;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>需要注意的是，上面的代码并不完全是把一个holder完全转换为一个trule：如果是这样的话，holder就必须是一个可修改的左值。这也是我们为什么要使用一个单独的类型来实现trule，而不是将它的功能合并到holder类模板中的原因。</p>
<p>最后，对于上面实现的trule，只有被holder模板所辨识并且使用之后，才能算是完整的。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 前面已经定义的成员</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder(Trule&lt;T&gt; <span class="keyword">const</span>&amp; t)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = t.ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">const_cast</span>&lt;Trule&lt;T&gt;&amp;&gt;(t).ptr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Holder&lt;T&gt;&amp; <span class="keyword">operator</span>= (Trule&lt;T&gt; <span class="keyword">const</span>&amp; t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ptr = t.ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">const_cast</span>&lt;Trule&lt;T&gt;&amp;&gt;(t).ptr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>为了充分演示对holder/trule作了哪些改善，我们可以重写load_something()例子，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"holder2.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"trule.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_something</span><span class="params">(Something* x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 返回类型为Trule&lt;Something&gt;，通过将Holder&lt;Something&gt;转换成返回类型(也即，通过trule传递返回值)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Trule&lt;Something&gt; load_something()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Holder&lt;Something&gt; result(<span class="keyword">new</span> Something);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    read_something(result.get());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 接收load_something函数返回的Trule&lt;Something&gt;类型的值，并通过Holder内部接收Trule对象的构造函数初始化Holder对象ptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Holder&lt;Something&gt; ptr(load_something());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数</h4>
<p>设计一个引用计数的智能指针，基本思想是：对于每个被指向的对象，都保存一个计数，用于代表指向该对象的指针的个数，当计数值减少到0时，就删除此对象。</p>
<p>我们首先面对的问题是：计算器在什么地方？这里可以有两种方式，一种是把计算器放在对象中，但如果对象早期已经设计好，则无法再把计算器放入对象；另一种也是通常会使用的就是使用专用的（内存）分配器。</p>
<p>我们面对的第二个问题是：对象的析构和释放。我们有可能会需要使用非标准方式（比如C的free()，或者delete[]运算符释放对象数组）来释放对象，故而，我们还需要指定一种单独的对象（释放）policy。</p>
<p>对于大多数用CountingPtr计数的对象，我们可以使用下面这个简单的对象policy：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pointers/stdobjpolicy.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardObjectPolicy</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">(T* object)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> object;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// pointers/stdarraypolicy.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardArrayPolicy</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">(T* <span class="built_in">array</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在考虑了上面两个问题之后，我们现在开始定义我们的CountingPtr模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pointers/countingptr.hpp */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">typename</span> CounterPolicy	= SimpleReferenceCount,         <span class="comment">/* 计算器的policy */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">typename</span> ObjectPolicy		= StandardObjectPolicy&gt;         <span class="comment">/* 对象（释放）policy */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class CountingPrt : <span class="keyword">private</span> CounterPolicy, <span class="keyword">private</span> ObjectPolicy</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* typedef 两个简单的别名 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">typedef</span> CountPolicy	CP;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">typedef</span> ObjectPolicy	OP;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	T* object_pointer_to;         <span class="comment">/* 所引用的对象 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 如果没有引用任何对象，则为NULL */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 缺省构造函数（没有显式初始化，即没有加上explicit关键字） */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CountingPtr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;object_pointed_to = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 一个针对转型的构造函数（转型自一个内建的指针） */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">CountingPtr</span><span class="params">( T* p )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;init( p );        <span class="comment">/* 使用普通指针初始化 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 拷贝构造函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CountingPtr( CountingPtr&lt;T, CP, OP&gt; <span class="keyword">const</span> &amp; cp )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		: CP( (CP <span class="keyword">const</span> &amp;)cp ), <span class="comment">/* 拷贝policy */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		OP( (OP <span class="keyword">const</span> &amp;)cp )</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;attach( cp );     <span class="comment">/* 拷贝指针，并增加计数值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 析构函数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	~CountingPtr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;detach();         <span class="comment">/* 减少计数值，如果计数值为0，则释放该计数器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 针对内建指针的赋值运算符 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CountingPtr&lt;T, CP, OP&gt; &amp; <span class="keyword">operator</span>=( T* p )</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">/* 计数指针不能指向*p */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		assert( p != <span class="keyword">this</span>-&gt;object_pointed_to );</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;detach();         <span class="comment">/* 减少计数值，如果计数值为0，则释放该计数器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;init( p );        <span class="comment">/* 用一个普通指针进行初始化 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>(*<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 拷贝赋值运算符（要考虑自己给自己赋值） */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CountingPtr&lt;T, CP, OP&gt; &amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">operator</span>=( CountingPtr&lt;T, CP, OP&gt; <span class="keyword">const</span> &amp; cp )</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;object_pointed_to != cp.object_pointed_to )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">this</span>-&gt;detach();                         <span class="comment">/* 减少计数值，如果计数值为0，则释放该计数器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">			CP::<span class="keyword">operator</span>=( (CP <span class="keyword">const</span> &amp;)cp );        <span class="comment">/* 对policy进行赋值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			OP::<span class="keyword">operator</span>=( (OP <span class="keyword">const</span> &amp;)op );</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">this</span>-&gt;attach( cp );                     <span class="comment">/* 拷贝指针并增加计数值 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> ；</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 使之成为智能指针的运算符 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>(<span class="keyword">this</span>-&gt;object_pointed_to);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	T &amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>(*<span class="keyword">this</span>-&gt;object_pointed_to);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* 以后在这里将可能会增加一些其他的接口 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	....</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * - 用普通指针进行初始化（前提是普通指针存在）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">( T* p )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ( p != <span class="literal">NULL</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			CounterPolicy::init( p );</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;object_pointed_to = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* - 拷贝指针并且增加计数值（前提是指针存在） */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">( CountingPtr&lt;T, CP, OP&gt; <span class="keyword">const</span> &amp; cp )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>-&gt;object_pointed_to = cp.object_pointed_to;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ( cp.object_pointed_to != <span class="literal">NULL</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			CounterPolicy::increment( cp.object_pointed_to );</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/* - 减少计数值（如果计数值为0， 则释放计数器） */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">	</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;object_pointed_to != <span class="literal">NULL</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			CounterPolicy::decrement( <span class="keyword">this</span>-&gt;object_pointed_to );</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> ( CounterPolicy::is_zero( <span class="keyword">this</span>-&gt;object_pointed_to ) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">/* 如果有必要的话，释放计数器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				CounterPolicy::dispose( <span class="keyword">this</span>-&gt;object_pointed_to );</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">/* 使用object policy来释放所指向的对象 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				ObjectPolicy::dispose( <span class="keyword">this</span>-&gt;object_pointed_to );</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面代码需要注意：</p>
<ol>
<li>在拷贝赋值操作中，要判断是否为自赋值；</li>
<li>由于空指针并没有一个可关联的计数器，所以在减少计数值之前，必须先显式地检查空指针的情况；</li>
<li>在前面的代码中，我们使用继承来包含两种policy。这样做确保了在policy类为空的情况下，并不需要占用存储空间（前提是我们的编译器实现了空基类优化）</li>
</ol>
<h5 id="一个简单的非侵入式计数器"><a class="markdownIt-Anchor" href="#一个简单的非侵入式计数器"></a> 一个简单的非侵入式计数器</h5>
<p>从总体看来，我们已经完成了CountingPtr的设计，下面我们需要为计数policy编写代码。</p>
<p>于是，我们先来看一个针对计数器的policy，它并不把计数器存储于所指向对象的内部，也就是说，它是一种非侵入式的计数器policy（或者称为非插入式的计数器policy）。</p>
<p>对于计数器而言，最主要的问题是如何分配存储空间。事实上，同一个计数器需要被多个CountingPtr所共享；因此，它的生命周期必须持续到最后一个智能指针被释放之后。</p>
<p>通常而言，我们会使用一种特殊的分配器来完成这种任务，这种分配器专门用于分配大小固定的小对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pointers/simplerefcount.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt; // 用于size_t的定义</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleReferenceCount</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span>* counter;        <span class="comment">// 已经分配的计数器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SimpleReferenceCount()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            counter = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 缺省的拷贝构造函数和拷贝赋值运算符都是允许的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 因为它们只是拷贝这个共享的计数器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 分配计数器，并把它的值初始为1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(T*)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Counter = alloc_counter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            *counter = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 释放该计数器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">(T*)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dealloc_counter(counter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计数值加1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(T*)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++*counter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计数值减1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(T*)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            --*counter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 检查计数值是否为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">is_zero</span><span class="params">(T*)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *counter == <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="一个简单的侵入式计数器模板"><a class="markdownIt-Anchor" href="#一个简单的侵入式计数器模板"></a> 一个简单的侵入式计数器模板</h5>
<p>侵入式（或插入式）计数器policy就是将计数器放到被管理对象本身的类型中（或者可能存放到由被管理对象所控制的存储空间中）。显然，这种policy通常需要在设计对象类型的时候就加以考虑；因此这种方案很可能会专用于被管理对象的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pointers/memberrefcount.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ObjectT,        <span class="comment">// 包含计数器的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">typename</span> CountT,             <span class="comment">// 计数器的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            CountT Object::*CountP&gt;   <span class="comment">// 计数器的位置，在设计ObjectT对象的时候就考虑到计数器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberReferenceCount</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 缺省构造函数和析构函数都是允许的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 让计数器的值初始化为1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ObjectT* object)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            object-&gt;*CountP = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对于计数器的释放，并不需要显式执行任何操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">(ObjectT*)</span></span>&#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计数器加1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(ObjectT* object)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++object-&gt;*CountP;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计数器减1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(ObjectT* object)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            --object-&gt;*CountP;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 检查计数值是否为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">is_zero</span><span class="params">(ObjectT* object)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> object-&gt;*CounP == <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>如果使用这种policy的话，那么在类的实现中，就可以很快地写出类的引用计数指针类型。其中类的设计框架大概如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManagedType</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> ref_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> CountingPtr&lt;ManagedType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       MemberReferenceCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                      &lt;ManagedType,        <span class="comment">// 包含计数器的对象类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                        <span class="keyword">size_t</span>,                   <span class="comment">// 计数器类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                        &amp;ManagedType::ref_count&gt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>有了上面这个定义之后，我们就可以使用ManageeType::Ptr方便地引用“那些用于访问ManagedType对象的”引用计数指针类型（在此为智能指针类型CountingPtr）。<br>
<a href="#">C++ Template By David Vandevoorde</a>还介绍了关于智能指针的其他一些功能实现，包括常数性相关内容、隐式转型，以及比较等等，有兴趣自行查阅学习，这里不介绍</p>
<h3 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h3>
<h4 id="duo"><a class="markdownIt-Anchor" href="#duo"></a> duo</h4>
<p>自定义的duo的目的是把两个对象聚集到一个单一类型（类似标准库的std::pair）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//add2: 提供域类型的访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> T1 Type1;             <span class="comment">// 第1个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> T2 Type2;             <span class="comment">// 第2个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">enum</span> &#123; N = <span class="number">2</span> &#125;;                  <span class="comment">// 域的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// end add2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T1 v1;       <span class="comment">// 第1个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T2 v2;       <span class="comment">// 第2个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//add1: 并且给它添加两个构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Duo() : v1(), v2() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Duo(T1 <span class="keyword">const</span>&amp;a, T2 <span class="keyword">const</span>&amp; b) : v1(a), v2(b) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// end add1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;T1, T2&gt; make_duo(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Duo&lt;T1, T2&gt;(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于某些需要判断返回结果是否有效的函数而言会很有用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;<span class="keyword">bool</span>, X&gt; result = foo();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.v1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 结果是有效的，返回值是result.v2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和初始化Duo也非常简单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">make_duo(<span class="literal">true</span>, <span class="number">42</span>);</span></pre></td></tr></table></figure>
<p>上面实现的duo已经很接近std::pair了，但还有一些不同之处，如在构造函数中我们没有提供用于隐式类型转换的成员模板初始化函数；没有提供比较运算符等；基于这些区别，我们下面给出一个更强大清晰的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tuples/duo1.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DUO_HPP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUO_HPP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 提供域类型的访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T1 Type1;             <span class="comment">// 第1个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> T2 Type2;             <span class="comment">// 第2个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; N = <span class="number">2</span> &#125;;                    <span class="comment">// 域的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T1 value1;       <span class="comment">// 第1个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        T2 value2;       <span class="comment">// 第2个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 并且给它添加两个构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo() : value1(), value2() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo(T1 <span class="keyword">const</span>&amp;a, T2 <span class="keyword">const</span>&amp; b) : value1(a), value2(b) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 用于在构造期间，进行隐式的类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo(Duo&lt;U1, U2&gt; <span class="keyword">const</span>&amp; d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            : value1(d.v1()), value2(d.v2()) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 用于在赋值期间，进行隐式的类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo&lt;T1, T2&gt;&amp; <span class="keyword">operator</span>= (Duo&lt;U1, U2&gt; <span class="keyword">const</span>&amp; d)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value1 = d.value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value2 = d.value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 用于访问域的函数（域访问函数）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T1&amp; <span class="title">v1</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T1 <span class="keyword">const</span>&amp; <span class="title">v1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T2&amp; <span class="title">v2</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T2 <span class="keyword">const</span>&amp; <span class="title">v2</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 比较运算符（允许混合类型）：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Duo&lt;T1, T2&gt; <span class="keyword">const</span>&amp; d1, Duo&lt;U1, U2&gt; <span class="keyword">const</span>&amp; d2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> d1.v1() == d2.v1() &amp;&amp; d1.v2() == d2.v2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(Duo&lt;T1, T2&gt; <span class="keyword">const</span>&amp; d1, Duo&lt;U1, U2&gt; <span class="keyword">const</span>&amp; d2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> !(d1 == d2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对创建和初始化的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;T1, T2&gt; make_duo(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Duo&lt;T1, T2&gt;(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DUO_HPP</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// tuples/duo1.cpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"duo1.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;<span class="keyword">float</span>, <span class="keyword">int</span>&gt; foo()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Duo&lt;int, int&gt; 到返回类型Duo&lt;float, int&gt;的隐式转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> make_duo(<span class="number">42</span>, <span class="number">42</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Duo&lt;float, int&gt; 到返回类型Duo&lt;int, double&gt;的隐式转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (foo() == make_duo(<span class="number">42</span>, <span class="number">42.0</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="可递归duo"><a class="markdownIt-Anchor" href="#可递归duo"></a> 可递归duo</h4>
<ul>
<li>域的个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tuples/duo2.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duo</span>&lt;A, Duo&lt;B, C&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> A            T1;       <span class="comment">// 第1个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Duo&lt;B, C&gt;            T2;       <span class="comment">// 第2个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; N = Duo&lt;B, C&gt;::N + <span class="number">1</span> &#125;;            <span class="comment">// 域的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T1 value1;                <span class="comment">// 第1个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        T2 value2;                <span class="comment">// 第2个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 其他的公共成员都不需要改变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// tuples/duo6.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 相应的递归出口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duo</span>&lt;A, void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> A        T1;          <span class="comment">// 第1个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span>        T2;          <span class="comment">// 第2个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; N = <span class="number">1</span> &#125;;            <span class="comment">// 域的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T1 value1;                <span class="comment">// 第1个域的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo() : value1() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Duo(T1 <span class="keyword">const</span>&amp; a) : value1(a) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 域访问函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T1&amp; <span class="title">v1</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">T1 <span class="keyword">const</span>&amp; <span class="title">v1</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">v2</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">v2</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<ul>
<li>域的类型<br>
用于获取duo的第N个域的类型（即T）的基本模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）对于non-Duo（非duo）而言，结果类型为void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> ResultT;         <span class="comment">// 一般情况下，结构类型是void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// （2）对于非递归的duo，定义两个简单的局部特化，用于获取每个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对普通duo第1个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span>&lt;1, Duo&lt;A, B&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> A ResultT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对普通duo第2个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span>&lt;2, Duo&lt;A, B&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> B ResultT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// （3）可递归duo的第N个域的类型：一般情况下，它等于第2个域的第N-1个域的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo第N个域的类型的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span>&lt;N, Duo&lt;A, Duo&lt;B, C&gt; &gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> DuoT&lt;N<span class="number">-1</span>, Duo&lt;B, C&gt; &gt;::ResultT ResultT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// （4）另外，针对可递归duo第1个（域的）类型的特化如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo第1个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span>&lt;1, Duo&lt;A, Duo&lt;B, C&gt; &gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> A ResultT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo第2个（域的）类型的特化如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo第2个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoT</span>&lt;2, Duo&lt;A, Duo&lt;B, C&gt; &gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> B ResultT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<ul>
<li>域的值<br>
在一个可递归duo中，就操作而言，抽取第N个值与抽取第N个类型是类似的，只是抽取第N个值要稍微复杂一些。为了能够抽取第N个值，我们需要实现一个形为val<n>(duo)的接口。但是在实现该接口的过程中，我们需要先实现一个辅助类模板DuoValue，因为只有类模板才能够被局部特化（函数模板现在还不可以），而局部特化能够帮助我们高效地抽取第N个值。如下：</n></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeop.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 返回变量duo的第N个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> TypeOp&lt;<span class="keyword">typename</span> DuoT&lt;N, Duo&lt;A, B&gt; &gt;::ResultT&gt;::RefT</span></pre></td></tr><tr><td class="code"><pre><span class="line">val(Duo&lt;A, B&gt;&amp; d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DuoValue&lt;N, Duo&lt;A, B&gt; &gt;::get(d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 返回常量duo的第N个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> TypeOp&lt;<span class="keyword">typename</span> DuoT&lt;N, Duo&lt;A, B&gt; &gt;::ResultT&gt;::RefConstT</span></pre></td></tr><tr><td class="code"><pre><span class="line">val(Duo&lt;A, B&gt; <span class="keyword">const</span>&amp; d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DuoValue&lt;N, Duo&lt;A, B&gt; &gt;::get(d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>下面是DuoValue的一个完整实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeop.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基本模板，针对（duo）T的第N个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoValue</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(T&amp;)</span> </span>&#123; &#125;        <span class="comment">// 一般情况下，并不返回值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(T <span class="keyword">const</span>&amp;)</span> </span>&#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对普通duo的第N个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoValue</span>&lt;1, Duo&lt;A, B&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> A&amp; <span class="title">get</span><span class="params">(Duo&lt;A, B&gt; &amp; d)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> d.v1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> A <span class="keyword">const</span>&amp; <span class="title">get</span><span class="params">(Duo&lt;A, B&gt; <span class="keyword">const</span>&amp;)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> d.v1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对普通duo第2个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoValue</span>&lt;2, Duo&lt;A, B&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> B&amp; <span class="title">get</span><span class="params">(Duo&lt;A, B&gt; &amp;d)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> d.v2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> B <span class="keyword">const</span>&amp; <span class="title">get</span><span class="params">(Duo&lt;A, B&gt; <span class="keyword">const</span> &amp;d)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> d.v2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo的第N个值的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuoValue</span>&lt;N, Duo&lt;A, Duo&lt;B, C&gt; &gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typename</span> TypeOp&lt;<span class="keyword">typename</span> DuoT&lt;N<span class="number">-1</span>, Duo&lt;B, C&gt; &gt;::ResultT&gt;::RefT</span></pre></td></tr><tr><td class="code"><pre><span class="line">    get(Duo&lt;A, Duo&lt;B, C&gt; &gt; &amp;d)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> DuoValue&lt;N<span class="number">-1</span>, Duo&lt;B, C&gt; &gt;::get(d.v2());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">typename</span> TypeOp&lt;<span class="keyword">typename</span> DuoT&lt;N<span class="number">-1</span>, Duo&lt;B, C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    &gt;::ResultT&gt;::RefConstT</span></pre></td></tr><tr><td class="code"><pre><span class="line">    get(Duo&lt;A, Duo&lt;B, C&gt; &gt; <span class="keyword">const</span> &amp;d)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> DuoValue&lt;N<span class="number">-1</span>, Duo&lt;B, C&gt; &gt;::get(d.v2());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对可递归duo的第1个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoValue</span>&lt;1, Duo&lt;A, Duo&lt;B, C&gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    public:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        static A&amp; get(Duo&lt;A, Duo&lt;B, C&gt; &gt; &amp;d)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">            return d.v1();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        static A const&amp; get(Duo&lt;A, Duo&lt;B, C&gt; &gt; const &amp;d)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">            return d.v1();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">// 针对可递归duo的第2个域的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">template &lt;typename A, typename B, typename C&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">class DuoValue&lt;2, Duo&lt;A, Duo&lt;B, C&gt; &gt; &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    public:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        static B&amp; get(Duo&lt;A, Duo&lt;B, C&gt; &gt; &amp;d)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">            return d.v2().v1();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        static B const&amp; get(Duo&lt;A, Duo&lt;B, C&gt; &gt; const &amp;d)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">            return d.v2().v1();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#125;;</span></span></pre></td></tr></table></figure>
<p>下面程序给出如何使用上面的duo：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用一个简单的duo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.v1() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">1</span>&gt;(d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用triple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Duo&lt;<span class="keyword">bool</span>, Duo&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; &gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">1</span>&gt;(t) = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">2</span>&gt;(t) = <span class="number">42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">3</span>&gt;(t) = <span class="number">0.2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>例如,调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">val&lt;<span class="number">3</span>&gt;(t)</span></pre></td></tr></table></figure>
<p>最后将会扩展为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t.v2().v2()</span></pre></td></tr></table></figure>
<h4 id="tuple构造"><a class="markdownIt-Anchor" href="#tuple构造"></a> tuple构造</h4>
<p>上一节我们了解到可递归duo的嵌套结构有助于展现metaprogramming技术的应用，现在我们为把该结构封装成一个简单接口，从而可以在日常工作中使用这种结构。为了实现这种接口，我们可以定义一个含有多个参数的可递归tuple模板，并让它派生自一个可递归duo类型，其中该duo类型的域个数是有限制的（假设最多5个域）。</p>
<p>为了使tuple的大小（即域个数）是可变的，我们声明了一些无用的类型参数，它们缺省值是一个null类型；在此，我们特地定义了一个NullT类型，用于代表这种null类型。之所以使用NullT，而不使用void，是因为我们需要创建该类型（即NullT）的参数，而void是不能作为参数类型的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于代表无用类型参数的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>接下来，我们把tuple定义为一个模板，它派生自duo，而且该duo至少具有一个定义为NullT的类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般情况下，Tuple&lt;&gt;都创建自“至少含有一个NullT的另一个Tuple&lt;&gt;”</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> P2 = NullT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> P3 = NullT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> P4 = NullT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typename</span> P5 = NullT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Tuple</span></pre></td></tr><tr><td class="code"><pre><span class="line">    : <span class="keyword">public</span> Duo&lt;P1, <span class="keyword">typename</span> Tuple&lt;P2, P3, P4, P5, NullT&gt;::BaseT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Duo&lt;P1, <span class="keyword">typename</span> Tuple&lt;P2, P3, P4, P5, NullT&gt;::BaseT&gt; BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple(TypeOp&lt;P1&gt;::RefConstT a1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;P2&gt;::RefConstT a2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;P3&gt;::RefConstT a3 = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;P4&gt;::RefConstT a4 = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;P5&gt;::RefConstT a5 = NullT())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            : BaseT(a1, Tuple&lt;P2, P3, P4, P5, NullT&gt;(a2, a3, a4, a5))&#123;   <span class="comment">// 递归减少参数个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于终止递归的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Tuple&lt;P1, P2, NullT, NullT, NullT&gt; : <span class="keyword">public</span> Duo&lt;P1, P2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Duo&lt;P1, P2&gt; BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple(TypeOp&lt;P1&gt;::RefConstT a1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;P2&gt;::RefConstT a2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            : BaseT(a1, a2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>于是，有一个如下的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">double</span>&gt; t4(<span class="literal">true</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">1.95583</span>);</span></pre></td></tr></table></figure>
<p>而其他的特化将会考虑tuple是一个singleton（即只具有一个域）的情形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对singletons的特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;P1, NullT, NullT, NullT, NullT&gt; :</span> <span class="keyword">public</span> Duo&lt;P1, <span class="keyword">void</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Duo&lt;P1, <span class="keyword">void</span>&gt; BaseT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Tuple(TypeOp&lt;P1&gt;::RefConstT a1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Tuple(TypeOp&lt;NullT&gt;::RefConstT = NullT())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            : BaseT(a1)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>最后，我们定义类似make_duo()的辅助函数，对每种不同大小的tuple，都需要声明一个不同的函数模板make_duo()，因为函数模板不能含有缺省模板实参，而且在模板参数的演绎过程中，也不会考虑缺省的函数调用实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对一个实参的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;T1&gt; make_duo(T1 <span class="keyword">const</span>&amp; a1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Tuple&lt;T1&gt;(a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对两个实参的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;T1, T2&gt; make_duo(T1 <span class="keyword">const</span>&amp; a1, T2 <span class="keyword">const</span>&amp; a2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Tuple&lt;T1, T2&gt;(a1, a2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对3个实参的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;T1, T2, T3&gt; make_duo(T1 <span class="keyword">const</span>&amp; a1, T2 <span class="keyword">const</span>&amp; a2, T3 <span class="keyword">const</span>&amp; a3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Tuple&lt;T1, T2, T3&gt;(a1, a2, a3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对4个实参的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;T1, T2, T3, T4&gt; make_duo(T1 <span class="keyword">const</span>&amp; a1, T2 <span class="keyword">const</span>&amp; a2, T3 <span class="keyword">const</span>&amp; a3, T4 <span class="keyword">const</span>&amp; a4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Tuple&lt;T1, T2, T3, T4&gt;(a1, a2, a3, a4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 针对5个实参的辅助函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;T1, T2, T3, T4, T5&gt; make_duo(T1 <span class="keyword">const</span>&amp; a1, T2 <span class="keyword">const</span>&amp; a2, T3 <span class="keyword">const</span>&amp; a3, T4 <span class="keyword">const</span>&amp; a4, T5 <span class="keyword">const</span>&amp; a5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Tuple&lt;T1, T2, T3, T4, T5&gt;(a1, a2, a3, a4, a5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如何使用该tuple：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用只具有1个域的tuple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;<span class="keyword">int</span>&gt; t1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">1</span>&gt;(t1) += <span class="number">42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t1.v1() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用duo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; <span class="number">42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">1</span>&gt;(t2) &lt;&lt; <span class="string">", "</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t2.v1() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用triple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt; t3;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">1</span>&gt;(t3) = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">2</span>&gt;(t3) = <span class="number">42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">val&lt;<span class="number">3</span>&gt;(t3) = <span class="number">0.2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">1</span>&gt;(t3) &lt;&lt; <span class="string">", "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">2</span>&gt;(t3) &lt;&lt; <span class="string">", "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">3</span>&gt;(t3) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">t3 = make_tuple(<span class="literal">false</span>, <span class="number">23</span>, <span class="number">13.13</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">1</span>&gt;(t3) &lt;&lt; <span class="string">", "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">2</span>&gt;(t3) &lt;&lt; <span class="string">", "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">3</span>&gt;(t3) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和使用quadruple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">double</span>&gt; t4(<span class="literal">true</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">1.95583</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;<span class="number">4</span>&gt;(t4) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t4.v2().v2().v2() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<h3 id="函数对象和回调"><a class="markdownIt-Anchor" href="#函数对象和回调"></a> 函数对象和回调</h3>
<p>函数对象（也称为__仿函数__）是指：可以使用函数调用语法进行调用的任何对象。</p>
<p>在C程序设计语言中，有3种类似于函数调用语法的实体：函数、类似于函数的宏和函数指针。由于函数和宏实际上并不是对象，因此在C语言中，我们只把函数指针看成仿函数。</p>
<p>然而在C++中，还存在其他的函数对象：对于class类型，我们可以重载函数调用运算符；还存在函数引用的概念；另外，成员函数和成员函数指针也都有自身的调用语法。</p>
<p>本节在于把仿函数的概念和模板所提供的编译期参数化机制结合起来以提供更加强大的程序设计技术。</p>
<p>仿函数的习惯用法几乎都是使用某种形式的回调，而回调的含义是这样的：对于一个程序库，它的客户端希望该程序库能够调用客户端自定义的某些函数，我们就把这种调用称为回调。</p>
<h4 id="直接调用-间接调用和内联调用"><a class="markdownIt-Anchor" href="#直接调用-间接调用和内联调用"></a> 直接调用、间接调用和内联调用</h4>
<p>在阐述如何使用模板来实现有用的仿函数之前，我们先讨论函数调用的一些属性，也正是这些属性的差异，才真正体现出基于模板的仿函数的优点。</p>
<p>使用内联的优点：在一个调用系列中，不但能够避免执行这些（查找名称的）机器代码；而且能够让优化器看到函数对传递进来的变量进行了哪些操作。</p>
<p>实际上，我们在后面将会看到，如果我们使用基于模板的回调来生成机器码的话，那么这些机器码将主要涉及到直接调用和内联调用；而如果用传统的回调的话，那么将会导致间接调用。使用模板的回调将会大大节省程序的运行时间。</p>
<h4 id="函数指针与函数引用"><a class="markdownIt-Anchor" href="#函数指针与函数引用"></a> 函数指针与函数引用</h4>
<p>考虑函数foo()定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>该函数的类型为：具有C<ins>链接的函数，不接受参数，不返回值并且不抛出异常。由于历史原因，在C</ins>语言的正式定义中，并没有把异常规范并入函数类型的一部分。然而，将来的标准将会把异常加入函数类型中。<br>
实际上，当你自己编写的代码要和某个函数进行匹配时，通常也应该要求异常规范同时也是匹配的。名字链接（通常只存在于C和C<ins>中）是类型系统的一部分，但某些C</ins>编译器将会自动添加这种链接。特别地，这些编译器允许具有C链接的函数指针和具有C<ins>链接的函数指针相互赋值。这同时带来下面的一个事实： 在大多数平台上，C和C</ins>函数的调用规范几乎是一样的，唯一的区别在于：C++将会考虑参数的类型和返回值的类型。</p>
<p>在大多数上下文中，表达式foo能够转型为指向函数foo()的指针。即使foo本身并没有指针的含义，但是就如表达式ia一样，在声明了下面的语句之后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];</span></pre></td></tr></table></figure>
<p>ia将隐含地表示一个数组指针（或者是一个指向数组第1个元素的指针）。于是，这种从函数（或者数组）到指针的转型通常也被称为decay。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functors/funcptr.cpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">FooT</span><span class="params">()</span></span>;        <span class="comment">// FooT是一个函数类型，与函数foo()具有相同的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo();     <span class="comment">// 直接调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出foo和FooT的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Types of foo: "</span> &lt;&lt; <span class="keyword">typeid</span>(foo).name() &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Types of FooT: "</span> &lt;&lt; <span class="keyword">typeid</span>(FooT).name() &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FooT* pf = foo;            <span class="comment">// 隐式转型（decay）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pf();            <span class="comment">// 通过指针的间接调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*pf)();            <span class="comment">// 等价于pf()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 打印出pf的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Types of pf : "</span> &lt;&lt; typeif(pf).name() &lt;&lt; <span class="string">'\n'</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FooT&amp; rf = foo;            <span class="comment">// 没有隐式转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    rf();            <span class="comment">// 通过引用的间接调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出rf的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Types of rf : "</span> &lt;&lt; <span class="keyword">typeid</span>(rf).name() &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo() called</span></pre></td></tr><tr><td class="code"><pre><span class="line">Types of foo: <span class="keyword">void</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">Types of FooT: <span class="keyword">void</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo() called</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo() called</span></pre></td></tr><tr><td class="code"><pre><span class="line">Types of pf: FooT *    <span class="comment">// 输出类型不是void(*)而是FooT*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">foo() called</span></pre></td></tr><tr><td class="code"><pre><span class="line">Types of rf: <span class="keyword">void</span> ()</span></pre></td></tr></table></figure>
<p>该例子同时也说明了：作为语言的一个概念，函数引用（或者称为指向函数的引用）是存在的；但是我们通常都是使用函数指针（而且为了避免产生混淆，最后还是继续使用函数指针）。另外，表达式foo实际上是一个左值，因为它可以被绑定到一个non-const类型的引用；然而，我们却不能修改这个左值。</p>
<p>我们另外还发现：在函数调用中，可以使用函数指针的名称（如pf）或者函数引用的名称（如rf）来进行函数调用，就像所有函数名称本身一样。</p>
<p>因此，可以认为一个函数指针本身就是一个仿函数——一个在函数调用语法中可以用于代替函数名称的对象。另一方面，由于引用并不是一个对象，所有函数引用并不是仿函数。最后，如果基于我们前面所讨论的直接调用和间接调用来看，那么这些看起来相同的符号却很可能会有很大的性能差距。</p>
<h4 id="成员函数指针"><a class="markdownIt-Anchor" href="#成员函数指针"></a> 成员函数指针</h4>
<p>典型的C++实现（也即编译器）是如何处理成员函数调用的？首先考虑下面的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> b1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> B1::mf1()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 = "</span> &lt;&lt; b1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//--------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> b2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> B2::mf2()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 = "</span> &lt;&lt; b2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//--------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>对成员函数mf1或mf2调用语法p-&gt;mf_x()，p会是一个指向对象或子对象的指针，以某种隐藏参数的形式传递给mf_x，大多是作为this指针的形式传递。</p>
<p>有了上面这个定义之后，D类型对象不但具有B1类型对象的行为，同时也具有B2类型对象的行为。为了实现D类型对象的这种特性，一个D对象就需要既包含一个B1对象，也包含一个B2对象。</p>
<p>在我们今天所指定的几乎所有的32位编译器中，如果int成员占用4个字节的话，那么成员b1的地址为this的地址，成员b2的地址为this地址再加上4个字节，而成员d的地址为this地址加上8个字节。B1和B2最大的区别在于：B1的子对象（即b1）与D的子对象共享起始地址（即this地址），而B2的子对象（即b2）则没有。</p>
<p>现在，考虑使用成员函数指针进行函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_memfun</span> <span class="params">(D obj, <span class="keyword">void</span>(D::*pmf) () )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (obj.*pmf) ();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    D obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    call_memfun(obj, &amp;D::mf1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    call_memfun(obj, &amp;D::mf2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>从上面调用代码我们得出一个结论：对于某些成员函数指针，除了需要指定函数的地址之外，还需要知道基于this指针的地址调整。如果在考虑到虚函数的时候又会有其他的许多不同。编译器通常使用3-值结构：</p>
<ol>
<li>成员函数的地址，如果是一个虚函数的话，那么该值为NULL；</li>
<li>基于this的地址调整；</li>
<li>一个虚函数索引。</li>
</ol>
<p><strong>成员变量指针实际上并不是一个真正意义上的指针，而是一些基于this指针的偏移量，然后根据this指针和对应的偏移量，才能获取给定的域（即成员变量的值，对于值域而言，在内存中可以表示为一块固有的存储空间）。</strong></p>
<p>对于通过成员函数指针访问成员函数的操作，实际上是一个2元操作，因为它不仅仅需要知道对应的成员函数指针（即下面的pmf），还需要知道包含该成员函数的对象（即下面的obj）。于是，在语言中引入特殊的成员指针取引用运算符.<em>和-&gt;</em>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(obj.*pmf)(...)            <span class="comment">// 调用位于obj中的、pmf所引用的成员函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(ptr-&gt;*pmf)(...)            <span class="comment">// 调用位于ptr所引用对象中的、pmf所引用的成员函数</span></span></pre></td></tr></table></figure>
<p>相对而言，通过指针访问一个普通函数就是一个一元操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*ptr)()</span></pre></td></tr></table></figure>
<p>从前面我们知道，上面这个解引用运算符可以省略不写，因为在函数调用运算符中，解引用运算符是隐式存在的。因此，前面的表达式通常可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptr()</span></pre></td></tr></table></figure>
<p>但是对于__函数指针而言，却不存在这种隐式（存在）的形式__。</p>
<blockquote>
<p>对于成员函数名称而言，同样不存在隐式的decay，例如MyType::print不能隐式decay为对应的指针形式（即&amp;MyType::print），其中这个&amp;号是必须写的，并不能省略。然而对于普通函数而言，把f隐式decay为&amp;f是很常见的，也是众所周知的。</p>
</blockquote>
<h4 id="class类型的仿函数"><a class="markdownIt-Anchor" href="#class类型的仿函数"></a> class类型的仿函数</h4>
<p>在C++语言中，虽然函数指针直接就是现成的仿函数；然而，在很多情况下，如果使用重载了函数调用运算符的class类型对象的话，可以给我们带来很多好处：譬如灵活性、性能，甚至二者兼备。<br>
下面是class类型仿函数的一个简单例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 含有返回常值的函数对象的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstantIntFunctor</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value;    <span class="comment">// “函数调用”所返回的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 构造函数：初始化返回值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConstantIntFunctor (<span class="keyword">int</span> c) : value(c) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// “函数调用”</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用上面“函数对象”的客户端函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client</span> <span class="params">(ConstantIntFunctor <span class="keyword">const</span>&amp; cif)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling back functor yields "</span> &lt;&lt; cif() &lt;&lt; <span class="string">'\n'</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">ConstantIntFunctor <span class="title">seven</span><span class="params">(<span class="number">7</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">ConstantIntFunctor <span class="title">fortytwo</span><span class="params">(<span class="number">42</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    client(seven);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    client(fortytwo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>ConstantIntFunctor是一个class类型，而它的仿函数就是根据该类型创建出来的。也就是说，如果你使用下面语句生成一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ConstantIntFunctor <span class="title">seven</span><span class="params">(<span class="number">7</span>)</span></span>;        <span class="comment">// 生成一个名叫seven的函数对象</span></span></pre></td></tr></table></figure>
<p>那么表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">seven();            <span class="comment">// 调用函数对象的operator()</span></span></pre></td></tr></table></figure>
<p>就是调用对象seven的operator()，而不是调用函数seven()。实际上，我们传递函数对象seven和fortytwo给client()的参数cif，（间接地）获得了和传递函数指针完全一样的效果。</p>
<p>该例如同时也说明了：在实际应用中，class类型仿函数的优点所在（与函数指针相比）：能够在函数中关联某些状态（也即成员变量），这可能也是class类型仿函数最重要的优点。而对于回调机制而言，这种优点能够带来功能上的提升。因为对于一个函数而言，我们现在能够根据不同的参数（主要指成员变量）来生成不同的函数实例（如前面的seven和fortytwo）。</p>
<h4 id="class类型仿函数的类型"><a class="markdownIt-Anchor" href="#class类型仿函数的类型"></a> class类型仿函数的类型</h4>
<p>与函数指针相比，class类型仿函数除了具有状态信息之外，还具有其他的特性。实际上，如果一个class类型仿函数并没有包含任何状态的话，那么它的行为完全是由它的类型所决定的。于是，我们可以以模板实参的形式来传递该类型，用于自定义程序库组件的行为。</p>
<p>对于上面的这种实现，一个经典的例子是：以某种顺序对它的元素进行排序的容器类，其中排序规则就是一个模板实参。另外，由于排序规则是容器类型的一部分，所以如果对某个特定容器混合使用多种不同的排序规则（例如在赋值运算符中，两个容器使用不同的排序规则，就不能相互赋值），类型系统通常都会给出错误。</p>
<h4 id="作为模板类型实参的仿函数"><a class="markdownIt-Anchor" href="#作为模板类型实参的仿函数"></a> 作为模板类型实参的仿函数</h4>
<p>传递仿函数的一个方法是让它的类型作为一个模板实参。然而类型本身并不是一个仿函数，因此客户端函数或者客户端类必须创建一个给定类型的仿函数对象。当然，只有class类型仿函数才能这么做，函数指针则不可以；而且函数指针本身也不会指定任何行为。另外，也不存在一种能够传递包含状态的类型的机制（因为类型本身并不包含任何特定的状态，只有对象才可能具有某些特定的状态，所以在此真正要传递的是一个特定的对象）。</p>
<p>下面是函数模板的一个雏形，它接收一个class类型的仿函数作为排序规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FO&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_sort</span><span class="params">(... )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FO cmp;        <span class="comment">// 创建函数对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cmp(x, y))        <span class="comment">// 使用函数对象来比较2个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 以仿函数为模板实参，来调用函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my_sort&lt;<span class="built_in">std</span>::less&lt;... &gt; &gt; (... );</span></pre></td></tr></table></figure>
<p>运用上面这个方法，比较代码（如std::less&lt;&gt;）的选择将会是在编译期进行的。并且由于比较操作是内联的，所以一个优化的编译器将能够产生本质上等价于不使用仿函数，而直接编写的代码。</p>
<h4 id="作为函数调用实参的仿函数"><a class="markdownIt-Anchor" href="#作为函数调用实参的仿函数"></a> 作为函数调用实参的仿函数</h4>
<p>另一种传递仿函数的方法是以函数调用实参的形式进行传递。这就允许调用者在运行期构造函数对象（可能使用一个非虚拟的构造函数）</p>
<p>就作用而言，函数调用实参和函数类型参数本质上是类似的，唯一的区别在于：当传递参数的时候，函数调用实参需要拷贝一个仿函数对象。这种拷贝开销通常是很低的，而且实际上如果该仿函数对象没有成员变量的话（而实际情况也经常如此），那么这种拷贝开销也将接近于0。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_sort</span><span class="params">(... , F cmp)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cmp(x, y))        <span class="comment">// 使用函数对象，来比较两个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 以仿函数作为调用实参，调用排序函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my_sort(... , <span class="built_in">std</span>::less&lt;... &gt;());</span></pre></td></tr></table></figure>
<h4 id="结合函数调用参数和模板类型参数"><a class="markdownIt-Anchor" href="#结合函数调用参数和模板类型参数"></a> 结合函数调用参数和模板类型参数</h4>
<p>对于前面两种传递仿函数的方式——即传递函数指针和class类型的仿函数，只要通过定义缺省函数调用实参，是完全可以把这两种方式结合起来的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_sort</span><span class="params">(... , F cmp = F() )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cmp(x, y))        <span class="comment">// 使用函数对象来比较两个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_criterion</span><span class="params">()</span> <span class="params">(T <span class="keyword">const</span>&amp; x, T <span class="keyword">const</span>&amp; y)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 借助于模板实参传递进来的仿函数，来调用排序函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my_sort&lt;<span class="built_in">std</span>::less&lt;... &gt; &gt; (... );</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 借助于值实参（即函数实参）传递进来的仿函数，来定义排序函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my_sort(... , <span class="built_in">std</span>::less&lt;... &gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 借助于值实参（即函数实参）传递进来的仿函数，来定义排序函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my_sort(... , my_criterion);</span></pre></td></tr></table></figure>
<h4 id="作为非类型模板实参的仿函数"><a class="markdownIt-Anchor" href="#作为非类型模板实参的仿函数"></a> 作为非类型模板实参的仿函数</h4>
<p>我们同样也可以通过非类型模板实参的形式来提供仿函数。然而，class类型的仿函数（更普遍而言，应该称为class类型的对象）将不能作为一个有效的非类型模板实参。如下面的代码就是无效的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCriterion</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(SomeType <span class="keyword">const</span>&amp;, SomeType <span class="keyword">const</span>&amp;)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;MyCriterion F&gt;        <span class="comment">// ERROR:MyCriterion 是一个class类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_sort</span><span class="params">(... )</span></span>;</span></pre></td></tr></table></figure>
<p>然而，我们可以让一个指向class类型对象的指针或者引用作为非类型实参，这也启发了我们编写出下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCriterion</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(SomeType <span class="keyword">const</span>&amp;, SomeType <span class="keyword">const</span>&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span> :</span> <span class="keyword">public</span> MyCriterion</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(SomeType <span class="keyword">const</span>&amp;, SomeType <span class="keyword">const</span>&amp;)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;MyCriterion&amp; F&gt;        <span class="comment">// class类型对象的指针或引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(... )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">LessThan order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">sort&lt;order&gt; (... );        <span class="comment">// 错误：要求派生类到基类的转型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sort&lt;(MyCriterion&amp;)order&gt;(... );        <span class="comment">// 非类型模板实参所引用的必须是一个简单的名称（不能含有转型）</span></span></pre></td></tr></table></figure>
<p>在上面这个例子中，我们的目的是为了在抽象基类中描述这种排序规则的接口，并且在非类型模板实参中使用该抽象类型。就我们的想法而言，我们是为了能够在派生类（如LessThan）中来特定地实现基类的这种接口（MyCriterion）。遗憾的是，C<ins>并不允许这种实现方法，在C</ins>中，借助于引用或者指针的非类型实参必须能够和参数类型精确匹配，从派生类到基类的转型是不允许的，而进行显式类型转换也会使实参无效，同样也是错误的。</p>
<p><strong>结论：</strong></p>
<blockquote>
<p>class类型的仿函数并不适合以非类型模板实参的形式进行传递。<br>
相反，函数指针（或者函数引用）却可以是有效的非类型模板实参。</p>
</blockquote>
<h4 id="函数指针的封装"><a class="markdownIt-Anchor" href="#函数指针的封装"></a> 函数指针的封装</h4>
<p>本节主要介绍：把一个合法的函数嵌入一个接收class类型仿函数框架。<br>
因此，我们可以定义一个模板，从而可以方便地嵌入这种函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于把函数指针封装成函数对象的封装类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> (*FP)() &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionReturningIntWrapper</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> FP();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 要进行封装的函数实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_int</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::rand();        <span class="comment">// 调用标准的C函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端，它使用由模板参数传递进来的函数对象类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FO&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coll)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FO fo;        <span class="comment">// 创建函数对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i=<span class="number">0</span>; i&lt;coll.size(); ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        coll[i] = fo();        <span class="comment">// 调用由函数对象表示的函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建含有10个元素的vector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 用封装函数来（重新）初始化vector的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initialize&lt;FunctionReturningIntWrapper&lt;random_int&gt; &gt; (v);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出vector中元素的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i=<span class="number">0</span>; i&lt;v.size(); ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"coll["</span> &lt;&lt; i &lt;&lt; <span class="string">"]:"</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其中位于initialize()内部的表达式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FunctionReturningIntWrapper&lt;random_int&gt;</span></pre></td></tr></table></figure>
<p>封装了函数指针random_int，于是我们可以把</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FunctionReturningIntWrapper&lt;random_int&gt;</span></pre></td></tr></table></figure>
<p>作为一个模板类型参数传递给initialize函数模板。</p>
<p><strong>注意</strong>:我们不能把一个具有C链接的函数指针直接传递给类模板FunctionReturningIntWrapper。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">initialize&lt;FunctionReturningIntWrapper&lt;<span class="built_in">std</span>::rand&gt; &gt; (v);</span></pre></td></tr></table></figure>
<p>可能就会是错误的，因为std::rand()是一个来自C标准库的函数（因此也就具有C链接）。然而，我们可以引入一个typedef，从而就可以使一个函数指针类型具有合适的链接：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对具有C链接的函数指针的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*C_int_FP)</span> <span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 把函数指针封装成函数对象的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;C_int_FP FP&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionReturningIntWrapper</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> FP();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="分析一个仿函数的类型"><a class="markdownIt-Anchor" href="#分析一个仿函数的类型"></a> 分析一个仿函数的类型</h4>
<p>在我们的框架中，我们只是处理class类型的仿函数，并且要求框架可以提供以下这些于仿函数相关的属性：</p>
<ol>
<li>仿函数参数的个数（作为一个成员枚举常量NumParams）</li>
<li>仿函数每个参数的类型（通过成员typedef Param1T、Param2T、Param3T来表示）</li>
<li>仿函数的返回类型（通过一个成员typedef ReturnT来表示）</li>
</ol>
<p>例如，我们可以这样编写PersonSortCriterion，使之适合我们前面的框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonSortCriterion</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = <span class="number">2</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">bool</span> ReturnT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Person <span class="keyword">const</span>&amp; Param1T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Person <span class="keyword">const</span>&amp; Param2T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Person <span class="keyword">const</span>&amp; p1, Person <span class="keyword">const</span>&amp; p2)</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 返回p1是否“小于”p2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>对于没有副作用的仿函数，我们通常把它称为纯仿函数。<br>
例如，通常而言，排序规则就必须是纯仿函数，否则的话排序操作的结果将会是毫无意义的。</p>
<h4 id="访问参数的类型"><a class="markdownIt-Anchor" href="#访问参数的类型"></a> 访问参数的类型</h4>
<p>仿函数可以具有任意数量的参数。我们期望能够编写一个类型函数，对于一个给定的仿函数类型和一个常识N，可以给出该仿函数第N个参数的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ifthenelse.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">int</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsedFunctorParam</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">int</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctorParam</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当N值大于仿函数的参数个数时的类型：FunctorParam&lt;F, N&gt;::Type的类型为私有class类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不使用FunctorParam&lt;F, N&gt;::Type的值为void的原因，是因为void自身会有很多限制，如函数不能接受类型为void的参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Unused</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">        &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 这种类型的对象不能被创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">Private</span> &#123;</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">typedef</span> Private Type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> IfThenElse&lt;F::NumParams&gt;=N,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    UsedFunctorParam&lt;F, N&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    Unused&gt;::ResultT::Type</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsedFunctorParam</span>&lt;F, 1&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> F::Param1T Type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>UsedFunctorParam是我们引入的一个辅助模板，对于每一个特定的N值，都需要对该模板进行局部特化，下面使用宏来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FunctorParamSpec(N)                                                    \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;                                                \</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">UsedFunctorParam</span>&lt;F, N&gt;&#123;</span>                                    \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">public</span>:                                                                    \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">typedef</span> <span class="keyword">typename</span> F::Param##N##T Type;            \</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctorParamSpec(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctorParamSpec(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctorParamSpec(<span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FunctorParamSpec</span></span></pre></td></tr></table></figure>
<h4 id="封装函数指针"><a class="markdownIt-Anchor" href="#封装函数指针"></a> 封装函数指针</h4>
<p>上面一小节，我们借助于typedef的形式，是仿函数类型能够支持某些内省。然而，由于要实现这些内省的约束，函数指针不再适用于我们的框架。我们可以通过封装函数指针来绕过这种限制。我们可以开发一个小工具，它能够封装最多具有2个参数的函数（封装含有多个参数的函数的原理和做法是一样的）。</p>
<p>接下来给出的解释方案将会涉及到2个组件：类模板FunctionPtr，它的实例就是封装函数指针的仿函数类型；重载函数模板func_ptr，它接收一个函数指针为参数，然后返回一个相应的、适合该框架的仿函数。其中，类模板FunctionPtr将由返回类型和参数类型进行参数化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1 = <span class="keyword">void</span>, <span class="keyword">typename</span> P2 = <span class="keyword">void</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class FunctionPtr;</span></pre></td></tr></table></figure>
<p>用void值来替换一个参数意味着：该参数实际上并没有提供。因此，我们的模板能够处理仿函数调用实参个数不同的情况。<br>
因为我们需要封装的是函数指针，所以我们需要有一个工具，它能够根据参数的类型，来创建函数指针类型。我们通过下面的局部特化来实现这个目的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本模板，用于处理参数个数最大的情况：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1 = <span class="keyword">void</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> P2 = <span class="keyword">void</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> P3 = <span class="keyword">void</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class FunctionPtrT</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = <span class="number">3</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">RT</span> <span class="params">(*Type)</span><span class="params">(P1, P2, P3)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于处理两个参数的局部特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> P2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionPtrT</span>&lt;RT, P1, P2, void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = <span class="number">2</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">RT</span> <span class="params">(*Type)</span><span class="params">(P1, P2)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于处理一个参数的局部特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionPtrT</span>&lt;RT, P1, void, void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = <span class="number">1</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">RT</span> <span class="params">(*Type)</span><span class="params">(P1)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用于处理0个参数的局部特化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionPtrT</span>&lt;RT, void, void, void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">RT</span> <span class="params">(*Type)</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>你会发现，我们还使用了上面这个（相同的）模板来计算参数的个数。</p>
<p>对于上面这个仿函数类型，它把它的参数传递给所封装的函数指针。然而，传递一个函数调用实参是可能会产生副作用的：如果相应的参数属于class类型（而不是一个指向class类型的引用），那么在传递的过程中，将会调用该class类型的拷贝构造函数。</p>
<p>为了避免这个（调用拷贝构造函数）额外的开销，我们需要编写一个类型函数；在一般情况下，该类型函数不会改变实参的类型，而当参数是属于class类型的时候，它会产生一个指向该class类型的const引用。借助于在前面章节开发的TypeT模板和熟知的IfThenElse功能模板，我们可以这样准确地实现这个类型函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ifthenelse.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typet.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeop.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于class类型，ForwardParamT&lt;T&gt;::Type是一个常引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于其他的所有类型，ForwardParamT&lt;T&gt;::Type是普通类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于void类型，ForwardParamT&lt;T&gt;::Type是一个哑类型（Unused）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardParamT</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> IfThenElse&lt;TypeT&lt;T&gt;::IsClassT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    <span class="keyword">typename</span> TypeOp&lt;T&gt;::RefConstT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    <span class="keyword">typename</span> TypeOp&lt;T&gt;::ArgT</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    &gt;::ResultT</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardParamT</span>&lt;void&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Unused</span> &#123;</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> Unused Type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>我们发现这个模板和前面的RParam模板非常相似，唯一的区别在于：在此我们需要把void类型（我们在前面已经说明，void类型是用于代表那些没有提供参数的类型）映射为一个类型，而且该类型必须是一个有效的参数类型。</p>
<p>现在，我们已经能够定义FunctionPtr模板了。另外，由于我们事先并不知道FunctionPtr究竟会接收多少个参数，所以在下面的代码中，我们针对不同个数的参数（但在此我们最多只是针对3个参数），都重载了函数调用运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functors/functionptr.hpp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"forwardparam.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functionptrt.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1 = <span class="keyword">void</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> P2 = <span class="keyword">void</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="keyword">typename</span> P3 = <span class="keyword">void</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class FunctionPtr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> typaname FunctionPtrT&lt;RT, P1, P2, P3&gt;::Type FuncPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 封装的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        FuncPtr fptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 使之适合我们的框架</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">enum</span> &#123; NumParams = FunctionPtrT&lt;RT, P1, P2, P3&gt;::NumParams &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> RT ReturnT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> P1 Param1T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> P2 Param2T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">typedef</span> P3 Param3T;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 构造函数：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        FunctionPtr(FuncPtr ptr) : fptr(ptr) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// "函数调用":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">RT <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> fptr();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">RT <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">typename</span> ForwardParamT&lt;P1&gt;::Type a1)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> fptr(a1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">RT <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">typename</span> ForwardParamT&lt;P1&gt;::Type a1,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                            <span class="keyword">typename</span> ForwardParamT&lt;P2&gt;::Type a2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> fptr(a1, a2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">RT <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">typename</span> ForwardParamT&lt;P1&gt;::Type a1,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                            <span class="keyword">typename</span> ForwardParamT&lt;P2&gt;::Type a2,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                            <span class="keyword">typename</span> ForwardParamT&lt;P3&gt;::Type a3)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> fptr(a1, a2, a3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>该类模板可以实现所期望的功能，但如果直接使用该模板，将会比较繁琐。为了使之具有更好的易用性，我们可以借助模板的实参演绎机制，实现每个对应的（内联的）函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functionptr.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT&gt; <span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctionPtr&lt;RT&gt; func_ptr (RT (*fp) () )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FunctionPtr&lt;RT&gt;(fp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1&gt; <span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctionPtr&lt;RT, P1&gt; func_ptr (RT (*fp) (P1) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FunctionPtr&lt;RT, P1&gt;(fp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt; <span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctionPtr&lt;RT, P1, P2&gt; func_ptr (RT (*fp) (P1, P2) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FunctionPtr&lt;RT, P1, P2&gt;(fp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2, <span class="keyword">typename</span> P3&gt; <span class="keyword">inline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FunctionPtr&lt;RT, P1, P2, P3&gt; func_ptr (RT (*fp) (P1, P2, P3) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FunctionPtr&lt;RT, P1, P2, P3&gt;(fp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>至此，剩余的工作就是编写一个使用这个（高级）模板工具的实例程序了。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"funcptr.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">seven</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">7.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">more</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"more"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctorT&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(FunctorT func)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Functor returns type "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">typename</span> FunctorT::ReturnT).name() &lt;&lt; <span class="string">'\n'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;&lt; <span class="string">"Functor returns value "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;&lt; func() &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    demo(func_ptr(seven));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    demo(func_ptr(more));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="#">C++ Template By David Vandevoorde</a>还介绍了函数对象组合和和值绑定的相关知识点及其实现。函数对象组合通过组合两个或多个仿函数，来实现多个仿函数功能的组合，完成较为复杂的操作；而值绑定通过对一个具有多个参数的仿函数，把其中一个参数绑定为一个特定的值。</p>
<h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> @Reference</h3>
<ul>
<li><a href="/assets/2019/12/09/sanderson_templates_lecture_uqcomp7305.pdf">Advanced C++ Template Techniques:An Introduction to Meta-Programming for Scientific Computing</a></li>
<li>C++ Template By David Vandevoorde</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Operator Overload(赋值运算符重载)</title>
    <url>/program/C++-Operator-Overload.html</url>
    <content><![CDATA[<h2 id="c-operator-overload"><a class="markdownIt-Anchor" href="#c-operator-overload"></a> C++ Operator Overload</h2>
<h3 id="转换函数-opetartor"><a class="markdownIt-Anchor" href="#转换函数-opetartor"></a> 转换函数 (Opetartor ())</h3>
<h4 id="operator用于类型转换函数"><a class="markdownIt-Anchor" href="#operator用于类型转换函数"></a> operator用于类型转换函数</h4>
<blockquote>
<p>类型转换函数的一般形式为 :<br>
operator 类型名() (const)<br>
{实现转换的语句}<br>
在函数名前面不能指定函数类型,函数没有参数.</p>
</blockquote>
<p>类型转换函数的特征</p>
<ol>
<li>型转换函数定义在源类中；</li>
<li>须由 operator 修饰，函数名称是目标类型名或目标类名</li>
<li>函数没有参数，没有返回值，但是有return 语句。<br>
在return语句中返回目标类型数据或调用目标类的构造函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="comment">//定义了一个将类转化为int的转换函数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"convert_to_int"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    my_class a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i_a = (<span class="keyword">int</span>)a;<span class="comment">//第一次显式的转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//第二次隐式的转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以转化为任意其他的类型，只需要改变转换函数即可。<br>
但是在定义转化函数时，要避免出现二义性，比如不要同时提供多个符合条件的转换函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span><span class="comment">//定义了一个将类转化为double的转换函数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"convert_to_double"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="comment">//定义了一个将类转化为int的转换函数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"convert_to_int"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    my_class a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出报错信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">有多个运算符 <span class="string">"&lt;&lt;"</span> 与这些操作数匹配</span></pre></td></tr></table></figure>
<p>当然，若同时需要这两个转换函数，这个错误也可以通过很多方法来解决，比如显式的指定要输出的是哪种类型，而不是让编译器自己去选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>)a &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>或者指定其中一个转换函数只能显式的转换，而不能隐式的转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"convert_to_double"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>都将得到正确的结果。</p>
<p>C++ 允许程序员重新定义标准运算符在与类对象一起使用时的工作方式。</p>
<h3 id="赋值运算符重载-operator"><a class="markdownIt-Anchor" href="#赋值运算符重载-operator"></a> 赋值运算符重载 (Operator =)</h3>
<h4 id="sample"><a class="markdownIt-Anchor" href="#sample"></a> sample</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStr</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> *name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr(<span class="keyword">int</span> _id, <span class="keyword">char</span> *_name)   <span class="comment">//constructor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id = _id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(_name) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        strcpy_s(name, <span class="built_in">strlen</span>(_name) + <span class="number">1</span>, _name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr(<span class="keyword">const</span> MyStr&amp; str)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id = str.id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span>[] name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.name) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        strcpy_s(name, <span class="built_in">strlen</span>(str.name) + <span class="number">1</span>, str.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> MyStr&amp; str)<span class="comment">//赋值运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator ="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">delete</span>[] name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>-&gt;id = str.id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strcpy_s(name, <span class="built_in">strlen</span>(str.name) + <span class="number">1</span>, str.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~MyStr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span>[] name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">MyStr <span class="title">str1</span><span class="params">(<span class="number">1</span>, <span class="string">"hhxx"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr str2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    str2 = str1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyStr str3 = str2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">====================</span></pre></td></tr><tr><td class="code"><pre><span class="line">operator =</span></pre></td></tr><tr><td class="code"><pre><span class="line">======================</span></pre></td></tr><tr><td class="code"><pre><span class="line">copy constructor</span></pre></td></tr></table></figure>
<h4 id="参数说明"><a class="markdownIt-Anchor" href="#参数说明"></a> 参数说明</h4>
<p>一般地，赋值运算符重载函数的参数是函数所在类的const类型的引用,加const 引用是因为</p>
<ol>
<li>不希望在这个函数中对用来进行赋值的“原版”做任何修改</li>
<li>加上const，对于const的和非const的实参，函数就能接受；<br>
如果不加，就只能接受非const的实参。</li>
<li>使用引用避免在函数调用时对实参的一次拷贝，提高了效率</li>
</ol>
<blockquote>
<p><strong>上面的规定都不是强制的，可以不加const，也可以没有引用，甚至参数可以不是函数所在的对象</strong></p>
</blockquote>
<h4 id="返回值说明"><a class="markdownIt-Anchor" href="#返回值说明"></a> 返回值说明</h4>
<p>一般地，返回值是被赋值者的引用，即__*this__</p>
<ul>
<li>这样在函数返回时避免一次拷贝，提高了效率。</li>
<li>更重要的，这样可以实现连续赋值，即类似a=b=c这样。如果不是返回引用而是返回值类型，那么，执行a=b时，调用赋值运算符重载函数，在函数返回时，由于返回的是值类型，所以要对return后边的“东西”进行一次拷贝，得到一个未命名的副本（有些资料上称之为“匿名对象”），然后将这个副本返回，而这个副本是右值，所以，执行a=b后，得到的是一个右值，再执行=c就会出错。</li>
</ul>
<blockquote>
<p><strong>这也不是强制的，我们可以将函数返回值声明为void，然后什么也不返回，只不过这样就不能够连续赋值了。</strong></p>
</blockquote>
<h4 id="调用机制"><a class="markdownIt-Anchor" href="#调用机制"></a> 调用机制</h4>
<p>当为一个类对象赋值（注意：可以用本类对象为其赋值（如sample），也可以用其它类型（如内置类型）的值为其赋值，关于这一点，见后面的例子）时，会由该对象调用该类的赋值运算符重载函数。</p>
<p>如上边代码中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str2 = str1;</span></pre></td></tr></table></figure>
<p>一句，用str1为str2赋值，会由str2调用MyStr类的赋值运算符重载函数。</p>
<p>需要注意的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStr str2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">str2 = str1;</span></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStr str3 = str2;</span></pre></td></tr></table></figure>
<p>在调用函数上是有区别的。正如我们在上面结果中看到的那样。</p>
<p>前者MyStr str2是str2的声明加定义，调用无参构造函数，所以str2 = str1是在str2已经存在的情况下，用str1来为str2赋值，调用的是拷贝赋值运算符重载函数；</p>
<p>而后者，是用str2来初始化str3，调用的是拷贝构造函数。</p>
<h4 id="提供默认赋值运算符重载函数的时机"><a class="markdownIt-Anchor" href="#提供默认赋值运算符重载函数的时机"></a> 提供默认赋值运算符重载函数的时机</h4>
<blockquote>
<p><strong>当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋值运算符重载函数。</strong></p>
</blockquote>
<p>注意我们的限定条件，不是说只要程序中有了显式的赋值运算符重载函数，编译器就一定不再提供默认的版本，而是说__只有程序显式提供了以本类或本类的引用为参数的赋值运算符重载函数时，编译器才不会提供默认的版本__。可见，所谓默认，就是“以本类或本类的引用为参数”的意思</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> data;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data() &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data(<span class="keyword">int</span> _data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        :data(_data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">int</span> _data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(int _data)"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data = _data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Data <span class="title">data1</span><span class="params">(<span class="number">1</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data data2,data3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"====================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"====================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data3 = data2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====================</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span>=(<span class="keyword">int</span> _data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====================</span></pre></td></tr></table></figure>
<p>上面的例子中，我们提供了一个带int型参数的赋值运算符重载函数，data2 = 1 一句调用了该函数，如果编译器不再提供默认的赋值运算符重载函数，那么，data3 = data2 一句将不会编译通过，但我们看到事实并非如此。所以，这个例子有力地证明了我们的结论。</p>
<h4 id="构造函数还是赋值运算符重载函数"><a class="markdownIt-Anchor" href="#构造函数还是赋值运算符重载函数"></a> 构造函数还是赋值运算符重载函数</h4>
<p>如果我们将上面例子中的赋值运算符重载函数注释掉，main函数中的代码依然可以编译通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> data;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data() &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data(<span class="keyword">int</span> _data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        :data(_data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    Data&amp; operator=(const Data&amp; dd)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        cout &lt;&lt; "woshi shei" &lt;&lt; endl;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        return *this;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    Data&amp; operator=(const int _data)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        cout &lt;&lt; "operator=(int _data)" &lt;&lt; endl;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        data = _data;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        return *this;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Data <span class="title">data1</span><span class="params">(<span class="number">1</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Data data2,data3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"====================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"====================="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data3 = data2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====================</span></pre></td></tr><tr><td class="code"><pre><span class="line">constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====================</span></pre></td></tr></table></figure>
<p>可见，当用一个非类A的值（如上面的int型值）为类A的对象赋值时</p>
<ul>
<li>如果匹配的构造函数和赋值运算符重载函数同时存在（如例2），会调用赋值运算符重载函数。</li>
<li>如果只有匹配的构造函数存在，就会调用这个构造函数。</li>
</ul>
<h4 id="显式提供赋值运算符重载函数的时机"><a class="markdownIt-Anchor" href="#显式提供赋值运算符重载函数的时机"></a> 显式提供赋值运算符重载函数的时机</h4>
<ul>
<li>用非类A类型的值为类A的对象赋值时（当然也可以不提供相应的赋值运算符重载函数而只提供相应的构造函数来完成任务）。</li>
<li>当用类A类型的值为类A的对象赋值且类A的成员变量中含有指针时，为避免浅拷贝，必须显式提供赋值运算符重载函数（如例1）。</li>
</ul>
<h4 id="浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#浅拷贝和深拷贝"></a> 浅拷贝和深拷贝</h4>
<p>拷贝构造函数和赋值运算符重载函数都会涉及到这个问题。</p>
<p>所谓浅拷贝，就是说编译器提供的默认的拷贝构造函数和赋值运算符重载函数，仅仅是将对象a中各个数据成员的值拷贝给对象b中对应的数据成员（这里假设a、b为同一个类的两个对象，且用a拷贝出b或用a来给b赋值），而不做其它任何事。</p>
<p>假设我们将例1中显式提供的拷贝构造函数注释掉，然后同样执行<code>MyStr str3 = str2</code> 语句，此时调用默认的拷贝构造函数，它只是将str2的id值和nane值拷贝到str3，这样，str2和str3中的name值是相同的，即它们指向内存中的同一区域（在例1中，是字符串”hhxx”）。如下图<br>
<img alt="string memory" data-src="/assets/2019/12/09/operator_overload_example1.png"></p>
<p>这样，会有两个致命的错误</p>
<ol>
<li>当我们通过str2修改它的name时，str3的name也会被修改！</li>
<li>当执行str2和str3的析构函数时，会导致同一内存区域释放两次，程序崩溃！</li>
</ol>
<p>所以我们必须通过显式提供拷贝构造函数以避免这样的问题。就像我们在例1中做的那样，先判断被拷贝者的name是否为空，若否，delete[] name（后面会解释为什么要这么做），然后，为name重新申请空间，再将拷贝者name中的数据拷贝到被拷贝者的name中。执行后，如图<br>
<img alt="string memory" data-src="/assets/2019/12/09/operator_overload_example2.png"></p>
<p>这样，str2.name和str3.name各自独立，避免了上面两个致命错误。<br>
我们是以拷贝构造函数为例说明的，赋值运算符重载函数也是同样的道理。</p>
<h4 id="赋值运算符重载函数只能是类的非静态的成员函数"><a class="markdownIt-Anchor" href="#赋值运算符重载函数只能是类的非静态的成员函数"></a> 赋值运算符重载函数只能是类的非静态的成员函数</h4>
<blockquote>
<p>C++规定赋值运算符重载函数只能是类的非静态的成员函数，不能是静态成员函数，也不能是友元函数<br>
因为静态成员函数只能操作类的静态成员，不能操作非静态成员。如果我们将赋值运算符重载函数定义为静态成员函数，那么，该函数将无法操作类的非静态成员，这显然是不可行的</p>
</blockquote>
<p>当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动提供一个。假设C++允许将赋值运算符重载函数定义为友元函数，而且以类的引用为参数。与此同时，我们在类内却没有显式提供一个以本类或本类的引用为参数的赋值运算符重载函数。由于友元函数并不属于这个类，而当前类并没有一个以本类或本类的引用为参数的赋值运算符重载函数，所以编译器会自动提供一个。此时，执行类str2=str1这样的代码，编译器是该执行它提供的默认版本呢，还是执行我们定义的友元函数版本呢？</p>
<p>为了避免这样的二义性，C++强制规定，赋值运算符重载函数只能定义为类的成员函数，这样，编译器就能够判定是否要提供默认版本了，也不会再出现二义性。</p>
<h4 id="赋值运算符重载函数不能被继承"><a class="markdownIt-Anchor" href="#赋值运算符重载函数不能被继承"></a> 赋值运算符重载函数不能被继承</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> X;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        X = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">void</span>) :A() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = <span class="number">45</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//b = 67;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (A)b = <span class="number">67</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注释掉的一句无法编译通过。报错提示：没有与这些操作数匹配的”=”运算符。<br>
对于//b = 67 一句，首先，没有可供调用的构造函数（前面说过，在没有匹配的赋值运算符重载函数时，类似于该句的代码可以调用匹配的构造函数）。</p>
<p><strong>代码不能编译通过，说明父类的operator = 函数并没有被子类继承。</strong></p>
<p>为什么赋值运算符重载函数不能被继承呢？</p>
<p>因为相较于基类，派生类往往要添加一些自己的数据成员和成员函数，如果允许派生类继承基类的赋值运算符重载函数，那么，在派生类不提供自己的赋值运算符重载函数时，就只能调用基类的，但基类版本只能处理基类的数据成员，在这种情况下，派生类自己的数据成员怎么办？</p>
<p>所以，<strong>C++规定，赋值运算符重载函数不能被继承</strong>。</p>
<p>上面代码中， (A)b = 67; 一句可以编译通过，原因是我们将B类对象b强制转换成了A类对象。</p>
<h4 id="赋值运算符重载函数要避免自赋值"><a class="markdownIt-Anchor" href="#赋值运算符重载函数要避免自赋值"></a> 赋值运算符重载函数要避免自赋值</h4>
<p>对于赋值运算符重载函数，我们要避免自赋值情况（即自己给自己赋值）的发生，一般地，我们通过比较赋值者与被赋值者的地址是否相同来判断两者是否是同一对象。</p>
<ul>
<li>
<p>为了效率。显然，自己给自己赋值完全是毫无意义的无用功，特别地，对于基类数据成员间的赋值，还会调用基类的赋值运算符重载函数，开销是很大的。如果我们一旦判定是自赋值，就立即return *this，会避免对其它函数的调用。</p>
</li>
<li>
<p>如果类的数据成员中含有指针，自赋值有时会导致灾难性的后果。对于指针间的赋值（注意这里指的是指针所指内容间的赋值，这里假设用_p给p赋值），先要将p所指向的空间delete掉（为什么要这么做呢？因为指针p所指的空间通常是new来的，如果在为p重新分配空间前没有将p原来的空间delete掉，会造成内存泄露），然后再为p重新分配空间，将_p所指的内容拷贝到p所指的空间。如果是自赋值，那么p和_p是同一指针，在赋值操作前对p的delete操作，将导致p所指的数据同时被销毁。那么重新赋值时，会出现不可预期的结果。</p>
</li>
</ul>
<p>所以，对于赋值运算符重载函数，一定要先检查是否是自赋值，如果是，直接return *this。</p>
<h3 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h3>
<p>类型转换：operator &lt;类型&gt;()<br>
运算符重载：&lt;类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;)</p>
<p>重载主要有两种形式，成员函数形式与友元函数形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyClass() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyClass(<span class="keyword">int</span> a, <span class="keyword">double</span> b):a_(a),b_(b)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~MyClass()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a_; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_b</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b_; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass &amp;adder) <span class="keyword">const</span><span class="comment">//以成员函数方式重载+</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClass sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum.a_ = a_ + adder.a_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum.b_ = b_ + adder.b_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>-(<span class="keyword">const</span> MyClass &amp;A,<span class="keyword">const</span> MyClass &amp;B)<span class="comment">//以友元方式重载-</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClass diff;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        diff.a_ = A.a_ - B.a_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        diff.b_ = A.b_ - B.b_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> diff;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> b_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">MyClass <span class="title">A</span><span class="params">(<span class="number">1</span>, <span class="number">1.1</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">MyClass <span class="title">B</span><span class="params">(<span class="number">2</span>, <span class="number">2.2</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyClass sum = A + B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyClass diff = A - B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum.get_a() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; sum.get_b() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; diff.get_a() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; diff.get_b() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="operator-重载"><a class="markdownIt-Anchor" href="#operator-重载"></a> operator 重载 ()</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> hour;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> minute;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> second;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Time( <span class="keyword">int</span> h=<span class="number">0</span>, <span class="keyword">int</span> m=<span class="number">0</span>, <span class="keyword">int</span> s=<span class="number">0</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">operator</span>()( h, m, s );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//版本0，返回时间表示的秒数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> hour*<span class="number">3600</span>+minute*<span class="number">60</span>+second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//版本1，设置为整点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> h )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">operator</span>()( h, <span class="number">0</span>, <span class="number">0</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//版本2，设置整小时和分钟</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> h, <span class="keyword">int</span> m )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">operator</span>()( h, m, <span class="number">0</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//版本3，设置时分秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hour = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minute = m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        second = s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; os, <span class="keyword">const</span> Time&amp; ct )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os &lt;&lt; ct.hour &lt;&lt; ';:';;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>( ct.minute&lt;<span class="number">10</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">            os &lt;&lt; ';0';;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os &lt;&lt; ct.minute &lt;&lt; ';:';;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>( ct.second&lt;<span class="number">10</span> )</span></pre></td></tr><tr><td class="code"><pre><span class="line">            os &lt;&lt; ';0';;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os &lt;&lt; ct.second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> os;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Time t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t( <span class="number">9</span> );<span class="comment">//调用版本1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t( <span class="number">7</span>, <span class="number">30</span> );<span class="comment">//调用版本2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t( <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span> );<span class="comment">//调用版本3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; t() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//调用版本0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="operator-重载-2"><a class="markdownIt-Anchor" href="#operator-重载-2"></a> operator 重载 &amp;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(!_ptr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		throwNullHandleException(__FILE__, __LINE__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> *_ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="operator-重载-"><a class="markdownIt-Anchor" href="#operator-重载-"></a> operator 重载 -&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Action in class A!"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	A a;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A* <span class="keyword">operator</span>-&gt;()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> &amp;a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Action in class B!"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	B b;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B <span class="keyword">operator</span>-&gt;()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Action in class C!"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	C* pc = <span class="keyword">new</span> C;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	pc-&gt;action();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	C c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c-&gt;action();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="operator-重载-3"><a class="markdownIt-Anchor" href="#operator-重载-3"></a> operator 重载 []</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; opetator[] (T instance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	....</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Virtual</title>
    <url>/program/C++-Virtual.html</url>
    <content><![CDATA[<h2 id="c-virtual"><a class="markdownIt-Anchor" href="#c-virtual"></a> C++ Virtual</h2>
<h3 id="virtual-function"><a class="markdownIt-Anchor" href="#virtual-function"></a> Virtual Function</h3>
<h4 id="whats-virtual"><a class="markdownIt-Anchor" href="#whats-virtual"></a> what’s virtual</h4>
<blockquote>
<p>The virtual specifier specifies that a non-static member function is virtual and supports dynamic dispatch. It may only appear in the decl-specifier-seq of the initial declaration of a non-static member function (i.e., when it is declared in the class definition).</p>
</blockquote>
<h4 id="explanation"><a class="markdownIt-Anchor" href="#explanation"></a> Explanation</h4>
<p>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using qualified name lookup (that is, if the function’s name appears to the right of the scope resolution operator :😃.</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> override </span>&#123; <span class="comment">// 'override' is optional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// virtual function call through reference</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base&amp; br = b; <span class="comment">// the type of br is Base&amp;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base&amp; dr = d; <span class="comment">// the type of dr is Base&amp; as  well</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    br.f(); <span class="comment">// prints "base"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dr.f(); <span class="comment">// prints "derived"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// virtual function call through pointer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base* bp = &amp;b; <span class="comment">// the type of bp is Base*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base* dp = &amp;d; <span class="comment">// the type of dp is Base* as  well</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    bp-&gt;f(); <span class="comment">// prints "base"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp-&gt;f(); <span class="comment">// prints "derived"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// non-virtual function call</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    br.Base::f(); <span class="comment">// prints "base"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dr.Base::f(); <span class="comment">// prints "base"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>C++中使用 classname::functionname 可以直接获取成员函数的地址指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non-virtual function call</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">br.Base::f(); <span class="comment">// prints "base"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dr.Base::f(); <span class="comment">// prints "base"</span></span></pre></td></tr></table></figure>
<p>不支持多重继承的语言不需要提供virtual词法，内部提供了类似virtual的机制，且默认使用</p>
<h4 id="another-example-why-virtual-required"><a class="markdownIt-Anchor" href="#another-example-why-virtual-required"></a> another example (why virtual required)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm eating generic food."</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm eating a rat."</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>In your main function:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal *animal = <span class="keyword">new</span> Animal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat *cat = <span class="keyword">new</span> Cat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">animal-&gt;eat(); <span class="comment">// Outputs: "I'm eating generic food."</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat-&gt;eat();    <span class="comment">// Outputs: "I'm eating a rat."</span></span></pre></td></tr></table></figure>
<p>So far so good, right? Animals eat generic food, cats eat rats, all without virtual.</p>
<p>Let’s change it a little now so that eat() is called via an intermediate function (a trivial function just for this example):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This can go at the top of the main.cpp file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *xyz)</span> </span>&#123; xyz-&gt;eat(); &#125;</span></pre></td></tr></table></figure>
<p>Now our main function is:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal *animal = <span class="keyword">new</span> Animal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat *cat = <span class="keyword">new</span> Cat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">func(animal); <span class="comment">// Outputs: "I'm eating generic food."</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">func(cat);    <span class="comment">// Outputs: "I'm eating generic food."</span></span></pre></td></tr></table></figure>
<p>Uh oh… we passed a Cat into func(), but it won’t eat rats. Should you overload func() so it takes a Cat*? If you have to derive more animals from Animal they would all need their own func().</p>
<p>The solution is to make eat() from the Animal class a virtual function:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm eating generic food."</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm eating a rat."</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>Main:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func(animal); <span class="comment">// Outputs: "I'm eating generic food."</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">func(cat);    <span class="comment">// Outputs: "I'm eating a rat."</span></span></pre></td></tr></table></figure>
<h3 id="in-detail"><a class="markdownIt-Anchor" href="#in-detail"></a> In detail</h3>
<p>If some member function vf is declared as virtual in a class Base, and some class Derived, which is derived, directly or indirectly, from Base, has a declaration for member function with the same</p>
<ul>
<li>name</li>
<li>parameter type list (but not the return type)</li>
<li>cv-qualifiers</li>
<li>ref-qualifiers</li>
</ul>
<p>Then this function in the class Derived is also virtual (whether or not the keyword virtual is used in its declaration) and overrides Base::vf (whether or not the word override is used in its declaration).</p>
<p>Base::vf does not need to be visible (can be declared private, or inherited using private inheritance) to be overridden.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">do_f</span><span class="params">()</span></span>; <span class="comment">// private member</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; do_f(); &#125; <span class="comment">// public interface</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_f</span><span class="params">()</span> override</span>; <span class="comment">// overrides B::do_f</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    D d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B* bp = &amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bp-&gt;f(); <span class="comment">// internally calls D::do_f();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>For every virtual function, there is the final overrider, which is executed when a virtual function call is made. A virtual member function vf of a base class Base is the final overrider unless the derived class declares or inherits (through multiple inheritance) another function that overrides vf.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;     <span class="comment">// A::f is virtual</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;         <span class="comment">// B::f overrides A::f in B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> B &#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;; <span class="comment">// C::f overrides A::f in C</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> <span class="keyword">virtual</span> B &#123;&#125;; <span class="comment">// D does not introduce an overrider, B::f is final in D</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> :</span> C, D  &#123;       <span class="comment">// E does not introduce an overrider, C::f is final in E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> A::f; <span class="comment">// not a function declaration, just makes A::f visible to lookup</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   E e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   e.f();    <span class="comment">// virtual call calls C::f, the final overrider in e</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   e.E::f(); <span class="comment">// non-virtual call calls A::f, which is visible in E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>A function with the same name but different parameter list does not override the base function of the same name, but hides it</strong>: when unqualified name lookup examines the scope of the derived class, the lookup finds the declaration and does not examine the base class.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// D::f hides B::f (wrong parameter list)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> D &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// D2::f overrides B::f (doesn't matter that it's not visible)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B b;   B&amp; b_as_b   = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    D d;   B&amp; d_as_b   = d;    D&amp; d_as_d = d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    D2 d2; B&amp; d2_as_b  = d2;   D&amp; d2_as_d = d2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    b_as_b.f(); <span class="comment">// calls B::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d_as_b.f(); <span class="comment">// calls B::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d2_as_b.f(); <span class="comment">// calls D2::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    d_as_d.f(); <span class="comment">// Error: lookup in D finds only f(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d2_as_d.f(); <span class="comment">// Error: lookup in D finds only f(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>If a function is declared with the specifier override, but does not override a virtual function, the program is ill-formed:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override</span>; <span class="comment">// OK, D::f(int) overrides B::f(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span>)</span> override</span>; <span class="comment">// Error: f(long) does not override B::f(int)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结：</strong></h4>
<ul>
<li><strong>Non-virtual method ⇒ static binding</strong></li>
<li><strong>virtual method =&gt; dynamic runtime binding</strong></li>
<li><strong>Non-member functions and static member functions cannot be virtual.</strong></li>
<li>若基类中的成员函数声明为虚函数，派生类中重写的virtual函数自动成为虚函数</li>
</ul>
<h3 id="covariant-return-types"><a class="markdownIt-Anchor" href="#covariant-return-types"></a> Covariant return types</h3>
<p>If the function Derived::f overrides a function Base::f, their return types must either be the same or be covariant. Two types are covariant if they satisfy all of the following requirements:</p>
<ul>
<li>both types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed.</li>
<li>the referenced/pointed-to class in the return type of Base::f() must be a unambiguous and accessible direct or indirect base class of the referenced/pointed-to class of the return type of Derived::f().</li>
<li>the return type of Derived::f() must be equally or less cv-qualified than the return type of Base::f().</li>
</ul>
<p>The class in the return type of Derived::f must be either Derived itself, or must be a complete type at the point of declaration of Derived::f.</p>
<p>When a virtual function call is made, the type returned by the final overrider is implicitly converted to the return type of the overridden function that was called:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vf1</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vf2</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vf3</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> B* <span class="title">vf4</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> B* <span class="title">vf5</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">private</span> B &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>;</span> <span class="comment">// in Derived, B is an accessible base of D</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span> <span class="comment">// forward-declared class is an incomplete type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vf1</span><span class="params">()</span></span>;    <span class="comment">// virtual, overrides Base::vf1()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vf2</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// non-virtual, hides Base::vf2()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  char vf3();    // Error: overrides Base::vf3, but has different</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="comment">// and non-covariant return type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">D* <span class="title">vf4</span><span class="params">()</span></span>;      <span class="comment">// overrides Base::vf4() and has covariant return type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  A* vf5();      // Error: A is incomplete type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base&amp; br = d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived&amp; dr = d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    br.vf1(); <span class="comment">// calls Derived::vf1()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    br.vf2(); <span class="comment">// calls Base::vf2()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  dr.vf2(); // Error: vf2(int) hides vf2()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    B* p = br.vf4(); <span class="comment">// calls Derived::vf4() and converts the result to B*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    D* q = dr.vf4(); <span class="comment">// calls Derived::vf4() and does not convert</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                     <span class="comment">//  the result to B*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="virtual-destructor"><a class="markdownIt-Anchor" href="#virtual-destructor"></a> Virtual destructor</h3>
<p>父类有virtual修饰的方法，且被子类覆盖，需要注意必须使用virtual声明父类的析构函数。</p>
<blockquote>
<p>上述场景一般使用工厂设计模式，定义一个父类的指针，指向子类对象，而在delete 父类指针时，期望释放对象。但父类析构函数不加Virtual修饰，则只会调用父类析构函数，而不调用子类析构函数，导致只释放了对象的父类部分，而子类部分没有释放。Virtual含义就是有一个函数映射表，调用时会去查映射表调用对应的方法。</p>
</blockquote>
<p>Even though destructors are not inherited, if a base class declares its destructor virtual, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">virtual</span> ~Base() &#123; <span class="comment">/* releases Base's resources */</span> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Derived() &#123; <span class="comment">/* releases Derived's resources */</span> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base* b = <span class="keyword">new</span> Derived;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">delete</span> b; <span class="comment">// Makes a virtual function call to Base::~Base()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="comment">// since it is virtual, it calls Derived::~Derived() which can</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="comment">// release resources of the derived class, and then calls</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="comment">// Base::~Base() following the usual order of destruction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Moreover, if a class is polymorphic (declares or inherits at least one virtual function), and its destructor is not virtual, deleting it is undefined behavior regardless of whether there are resources that would be leaked if the derived destructor is not invoked.</p>
<h3 id="virtual-function-table"><a class="markdownIt-Anchor" href="#virtual-function-table"></a> virtual function table</h3>
<h4 id="what-do-vtables-have-to-do-with-all-this"><a class="markdownIt-Anchor" href="#what-do-vtables-have-to-do-with-all-this"></a> what do vtables have to do with all this?</h4>
<p>Well, there are cases where it is not possible for the compiler to know which routine to execute at compile time. This is the case, for instance, when we declare virtual functions:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">qux</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> B::bar()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is B's implementation of bar"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> B::qux()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is B's implementation of qux"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>The thing about virtual functions is that they can be overriden by subclasses:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> C::bar()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is C's implementation of bar"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Now consider the following call to bar():</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B* b = <span class="keyword">new</span> C();</span></pre></td></tr><tr><td class="code"><pre><span class="line">b-&gt;bar();</span></pre></td></tr></table></figure>
<p>If we use static dispatch as above, the call b-&gt;bar() would execute B::bar(), since (from the point of view of the compiler) b points to an object of type B. This would be horribly wrong, off course, because b actually points to an object of type C and C::bar() should be called instead.</p>
<p>Hopefully you can see the problem by now: given that virtual functions can be redefined in subclasses, calls via pointers (or references) to a base type can not be dispatched at compile time. The compiler has to find the right function definition (i.e. the most specific one) at runtime. This process is called dynamic dispatch or late method binding.</p>
<h4 id="how-do-we-implement-dynamic-dispatch"><a class="markdownIt-Anchor" href="#how-do-we-implement-dynamic-dispatch"></a> how do we implement dynamic dispatch?</h4>
<p>For every class that contains virtual functions, the compiler constructs a virtual table, a.k.a vtable. The vtable contains an entry for each virtual function accessible by the class and stores a pointer to its definition. Only the most specific function definition callable by the class is stored in the vtable. Entries in the vtable can point to either functions declared in the class itself (e.g. C::bar()), or virtual functions inherited from a base class (e.g. C::qux()).</p>
<p>In our example, the compiler will create the following virtual tables:<br>
<img alt="vtables" data-src="/assets/2019/12/09/vtables.png"></p>
<p>The vtable of class B has two entries, one for each of the two virtual functions declared in B’s scope: bar() and qux(). Additionally, the vtable of B points to the local definition of functions, since they are the most specific (and only) from B’s point of view.</p>
<p>More interesting is C’s vtable. In this case, the entry for bar() points to own C’s implementation, given that it is more specific than B::bar(). Since C doesn’t override qux(), its entry in the vtable points to B’s definition (the most specific definition).</p>
<blockquote>
<p><strong>Note that vtables exist at the class level, meaning there exists a single vtable per class, and is shared by all instances.</strong></p>
</blockquote>
<h4 id="vpointers"><a class="markdownIt-Anchor" href="#vpointers"></a> Vpointers</h4>
<p>You might be thinking: vtables are cool and all, but how exactly do they solve the problem? When the compiler sees b-&gt;bar() in the example above, it will lookup B’s vtable for bar’s entry and follow the corresponding function pointer, right? We would still be calling B::bar() and not C::bar()…</p>
<p>Very true, I still need to tell the second part of the story: vpointers. Every time the compiler creates a vtable for a class, it adds an extra argument to it: a pointer to the corresponding virtual table, called the vpointer.<br>
<img alt data-src="/assets/2019/12/09/vpointer.png"></p>
<p>Note that the vpointer is just another class member added by the compiler and increases the size of every object that has a vtable by sizeof(vpointer).</p>
<p>Hopefully you have grasped how dynamic function dispatch can be implemented by using vtables: when a call to a virtual function on an object is performed, the vpointer of the object is used to find the corresponding vtable of the class. Next, the function name is used as index to the vtable to find the correct (most specific) routine to be executed. Done!</p>
<h4 id="virtual-destructors"><a class="markdownIt-Anchor" href="#virtual-destructors"></a> Virtual Destructors</h4>
<p>By now it should also be clear why it is always a good idea to make destructors of base classes virtual. Since derived classes are often handled via base class references, declaring a non-virtual destructor will be dispatched statically, obfuscating the destructor of the derived class:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ~Base()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destroying base"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Derived(<span class="keyword">int</span> number)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    some_resource_ = <span class="keyword">new</span> <span class="keyword">int</span>(number);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ~Derived()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destroying derived"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">delete</span> some_resource_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span>* some_resource_;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Base* p = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">delete</span> p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>This will output:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Destroying base</span></pre></td></tr></table></figure>
<p>Making Base’s destructor virtual will result in the expected behavior:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Destroying derived</span></pre></td></tr><tr><td class="code"><pre><span class="line">Destroying base</span></pre></td></tr></table></figure>
<h4 id="wrapping-up"><a class="markdownIt-Anchor" href="#wrapping-up"></a> Wrapping up</h4>
<blockquote>
<ol>
<li>Function overriding makes it impossible to dispatch virtual functions statically (at compile time)</li>
<li>Dispatching of virtual functions needs to happen at runtime</li>
<li>The virtual table method is a popular implementation of dynamic dispatch</li>
<li>For every class that defines or inherits virtual functions the compiler creates a virtual table</li>
<li>The virtual table stores a pointer to the most specific definition of each virtual function</li>
<li>For every class that has a vtable, the compiler adds an extra member to the class: the vpointer</li>
<li>The vpointer points to the corresponding vtable of the class</li>
<li>Always declare desctructors of base classes as virtual</li>
</ol>
</blockquote>
<h3 id="virtual-inherit"><a class="markdownIt-Anchor" href="#virtual-inherit"></a> Virtual inherit</h3>
<p>通过合理的重构和设计，避开使用虚继承</p>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<p>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Base b;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//sizeof (b); //outputs 8</span></span></pre></td></tr></table></figure>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Base b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fun pFun = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Invoke the first virtual function </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span></pre></td></tr><tr><td class="code"><pre><span class="line">pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">虚函数表地址：<span class="number">0x7ffdc351ecf0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">虚函数表 — 第一个函数地址：<span class="number">0x400e50</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Base::f</span></pre></td></tr></table></figure>
<p>可以看到，通过强行把 &amp;b 转成int*，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>);  <span class="comment">// Base::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>);  <span class="comment">// Base::g()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>);  <span class="comment">// Base::h()</span></span></pre></td></tr></table></figure>
<p><img alt="virtual table display" data-src="/assets/2019/12/09/vtable_exmple.png"></p>
<blockquote>
<p>上图中，虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</p>
</blockquote>
<p>下面将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。作为对比，先说明没有覆盖的情况。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h4 id="一般继承无虚函数覆盖"><a class="markdownIt-Anchor" href="#一般继承无虚函数覆盖"></a> 一般继承（无虚函数覆盖）</h4>
<p>假设有如下所示的一个继承关系<br>
<img alt="inherit" data-src="/assets/2019/12/09/virtual_inherit_common.png"></p>
<p>注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，<br>
对于实例：Derive d; 的虚函数表如下：<br>
<img alt="vtable" data-src="/assets/2019/12/09/vtable_example2.png"></p>
<p>显然可见：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。</li>
</ol>
<h4 id="一般继承有虚函数覆盖"><a class="markdownIt-Anchor" href="#一般继承有虚函数覆盖"></a> 一般继承（有虚函数覆盖）</h4>
<p>假设有如下所示的一个继承关系<br>
<img alt="inherit" data-src="/assets/2019/12/09/virtual_inherit_common.png"></p>
<p>在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子<br>
<img alt="vtable" data-src="/assets/2019/12/09/vtable_example3.png"></p>
<p>我们从表中可以看到下面几点，</p>
<ol>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。</li>
</ol>
<p>下面由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derive();</span></pre></td></tr><tr><td class="code"><pre><span class="line">b-&gt;f();</span></pre></td></tr></table></figure>
<h4 id="多重继承无虚函数覆盖"><a class="markdownIt-Anchor" href="#多重继承无虚函数覆盖"></a> 多重继承（无虚函数覆盖）</h4>
<p>设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br>
<img alt="inherit" data-src="/assets/2019/12/09/virtual_inherit_multi.png"><br>
子类实例中的虚函数表，是下面这个样子：<br>
<img alt="vtable" data-src="/assets/2019/12/09/vtable_example4.png"></p>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<blockquote>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
</blockquote>
<h4 id="多重继承有虚函数覆盖"><a class="markdownIt-Anchor" href="#多重继承有虚函数覆盖"></a> 多重继承（有虚函数覆盖）</h4>
<p>设有下面这样一个类的继承关系。 注意：我们在子类中覆盖了父类的f()函数。<br>
<img alt="inherit" data-src="/assets/2019/12/09/virtual_inherit_multi.png"><br>
子类实例中的虚函数表，是下面这个样子：<br>
<img alt="vtable" data-src="/assets/2019/12/09/vtable_example5.png"></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derive d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Base1 *b1 = &amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Base2 *b2 = &amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Base3 *b3 = &amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">b1-&gt;f(); <span class="comment">//Derive::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b2-&gt;f(); <span class="comment">//Derive::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b3-&gt;f(); <span class="comment">//Derive::f()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">b1-&gt;g(); <span class="comment">//Base1::g()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b2-&gt;g(); <span class="comment">//Base2::g()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b3-&gt;g(); <span class="comment">//Base3::g()</span></span></pre></td></tr></table></figure>
<h4 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h4>
<h5 id="通过父类型的指针访问子类自己的虚函数"><a class="markdownIt-Anchor" href="#通过父类型的指针访问子类自己的虚函数"></a> 通过父类型的指针访问子类自己的虚函数</h5>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1 *b1 = <span class="keyword">new</span> Derive();</span></pre></td></tr><tr><td class="code"><pre><span class="line">b1-&gt;f1();  <span class="comment">//编译出错</span></span></pre></td></tr></table></figure>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。</p>
<blockquote>
<p><strong>但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</strong></p>
</blockquote>
<h5 id="访问non-public的虚函数"><a class="markdownIt-Anchor" href="#访问non-public的虚函数"></a> 访问non-public的虚函数</h5>
<p>如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derive d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Fun  pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;d)+<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="附录多重继承运行时环境父类型的指针访问子类自己的虚函数"><a class="markdownIt-Anchor" href="#附录多重继承运行时环境父类型的指针访问子类自己的虚函数"></a> 附录：多重继承运行时环境父类型的指针访问子类自己的虚函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::g1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Fun pFun = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Derive d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">int</span>** pVtab = (<span class="keyword">int</span>**)&amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Base1's vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">0</span>][<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">0</span>][<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">0</span>][<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Derive's vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">0</span>][<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//The tail of the vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">0</span>][<span class="number">4</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">cout</span>&lt;&lt;pFun&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Base2's vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">1</span>][<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">1</span>][<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">1</span>][<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun(); </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//The tail of the vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">1</span>][<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">cout</span>&lt;&lt;pFun&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//Base3's vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">2</span>][<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">2</span>][<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">2</span>][<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun(); </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//The tail of the vtable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pFun = (Fun)pVtab[<span class="number">2</span>][<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">cout</span>&lt;&lt;pFun&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> @Reference</h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/virtual" target="_blank" rel="noopener">virtual official manual</a></li>
<li><a href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c" target="_blank" rel="noopener">why-do-we-need-virtual-functions</a></li>
<li><a href="https://pabloariasal.github.io/2017/06/10/understanding-virtual-tables/" target="_blank" rel="noopener">understanding-virtual-tables</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 Features Overview</title>
    <url>/program/C++11-Features-Overview.html</url>
    <content><![CDATA[<hr>
<h2 id="title-c11-features-overviewmathjax-falseschema-programp-programc11-featuresdate-2019-12-08-233230categories-编程tags-curlname-c11-features-overview"><a class="markdownIt-Anchor" href="#title-c11-features-overviewmathjax-falseschema-programp-programc11-featuresdate-2019-12-08-233230categories-编程tags-curlname-c11-features-overview"></a> title: C<ins>11 Features Overview<br>
mathjax: false<br>
schema: program<br>
p: program/c</ins>11-features<br>
date: 2019-12-08 23:32:30<br>
categories:<br>
- 编程<br>
tags:<br>
- C++<br>
urlname: C++11-Features-Overview</h2>
<h2 id="c11-新增特性"><a class="markdownIt-Anchor" href="#c11-新增特性"></a> C++11 新增特性</h2>
<h3 id="空指针-nullptr"><a class="markdownIt-Anchor" href="#空指针-nullptr"></a> 空指针 nullptr</h3>
<p>nullptr 出现的目的是为了替代 NULL。</p>
<p>C++11之前官方标准对NULL、0没有严格的区分，更多的是取决于不同编译器的选择，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。</p>
<p>C++ 不允许直接将 void * 隐式转换到其他类型，但如果 NULL 被定义为 ((void*)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0。</p>
<p>这显然会产生问题，导致了 C++ 中重载特性会发生混乱，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span></pre></td></tr></table></figure>
<p>如果 NULL 又被定义为了 0 那么 foo(NULL)将会去调用 foo(int)，从而导致代码违反直观。</p>
<blockquote>
<p>为了解决这个问题，C++11 引入了 <strong>nullptr</strong> 关键字，专门用来区分__空指针、0__。<br>
nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等运算。</p>
</blockquote>
<p>当需要使用 NULL 时候，养成直接使用 nullptr 的习惯</p>
<a id="more"></a>
<h3 id="智能指针-smart-pointer"><a class="markdownIt-Anchor" href="#智能指针-smart-pointer"></a> 智能指针 Smart Pointer</h3>
<p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<p>理解智能指针：</p>
<ol>
<li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li>
<li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li>
<li>智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Animal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal b = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//java这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal b = a; <span class="comment">//这里却是就是生成了两个对象。</span></span></pre></td></tr></table></figure>
<p>C++11标准引入智能指针，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr。</memory></p>
<h4 id="shared_ptr"><a class="markdownIt-Anchor" href="#shared_ptr"></a> shared_ptr</h4>
<p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
<ul>
<li>初始化。<br>
智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的</int></li>
<li>拷贝和赋值。<br>
拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。</li>
<li>get函数获取原始指针。</li>
<li><strong>不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存</strong></li>
<li><strong>避免循环引用</strong>。</li>
</ul>
<p>shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。<br>
循环引用在weak_ptr中介绍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra2(ptra); <span class="comment">//copy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> *pb = &amp;a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptrb = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ptra2 = ptrb; <span class="comment">//assign</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pb = ptrb.get(); <span class="comment">//获取原始指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> unique_ptr</h4>
<p>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。<br>
相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。</p>
<p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</p>
<p>unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  <span class="comment">//绑定动态对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr2 = <span class="built_in">std</span>::move(uptr); <span class="comment">//轉換所有權</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        uptr2.release(); <span class="comment">//释放所有权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//超過uptr的作用域，內存釋放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h4>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。</p>
<p>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。<br>
但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count() == 0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p>
<p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sh_ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!wp.expired())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock(); <span class="comment">//get another shared_ptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            *sh_ptr = <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//delete memory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="循环引用"><a class="markdownIt-Anchor" href="#循环引用"></a> 循环引用</h4>
<p>考虑一个简单的对象建模——家长与子女：a Parent has a Child, a Child knows his/her Parent。在Java 里边很好写，不用担心内存泄漏，也不用担心空悬指针，只要正确初始化myChild 和myParent，那么Java 程序员就不用担心出现访问错误。一个handle 是否有效，只需要判断其是否non null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="keyword">private</span> Child myChild;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="keyword">private</span> Parent myParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在C++ 里边就要为资源管理费一番脑筋。如果使用原始指针作为成员，Child和Parent由谁释放？那么如何保证指针的有效性？如何防止出现空悬指针？这些问题是C++面向对象编程麻烦的问题，现在可以借助smart pointer把对象语义（pointer）转变为值（value）语义，shared_ptr轻松解决生命周期的问题，不必担心空悬指针。但是这个模型存在循环引用的问题，注意其中一个指针应该为weak_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始指针的做法，容易出错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Child* myChild;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(Child* ch)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;myChild = ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;myChild) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Parent() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> myChild;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Parent* myParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(Parent* p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;myParent = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;myParent) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Child() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> myParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Parent* p = <span class="keyword">new</span> Parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Child* c =  <span class="keyword">new</span> Child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;setChild(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c-&gt;setPartent(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">delete</span> c;  <span class="comment">//only delete one</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>循环引用内存泄露的问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; ChildPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.use_count()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Parent() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Child() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; p(<span class="keyword">new</span> Parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; c(<span class="keyword">new</span> Child);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;setChild(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c-&gt;setPartent(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wpp = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wpc = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>正确的做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//std::shared_ptr&lt;Child&gt; ChildPtr;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; ChildPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//new shared_ptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.lock()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Parent() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Child() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; p(<span class="keyword">new</span> Parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; c(<span class="keyword">new</span> Child);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;setChild(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c-&gt;setPartent(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wpp = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wpc = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="智能指针的设计和实现"><a class="markdownIt-Anchor" href="#智能指针的设计和实现"></a> 智能指针的设计和实现</h4>
<p>简单探究智能指针的设计实现。</p>
<ol>
<li>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</li>
<li>每次创建类的新对象时，初始化指针并将引用计数置为1；</li>
<li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；</li>
<li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；</li>
<li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</li>
</ol>
<p>智能指针就是模拟指针动作的类。所有的智能指针都会重载 -&gt; 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T* _ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span>* _count;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SmartPointer(T* ptr = <span class="literal">nullptr</span>) :</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _ptr(ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (_ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SmartPointer(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>-&gt;_count = ptr._count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (*<span class="keyword">this</span>-&gt;_count)++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (*<span class="keyword">this</span>-&gt;_count)--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;_count = ptr._count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (*<span class="keyword">this</span>-&gt;_count)++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~SmartPointer() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (*<span class="keyword">this</span>-&gt;_count)--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> use_count()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SmartPointer&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SmartPointer&lt;<span class="keyword">int</span>&gt; sp2(sp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SmartPointer&lt;<span class="keyword">int</span>&gt; sp3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sp2 = sp3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//delete operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="强枚举类型-strongly-typed-enums"><a class="markdownIt-Anchor" href="#强枚举类型-strongly-typed-enums"></a> 强枚举类型 Strongly-typed enums</h3>
<p>为了解决c/c<ins>98中的enum类型的一系列缺点，比如：全局作用域，非强类型，允许隐式转换为int型，占用存储空间及符号性不确定。c</ins>11引入了枚举类（又称为：强枚举类型strong-typed enum）<br>
语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> 类型名 &#123;</span>枚举值表&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span>yellow,black,white&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这样就成功的定义了一个强类型的枚举People。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">注意：等价于 <span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> 类型名&#123;</span>枚举值表&#125;; </span></pre></td></tr><tr><td class="code"><pre><span class="line">（<span class="keyword">enum</span> <span class="class"><span class="keyword">class</span>中的成员没有公有私有之分，也不会使用模板来支持泛化的功能）</span></span></pre></td></tr></table></figure>
<p>强枚举类型的优点</p>
<ul>
<li><strong>强作用域</strong> 强类型的枚举成员的名称不会被输出到其父作用域空间；</li>
<li><strong>转换限制</strong> 强类型枚举成员的值不可以与int隐式的相互转换</li>
<li><strong>指定底层类型</strong> 强类型枚举底层类型为int，但是也可以显示的指定底层类型。<br>
具体方法：在enum名称后面加：“：type”，其中type可以是除wchar_t以外的任何int</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span> <span class="keyword">char</span>&#123;yellow,black,white&#125;;</span></pre></td></tr></table></figure>
<h3 id="静态断言-static-assert"><a class="markdownIt-Anchor" href="#静态断言-static-assert"></a> 静态断言 static assert</h3>
<p>static_assert这个关键字，用来做编译期间的断言，因此叫做静态断言。<br>
语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(常量表达式，提示字符串）</span></pre></td></tr></table></figure>
<p>如果第一个参数常量表达式的值为false，会产生一条编译错误，错误位置就是该static_assert语句所在行，第二个参数就是错误提示字符串。</p>
<p>使用static_assert，我们可以在编译期间发现更多的错误，用编译器来强制保证一些契约，并帮助我们改善编译信息的可读性，尤其是用于模板的时候。</p>
<p>static_assert可以用在全局作用域中，命名空间中，类作用域中，函数作用域中，几乎可以不受限制的使用。由于是static_assert编译期间断言，不生成目标代码，因此static_assert不会造成任何运行期性能损失。</p>
<p>编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。</p>
<p>C++03标准中，就有assert、#error两个设施，也是用来检查错误的，还有一些第三方的静态断言实现。</p>
<h4 id="assert"><a class="markdownIt-Anchor" href="#assert"></a> assert</h4>
<p>assert是运行期断言，它用来发现运行期间的错误，不能提前到编译期发现错误，也不具有强制性，也谈不上改善编译信息的可读性，既然是运行期检查，对性能当然是有影响的，所以经常在发行版本中，assert都会被关掉。</p>
<h4 id="error"><a class="markdownIt-Anchor" href="#error"></a> #error</h4>
<p>#error可看做预编译期断言，甚至都算不上断言，仅仅能在预编译时显示一个错误信息，它能做的不多，可以配合#ifdef/ifndef参与预编译的条件检查，由于它无法获得编译信息，当然就做不了更进一步分析了。</p>
<h3 id="noexcept"><a class="markdownIt-Anchor" href="#noexcept"></a> noexcept</h3>
<p>C++98中，在函数声明时，我们使用throw指定一个函数可以抛出异常的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getVal</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">char</span>*, <span class="keyword">double</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="keyword">int</span> m_val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上述函数的声明指定了该函数可以抛出异常的类型：</p>
<ul>
<li>getVal() 可以抛出任何异常(默认)；</li>
<li>display() 不可以抛出任何异常；</li>
<li>setVal() 只可以抛出char* 和 double类型异常。</li>
</ul>
<p>从功能上来说，C<ins>98中的异常处理机制完全能满足我们的需要，正确的处理异常。<br>
然而，编译器为了遵守C</ins>语言标准，在编译时，只检查部分函数的异常规格（exception specification）。<br>
<strong>注意：</strong> exception specification: 函数名字后面的throw表达式，或者noexcept</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declaration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funAny</span><span class="params">(<span class="keyword">void</span>)</span></span>;                   <span class="comment">//May throw ANY exception.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">void</span>)</span> <span class="title">throw</span> <span class="params">(<span class="built_in">std</span>::out_of_range)</span></span>; <span class="comment">// May throw only std::out_of_range.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// implementation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">void</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::out_of_range)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    funAny();   <span class="comment">// Compiler does not check if</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...         <span class="comment">// funAny(), or one of its </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;               <span class="comment">// subordinates, only throws std::out_of_range!</span></span></pre></td></tr></table></figure>
<p>程序在运行时，如果funAny()抛出一个异常，<br>
但是它的类型不是std::out_of_range， 异常处理机制将调用std::unexpected()（该函数自己也可能抛出异常），<br>
这个函数默认情况下会调用std::teminate()。</p>
<p>编译器在编译时能过做的检测非常有限，因此在C++11中异常声明被简化为以下两种情况：</p>
<ul>
<li>函数可以抛出任何异常(和之前的默认情况相同)</li>
<li>函数不可以抛出任何异常</li>
</ul>
<p>在C++11中，声明一个函数不可以抛出任何异常使用关键字noexcept。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mightThrow</span><span class="params">()</span></span>; <span class="comment">// 可以抛出任意异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doesNotThrow</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">//不抛出任何异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">old_stytle</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_style</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span></pre></td></tr></table></figure>
<p>它们的区别在于程序运行时的行为和编译器优化的结果。<br>
使用throw()， 如果函数抛出异常，异常处理机制会进行栈回退，寻找(一个或多个）catch语句。<br>
此时，检测catch可以捕捉的类型，如果没有匹配的类型，std::unexpected()会被调用。<br>
但是std::unexpected()本身也可能抛出异常。<br>
如果std::unexpected()抛出的异常对于当前的异常规格是有效的，<br>
异常传递和栈回退会像以前那样继续进行。<br>
这意味着，如果使用throw， 编译器几乎没有机会做优化。<br>
事实上，编译器甚至会让代码变得更臃肿、庞大：</p>
<ol>
<li>栈必须被保存在回退表中；</li>
<li>所有对象的析构函数必须被正确的调用（按照对象构建相反的顺序析构对象）；</li>
<li>编译器可能引入新的传播栅栏（propagation barriers）、引入新的异常表入口，使得异常处理的代码变得更庞大；</li>
<li>内联函数的异常规格（exception specification）可能无效的。</li>
</ol>
<p>当使用noexcept时，std::teminate()函数会被立即调用，而不是调用std::unexpected();<br>
因此，在异常处理的过程中，编译器不会回退栈，这为编译器的优化提供了更大的空间。</p>
<p>简而言之，如果你知道你的函数绝对不会抛出任何异常，应该使用noexcept, 而不是throw().</p>
<h3 id="仿函数-functor"><a class="markdownIt-Anchor" href="#仿函数-functor"></a> 仿函数 functor</h3>
<p>仿函数（functor）又称为函数对象（function object），是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// this is a functor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_x</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	add_x(<span class="keyword">int</span> x) : x(x) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// usage:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">add_x <span class="title">add42</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// create an instance of the functor class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = add42(<span class="number">8</span>);  <span class="comment">// and "call" it</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">assert(i == <span class="number">50</span>);   <span class="comment">// and it added 42 to its argument</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in; <span class="comment">// assume this contains a bunch of values)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Pass a functor to std::transform, which calls the functor on every element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// in the input sequence, and stores the result to the output sequence</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(in.begin(), in.end(), out.begin(), add_x(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">assert(out[i] == in[i] + <span class="number">1</span>); <span class="comment">// for all i</span></span></pre></td></tr></table></figure>
<p>仿函数的优点</p>
<ul>
<li>迭代和计算逻辑分离<br>
使用仿函数可以使迭代和计算分离开来。因而你的functor可以应用于不同场合，在STL的算法中就大量使用了functor，下面是STL中for_each中使用functor的示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sum(<span class="keyword">int</span> * t):total(t)&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> * total;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> element)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       *total+=element;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">sum <span class="title">s</span><span class="params">(&amp;total)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::for_each(arr, arr+<span class="number">6</span>, s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// prints total = 15;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>参数可设置<br>
可以很容易通过给仿函数（functor）设置参数，来实现原本函数指针才能实现的功能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateAverageOfPowers</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CalculateAverageOfPowers(<span class="keyword">float</span> p) : acc(<span class="number">0</span>), n(<span class="number">0</span>), p(p) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; acc += <span class="built_in">pow</span>(x, p); n++; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getAverage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> acc / n; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> acc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>   n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这个仿函数的功能是求给定值平方或立方运算的平均值。只需要这样来声明一个对象即可：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">CalculateAverageOfPowers <span class="title">my_cal</span><span class="params">(<span class="number">2</span>)</span></span>;</span></pre></td></tr></table></figure>
<ul>
<li>有状态<br>
与普通函数另一个区别是仿函数（functor）是有状态的，所以可以进行诸如下面这种操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CalculateAverage avg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">avg = <span class="built_in">std</span>::for_each(dataA.begin(), dataA.end(), avg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">avg = <span class="built_in">std</span>::for_each(dataB.begin(), dataB.end(), avg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">avg = <span class="built_in">std</span>::for_each(dataC.begin(), dataC.end(), avg);</span></pre></td></tr></table></figure>
<ul>
<li>性能<br>
前例中 <code>std::transform(in.begin(), in.end(), out.begin(), add_x(1));</code><br>
编译器可以准确知道std::transform需要调用哪个函数（add_x::operator）。这意味着它可以内联这个函数调用。而如果使用函数指针，编译器不能直接确定指针指向的函数，而这必须在程序运行时才能得到并调用。<br>
一个例子就是比较std::sort 和qsort ，STL的版本一般要快5-10倍。</li>
</ul>
<p><strong>总结</strong>:前述3点都可以使用传统的函数和指针实现，但是用仿函数（functor）可以让这种实现变的更加简单</p>
<h4 id="仿函数-vs-指针函数"><a class="markdownIt-Anchor" href="#仿函数-vs-指针函数"></a> 仿函数 VS 指针函数</h4>
<p>假设有一个vector&lt;string&gt;，你的任务是统计长度小于5的string的个数，如果使用count_if函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LengthIsLessThanFive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> str.length() &lt; <span class="number">5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = count_if(vec.begin(), vec.end(), LengthIsLessThanFive);</span></pre></td></tr></table></figure>
<p>其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LenthIsLessThan</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span> str.length()&lt;len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：</p>
<blockquote>
<p>count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。</p>
</blockquote>
<p>所以问题来了，怎么样找到以上两个函数的一个折中的解决方案呢？<br>
这个问题其实可以归结于一个data flow的问题，要设计这样一个函数，使其能够access这个特定的length值，回顾我们已有的知识，有三种解决方案可以考虑：</p>
<ol>
<li>函数的局部变量<br>
局部变量不能在函数调用中传递，而且caller无法访问。</li>
<li>函数的参数<br>
多个参数不适用于count_if</li>
<li>全局变量<br>
我们可以将长度阈值设置成一个全局变量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxLength;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LengthIsLessThan</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span> str.length() &lt; maxLength;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = count_if(vec.begiin(), vec.end(), LengthIsLessThan);</span></pre></td></tr></table></figure>
<p>这段代码看似很不错，实则不符合规范，尤其是不优雅<br>
1. 容易出错<br>
必须先初始化maxLength的值，才能继续接下来的工作，如果忘了，则可能无法得到正确答案。<br>
此外，变量maxLength和函数LengthIsLessThan之间是没有必然联系的，编译器无法确定在调用该函数前是否将变量初始化。<br>
2. 不可扩展<br>
每遇到一个类似的问题就新建一个全局变量，很容易引起命名空间污染（namespace polution）的问题；当范围域内有多个变量时，我们用到的可能不是我们想要的那个。<br>
3. 应该尽可能减少使用全局变量</p>
<p>我们的初衷是想设计一个unary function，使其能做binary function的工作，这看起来并不容易，但是仿函数能解决这个问题。</p>
<p><strong>仿函数其实是上述解决方案中的第四种方案：成员变量。</strong></p>
<p>成员函数可以很自然的访问成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterThan</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        explicit ShorterThan(int maxLength) : length(maxLength) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> str.length() &lt; length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">count_if(myVector.begin(), myVector.end(), ShorterThan(length));<span class="comment">//直接调用即可</span></span></pre></td></tr></table></figure>
<h4 id="仿函数-stdbind-实现闭包"><a class="markdownIt-Anchor" href="#仿函数-stdbind-实现闭包"></a> 仿函数 std::bind 实现闭包</h4>
<p>std::bind ，仿函数functor 都可以用于实现闭包功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyFunctor(<span class="keyword">int</span> temp): round(temp) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;<span class="keyword">return</span> temp + round; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> round;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytest</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> round = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">MyFunctor <span class="title">f</span><span class="params">(round)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result: "</span> &lt;&lt; f(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// operator()(int temp)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mytest();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(<span class="string">"pause"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytest</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="number">1</span>, <span class="number">2</span>)();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="built_in">std</span>::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// std::placeholders 表示的是占位符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// std::placeholders::_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="number">2</span>, <span class="built_in">std</span>::placeholders::_1)(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="number">2</span>, <span class="built_in">std</span>::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::bind(func, <span class="built_in">std</span>::placeholders::_3, <span class="built_in">std</span>::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//std::bind(func, 2, std::placeholders::_2)(1); // err, 调用时没有第二个参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mytest();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(<span class="string">"pause"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i; <span class="comment">// 非静态成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123; <span class="comment">// 非静态成员函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytest</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test obj; <span class="comment">// 创建对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 绑定非静态成员函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = <span class="built_in">std</span>::bind(&amp;Test::func, &amp;obj, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 输出: 1 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    obj.i = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 绑定非静态成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> &amp;()&gt; f2 = <span class="built_in">std</span>::bind(&amp;Test::i, &amp;obj);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f2() = <span class="number">123</span>;  <span class="comment">// obj.i = 123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"obj.i: "</span> &lt;&lt; obj.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mytest();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(<span class="string">"pause"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="自定义字面量-user-defined-literals"><a class="markdownIt-Anchor" href="#自定义字面量-user-defined-literals"></a> 自定义字面量 user-defined literals</h3>
<p>c++11支持为内置类型提供新的自定义字面量的形式，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">“Hi!”s <span class="comment">// std::string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1.2</span>i <span class="comment">// imaginary of Complex</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10110000b</span> <span class="comment">// binary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span>s <span class="comment">// 10 seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.0</span>km <span class="comment">// kilometers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">12345678901234567890123456789</span>x <span class="comment">// extentend-precision</span></span></pre></td></tr></table></figure>
<p>这种形式是通过重载operator “”（双引号）后缀运算符实现的（称为literal operator，字面量运算符）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span><span class="string">""</span>s(<span class="keyword">const</span> <span class="keyword">char</span> * sz, <span class="keyword">size_t</span> n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>&#123;sz, n&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="keyword">operator</span><span class="string">""</span>i(<span class="keyword">double</span> d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &#123;<span class="number">0.0</span>, d&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> str = <span class="string">"test literal"</span>s;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cp = <span class="number">1.6</span>i;</span></pre></td></tr></table></figure>
<p>这种形式的后缀重载可以使用任意标准未规定的后缀，但是不能重载或重定义已经使用的后缀形式，比如前面提到的d、u、f、l等后缀。operator&quot;&quot;支持四种格式的重载:</p>
<ul>
<li>
<p>整型字面量<br>
重载literal运算符时使用unsigned long long、const char *、或者模板literal运算符，比如：123m，1234567890123456789x。</p>
</li>
<li>
<p>浮点型字面量<br>
重载literal运算符时使用long double、const char *、或者模板literal运算符，比如：10.0s, 4567.891234567x。</p>
</li>
<li>
<p>字符串字面量<br>
重载literal运算符时使用(const char*, size_t)参数，比如：&quot;string&quot;s， “Foobar”_path。</p>
</li>
<li>
<p>字符<br>
重载literal运算符时使用char, wchar_t, char16_t, char32_t参数，比如： ‘f’_runic, u’BEEF’_w。</p>
</li>
</ul>
<p><strong>注意c++标准规定保留所有非下划线开头的字面量后缀形式，重载literal运算符时建议使用下划线开头。</strong><br>
如果使用了非下划线开头的literal运算符重载形式，在GCC编译器中也会有警告信息。</p>
<p>c<ins>11中提供literal运算符的重载形式，给字面常量的处理带来很大的便利性和可定制化处理，比如可以在c</ins>中支持任意进制的数据输入、支持大数处理（不用通过先保存为字符串，然后预处理的机制）等。</p>
<p>扩展阅读：<a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_blank" rel="noopener">User-defined literals</a></p>
<h3 id="显式类型转换运算符-explicit-conversion-operators"><a class="markdownIt-Anchor" href="#显式类型转换运算符-explicit-conversion-operators"></a> 显式类型转换运算符 explicit conversion operators</h3>
<p>C<ins>中，有时可以将构造函数用作自动类型转换函数。但这种自动特性并非总是合乎要求的，有时会导致意外的类型转换。因此C</ins>11新增了关键字explicit，用于关闭这种自动特性。</p>
<blockquote>
<p>即被explicit关键字修饰的类构造函数，不能进行自动地隐式类型转换，只能显式地进行类型转换。</p>
</blockquote>
<p><strong>注意：只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行隐式类型转换。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码1 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Demo();    　　　　　　　　　　　　   <span class="comment">// 构造函数1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Demo(<span class="keyword">double</span> a);　　　　　　　　　　 <span class="comment">// 示例代码2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//explicit Demo(double a)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Demo(<span class="keyword">int</span> a,<span class="keyword">double</span> b);　　　　　　　   <span class="comment">// 示例代码3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Demo(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">10</span>,<span class="keyword">double</span> c=<span class="number">1.6</span>);　　<span class="comment">// 示例代码4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Demo();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<ul>
<li>构造函数1没有参数，无法进行类型转换！</li>
<li>构造函数2有一个参数，可以进行类型转换<br>
如：Demo test; test = 12.2;这样的调用就相当于把12.2隐式转换为Demo类型。</li>
<li>构造函数3有两个参数，且无默认值，故无法使用类型转换！</li>
<li>构造函数4有3个参数，其中两个参数有默认值，故可以进行隐式转换<br>
如：Demo test;test = 10;</li>
<li>如果使用了explicit关键字，则无法进行隐式转换。<br>
即：Demo test;test = 12.2;是无效的！但是我们可以进行显示类型转换，如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Demo test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">test = Demo(<span class="number">12.2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">test = (Demo)<span class="number">12.2</span>;</span></pre></td></tr></table></figure>
<p>扩展阅读:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/explicit" target="_blank" rel="noopener">cppreference-explicit specifier</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/user-defined-type-conversions-cpp?redirectedfrom=MSDN&amp;view=vs-2019" target="_blank" rel="noopener">MSDN-User-Defined Type Conversions</a></li>
</ul>
<h3 id="constexpr"><a class="markdownIt-Anchor" href="#constexpr"></a> constexpr</h3>
<p>C++11 引入 constexpr 生成常量表达式。</p>
<p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。</p>
<p>为了使函数获取编译时计算的能力，你必须指定constexpr关键字到这个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x * y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 将在编译时计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = multiply( <span class="number">10</span>, <span class="number">10</span> );</span></pre></td></tr></table></figure>
<p>constexpr允许函数被应用在以前调用宏的所有场合。例如，你想要一个计算数组size的函数，size是10的倍数。如果不用constexpr，你需要创建一个宏或者使用模板，因为你不能用函数的返回值去声明数组的大小。但是用constexpr，你就可以调用一个constexpr函数去声明一个数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getDefaultArraySize</span> <span class="params">(<span class="keyword">int</span> multiplier)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * multiplier;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[ getDefaultArraySize( <span class="number">3</span> ) ];</span></pre></td></tr></table></figure>
<h4 id="constexpr-实现字符串-switch"><a class="markdownIt-Anchor" href="#constexpr-实现字符串-switch"></a> constexpr 实现字符串 switch</h4>
<ol>
<li>定义一个hash函数，计算出字符串的hash值，将字符串转换为1个整数。</li>
<li>利用c++11自定义文字常量的语法，定义一个constexpr函数，switch的case标签处调用constexpr函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">uint64_t</span> <span class="keyword">hash_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">hash_t</span> prime = <span class="number">0x100000001B3</span>ull;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">hash_t</span> basis = <span class="number">0xCBF29CE484222325</span>ull;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">hash_t</span> hash_(<span class="keyword">char</span> <span class="keyword">const</span>* str)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">hash_t</span> ret&#123;basis&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(*str)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ret ^= *str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ret *= prime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ret;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//利用递归得到了与上面hash_函数得到的同样值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用constexpr声明了函数，因此编译器可以在编译期得出一个字符串的hash值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> hash_t <span class="title">hash_compile_time</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* str, <span class="keyword">hash_t</span> last_value = basis)</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> *str ? hash_compile_time(str+<span class="number">1</span>, (*str ^ last_value) * prime) : last_value; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ** 编译器就可以得到的整型常量，自然可以放到switch的case标签处了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ** hash_compile_time("first")是编译器计算出来的一个常量，因此可以用作case标签；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ** 而且如果出现了hash值冲突，编译器回给出错误提示。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_switch2</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* str)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span>(hash_(str))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    case hash_compile_time("first"):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1st one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    case hash_compile_time("second"):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    case hash_compile_time("third"):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3rd one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Default..."</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//利用自定义文字常量，重载一个operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">operator</span> <span class="string">""</span> _hash(<span class="keyword">char</span> <span class="keyword">const</span>* p, <span class="keyword">size_t</span>) </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> hash_compile_time(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用“_hash”作为自定义文字常量的后缀，编译器调用我们重载的operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_switch</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* str)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span>(hash_(str))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"first"</span>_hash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1st one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"second"</span>_hash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"third"</span>_hash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3rd one"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Default..."</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="default-deleted"><a class="markdownIt-Anchor" href="#default-deleted"></a> default deleted</h3>
<p>C++ 的类有四个特殊成员函数，它们分别是：</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符。</li>
</ul>
<p>这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。</p>
<p>如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。但是，如果程序员为类显式的自定义了非默认构造函数，编译器将不再会为它隐式的生成默认构造函数。</p>
<p><strong>手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低</strong>。</p>
<h4 id="default"><a class="markdownIt-Anchor" href="#default"></a> default</h4>
<p>C++11 标准引入：defaulted 函数。程序员只需在函数声明后加上__“=default;”__，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体。</p>
<ul>
<li>Defaulted 函数特性仅适用于类的__特殊成员函数__，且该特殊成员函数__没有默认参数__。</li>
<li>Defaulted 函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X() = <span class="keyword">default</span>;      <span class="comment">//Inline defaulted 默认构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X(<span class="keyword">const</span> X&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~X() = <span class="keyword">default</span>;     <span class="comment">//Inline defaulted 析构函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">X::X(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;   <span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;     <span class="comment">//Out-of-line defaulted 拷贝赋值操作符</span></span></pre></td></tr></table></figure>
<h4 id="deleted"><a class="markdownIt-Anchor" href="#deleted"></a> deleted</h4>
<p>C++11 标准引入：deleted 函数。程序员只需在函数声明后加上__“=delete;”__，就可将该函数禁用。<br>
我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 deleted 函数，就可以禁止类 X 对象之间的拷贝和赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X x1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X x2=x1;   <span class="comment">// 错误，拷贝构造函数被禁用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X x3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x3=x1;     <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>defaulted 函数特性规定了只有类的特殊成员函数才能被声明为 defaulted 函数</li>
<li>deleted 函数特性没有此限制。类的成员函数，非成员函数，即普通函数也可以被声明为 deleted 函数</li>
<li>deleted 函数必须在函数第一次声明的时候将其声明，否则编译器会报错。<br>
即对类的成员函数而言，deleted 函数必须在类体里（inline）定义，不能在类体外（out-of-line）定义</li>
</ul>
<p>Deleted 函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。在清单 12 中，假设类 X 只支持参数为双精度浮点数 double 类型的转换构造函数，而不支持参数为整数 int 类型的转换构造函数，则可以将参数为 int 类型的转换构造函数声明为 deleted 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X(<span class="keyword">int</span>) = <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X(<span class="keyword">double</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//X *pa = new X(1);     //错误,操作符被禁用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//X *pb = new X[10];    //错误,操作符被禁用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//x.add(1, 4);          //错误,已被禁止</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x.add(<span class="number">1.0</span>, <span class="number">4.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>值得一提的是，在上述示例中，虽然 add(int, int)函数被禁用了，但是禁用的仅是函数的定义，即该函数不能被调用。但是函数标示符 add 仍是有效的，在名字查找和函数重载解析时仍会查找到该函数标示符。</p>
<p><strong>如果编译器在解析重载函数时，解析结果为 deleted 函数，则会出现编译错误。</strong></p>
<h3 id="重载-override"><a class="markdownIt-Anchor" href="#重载-override"></a> 重载 Override</h3>
<h4 id="公有继承"><a class="markdownIt-Anchor" href="#公有继承"></a> 公有继承</h4>
<p>公有继承包含两部分：</p>
<ul>
<li>“函数接口” (interface)</li>
<li>“函数实现” (implementation)</li>
</ul>
<p>如 Shape 类中，三个成员函数，表示三种继承方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">// 1) 纯虚函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;  <span class="comment">// 2) 普通虚函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ObjectID</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 3) 非虚函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123; ... &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123; ... &#125;;</span></pre></td></tr></table></figure>
<h5 id="纯虚函数-pure-virtual"><a class="markdownIt-Anchor" href="#纯虚函数-pure-virtual"></a> 纯虚函数 (pure virtual)</h5>
<p>纯虚函数，继承的是基类中，成员函数的接口，且要在派生类中，重写成员函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ps1-&gt;Draw(); <span class="comment">// calls Rectangle::Draw</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ps2-&gt;Draw(); <span class="comment">// calls Ellipse::Draw</span></span></pre></td></tr></table></figure>
<p>调用基类的 Draw()，须加 类作用域操作符 ::</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps1-&gt;Shape::Draw(); <span class="comment">// calls Shape::draw</span></span></pre></td></tr></table></figure>
<h5 id="普通虚函数"><a class="markdownIt-Anchor" href="#普通虚函数"></a> 普通虚函数</h5>
<p>普通虚函数，会在基类中，定义一个缺省的实现 (default implementation)，表示继承的是基类成员函数接口和缺省实现，由派生类选择是否重写该函数。</p>
<p>实际上，允许普通虚函数 同时继承接口和缺省实现是危险的。 如下, ModelA 和 ModelB 是 Airplane 的两种飞机类型，且二者的飞行方式完全相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span></pre></td></tr></table></figure>
<p>这是典型的面向对象设计，两个类共享一个特性 – Fly，则 Fly 可在基类中实现，并由两个派生类继承之</p>
<p>现增加另一个飞机型号 ModelC，其飞行方式与 ModelA，ModelB 不相同，如果不小心忘记在 ModelC 中重写新的 Fly 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ... <span class="comment">// no fly function is declared</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>则调用 ModelC 中的 fly 函数，就是调用 Airplane::Fly，但是 ModelC 的飞行方式和缺省的并不相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Airplane *pa = <span class="keyword">new</span> ModelC;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pa-&gt;Fly(Qingdao); <span class="comment">// calls Airplane::fly!</span></span></pre></td></tr></table></figure>
<p>即前面所说的，普通虚函数同时继承接口和缺省实现是危险的，最好是基类中实现缺省行为 (behavior)，但只有在派生类要求时才提供该缺省行为。</p>
<h6 id="纯虚函数-缺省实现"><a class="markdownIt-Anchor" href="#纯虚函数-缺省实现"></a> 纯虚函数 + 缺省实现</h6>
<p>因为是纯虚函数，所以只有接口被继承，其缺省的实现不会被继承。派生类要想使用该缺省的实现，必须显式的调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span> </span>= <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Airplane::Fly(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// a pure virtual function default code for flying an airplane to the given destination</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span> </span>&#123; Airplane::Fly(destination); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>这样在派生类 ModelC 中，即使一不小心忘记重写 Fly 函数，也不会调用 Airplane 的缺省实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ModelC::Fly(<span class="keyword">const</span> <span class="built_in">string</span>&amp; destination)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// code for flying a ModelC airplane to the given destination</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h6 id="override"><a class="markdownIt-Anchor" href="#override"></a> Override</h6>
<p>可以看到，上面问题的关键就在于，一不小心在派生类 ModelC 中忘记重写 fly 函数，C++11 中使用关键字 override，可以避免这样的“一不小心”</p>
<h5 id="非虚函数"><a class="markdownIt-Anchor" href="#非虚函数"></a> 非虚函数</h5>
<p>非虚成员函数没有 virtual 关键字，表示派生类不但继承了接口，而且继承了一个强制实现 (mandatory implementation)</p>
<p>既然继承了一个强制的实现，则在派生类中，无须重新定义 (redefine) 继承自基类的成员函数，如下使用指针调用 ObjectID 函数，则都是调用的 Shape::ObjectID()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rectangel rc; <span class="comment">// rc is an object of type Rectangle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Shape *pB = &amp;rc; <span class="comment">// get pointer to rc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pB-&gt;ObjectID(); <span class="comment">// call ObjectID() through pointer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Rectangle *pD = &amp;rc; <span class="comment">// get pointer to rc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pD-&gt;ObjectID(); <span class="comment">// call ObjectID() through pointer</span></span></pre></td></tr></table></figure>
<p>如果在派生类中重新定义了继承自基类的成员函数 ObjectID 呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangel</span> :</span> <span class="keyword">public</span> Shape &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ObjectID</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// hides Shape::ObjectID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pB-&gt;ObjectID(); <span class="comment">// calls Shape::ObjectID()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pD-&gt;ObjectID(); <span class="comment">// calls Rectagle::ObjectID()</span></span></pre></td></tr></table></figure>
<p>此时，派生类中重新定义的成员函数会 “隐藏” (hide) 继承自基类的成员函数</p>
<p>这是因为非虚函数是 “静态绑定” 的，pB 被声明的是 Shape* 类型的指针，则通过 pB 调用的非虚函数都是基类中的，既使 pB 指向的是派生类</p>
<p>与“静态绑定”相对的是虚函数的“动态绑定”，即无论 pB 被声明为 Shape* 还是 Rectangle* 类型，其调用的虚函数取决于 pB 实际指向的对象类型。</p>
<h4 id="override-2"><a class="markdownIt-Anchor" href="#override-2"></a> Override</h4>
<p>以重写虚函数时，容易犯的四个错误为例，详细阐述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// is not declared virtual in Base</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;        <span class="comment">// declared const in Base, but not in Derived.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;    <span class="comment">// takes an int in Base, but an unsigned int in Derived</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;    <span class="comment">// is lvalue-qualified in Base, but rvalue-qualified in Derived.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：</p>
<ol>
<li>虚：基类中，成员函数声明为虚拟的 (virtual)</li>
<li>容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容</li>
<li>同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同</li>
</ol>
<p>如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错。</p>
<p>C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>即使不小心漏写了虚函数重写的某个苛刻条件，也可以通过编译器的报错，快速改正错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span> override</span>;  <span class="comment">// adding "virtual" is OK, but not necessary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span> override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; override</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> override</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<ol>
<li>公有继承
<ol>
<li>纯虚函数         =&gt; 继承的是：接口 (interface)</li>
<li>普通虚函数     =&gt; 继承的是：接口 + 缺省实现 (default implementation)</li>
<li>非虚成员函数  =&gt; 继承的是：接口 + 强制实现 (mandatory implementation)</li>
</ol>
</li>
<li>不要重新定义一个继承自基类的非虚函数 (never redefine an inherited non-virtual function)</li>
<li>在声明需要重写的函数后，加关键字 <strong>override</strong></li>
</ol>
<h3 id="类型推导-auto-decltype"><a class="markdownIt-Anchor" href="#类型推导-auto-decltype"></a> 类型推导 auto、decltype</h3>
<h4 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h4>
<p>c<ins>11之前，auto、register作为存储类型的指示符存在，一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。c</ins>11标准中 register 被弃用，auto 语义重定义。</p>
<p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//without auto</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = vec.cbegin();  itr != vec.cend();  ++ itr)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> itr = vec.cbegin(); itr != vec.cend(); ++itr);</span></pre></td></tr></table></figure>
<p>auto <strong>不能用于函数传参</strong>，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span></span>;</span></pre></td></tr></table></figure>
<p>auto <strong>不能用于推导数组类型</strong></p>
<h4 id="decltype"><a class="markdownIt-Anchor" href="#decltype"></a> decltype</h4>
<p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译器分析表达式并得到它的类型，却不实际计算表达式的值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) z;</span></pre></td></tr></table></figure>
<h4 id="拖尾返回类型-auto-与-decltype-配合"><a class="markdownIt-Anchor" href="#拖尾返回类型-auto-与-decltype-配合"></a> 拖尾返回类型、auto 与 decltype 配合</h4>
<p>auto 推导函数的返回类型。考虑这样一个例子加法函数的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//before c++11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型<br>
C++11 中这个问题得到解决。但不是通过下面这种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y);</span></pre></td></tr></table></figure>
<p>这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做__拖尾返回类型__（<strong>trailing return type</strong>），利用 auto 关键字将返回类型后置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>C++14 甚至可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="区间迭代-iterator-by-for"><a class="markdownIt-Anchor" href="#区间迭代-iterator-by-for"></a> 区间迭代 Iterator by for</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">5</span>, <span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = arr.begin(); i != arr.end(); ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//==&gt; convert to </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="初始化列表-initialization-list"><a class="markdownIt-Anchor" href="#初始化列表-initialization-list"></a> 初始化列表 initialization list</h3>
<h4 id="initialization-list"><a class="markdownIt-Anchor" href="#initialization-list"></a> initialization list</h4>
<p>C++11 提供了统一的语法来初始化任意的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">int</span> _a, <span class="keyword">float</span> _b): a(_a), b(_b) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">A a &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;;    <span class="comment">// 统一的初始化语法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">B b &#123;<span class="number">2</span>, <span class="number">2.2</span>&#125;;</span></pre></td></tr></table></figure>
<p>C++11 初始化列表的概念也绑定到了类型上，即 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span></pre></td></tr></table></figure>
<h4 id="成员变量快速初始化"><a class="markdownIt-Anchor" href="#成员变量快速初始化"></a> 成员变量快速初始化</h4>
<p>C++98支持就地声明成员变量，在类中使用 “=” 来初始化静态成员常量。</p>
<ul>
<li>类中的该静态成员变量需要满足“常量性”，如果不满足静态变量常量性，则不可以进行就地声明。</li>
<li>需要满足该静态常量成员必须是：整型或者是枚举类型。</li>
</ul>
<p>C<ins>11标准除了支持C</ins>98中的就地声明初始化方式外，还支持非静态成员变量的初始化方式有多种。即除了“初始化列表”之外，C++11还允许使用 “等号=”和 “花括号{}”来进行就地的非静态成员变量初始化操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base(<span class="keyword">int</span> _a,<span class="keyword">double</span> _b, <span class="keyword">float</span> _c):a(_a),b(_b),c(_c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base(<span class="keyword">const</span> Base&amp;) = <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Base&amp;) = <span class="keyword">delete</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Base()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DisplayMem</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a: "</span>&lt;&lt;a&lt;&lt;<span class="string">", b: "</span>&lt;&lt;b&lt;&lt; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="string">",c: "</span>&lt;&lt;c&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;        <span class="comment">//c++11新特性，使用等号“=”初始化非静态常量的成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> b&#123;<span class="number">2.0</span>&#125;; <span class="comment">//c++11新特性，使用花括号“&#123;&#125;”初始化非静态常量的成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> c&#123;<span class="number">3.0</span>&#125;;    <span class="comment">//c++11新特性，使用花括号“&#123;&#125;”初始化非静态常量的成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.DisplayMem();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意区别C<ins>98中使用（）初始化 和 C</ins>11 使用 {} 初始化的区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Human() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Human(<span class="keyword">int</span> _a):m_a(_a)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Human()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m_a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Man() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Man()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> f = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//std::string m_msg1("lxg"); //编译报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_msg2 = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"lxg"</span>);<span class="comment">//编译通过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_msg3&#123;<span class="string">"lxg"</span>&#125;; <span class="comment">//编译通过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Human h1 = Human(<span class="number">20</span>); <span class="comment">//编译通过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//Human h2(20); //编译报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Human h3&#123;<span class="number">20</span>&#125;; <span class="comment">//编译通过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="随机数-random"><a class="markdownIt-Anchor" href="#随机数-random"></a> 随机数 random</h3>
<p>随机数由生成器和分布器结合产生</p>
<blockquote>
<ol>
<li>生成器generator：能够产生离散的等可能分布数值(需要种子，不然每次生存的随机数都一样)</li>
<li>分布器distributions: 能够把generator产生的均匀分布值映射到其他常见分布，如<br>
1. 均匀分布uniform<br>
2. 正态分布normal<br>
3. 二项分布binomial<br>
4. 泊松分布poisson</li>
<li>种子：相当于外部传给随机数生成器的诱因。<br>
如果每次传入的种子一样，则每次生成的随机数还是一样</li>
</ol>
</blockquote>
<h4 id="default_random_engine"><a class="markdownIt-Anchor" href="#default_random_engine"></a> default_random_engine</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//std::default_random_engine engine();　　//没有设置种子，每次生存的随机数都一样</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">default_random_engine <span class="title">engine</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;　　<span class="comment">//设置了种子，每次种子都不一样</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dis(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dis(engine) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>default_random_engine 结合uniform_int_distribution生成的随机数是闭环[begin, end]<br>
如果嫌每次调用都要传入generator对象麻烦，可以使用std::bind，要包含头文件functional,以后就可以直接调用dice()产生复合均匀分布的随机数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//std::default_random_engine engine();　　//没有设置种子，每次生存的随机数都一样</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">default_random_engine <span class="title">engine</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dis(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dice = <span class="built_in">std</span>::bind(dis,generator);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dice() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<h4 id="random_device"><a class="markdownIt-Anchor" href="#random_device"></a> random_device</h4>
<p>标准库提供了一个非确定性随机数生成设备。在Linux的实现中,是读取/dev/urandom设备；Windows的实现是用rand_s(尴尬)<br>
random_device提供()操作符,用来返回一个min()到max()之间的一个数字。如果是Linux(Unix Like或者Unix)下，都可以使用这个来产生高质量的随机数，可以理解为真随机数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="built_in">std</span>::random_device rd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">20000</span>; ++n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　　　<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//结合：default_random_engine使用生成指定范围内的真随机数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_device rd; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">default_random_engine <span class="title">engine</span><span class="params">(rd())</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dis(<span class="number">10</span>, <span class="number">20</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> dice = <span class="built_in">std</span>::bind(dis, engine); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dice() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>
<p>C++11标准把随机数抽象成随机数引擎和分布两部分 。引擎用来产生随机数,分布产生特定分布的随机数(比如平均分布,正太分布等)。</p>
<p>C++11标准提供三种常用的引擎:<br>
linear_congruential_engine，mersenne_twister_engine和subtract_with_carry_engine。</p>
<p>第一种是线性同余算法,<br>
第二种是梅森旋转算法,<br>
第三种带进位的线性同余算法.</p>
<p>第一种是最常用的,而且速度也是非常快的; 第二种号称是最好的伪随机数生成器;第三种没用过…</p>
<p>随机数引擎接受一个整形参数当作种子，不提供的话,会使用默认值。推荐使用random_device来产生一个随机数当作种子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_device rd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mt() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="random-number-distributions"><a class="markdownIt-Anchor" href="#random-number-distributions"></a> random number distributions</h4>
<p>C++11标准提供各种各样的分布,不过我们经常用的比较少,比如平均分布,正太分布…使用也很简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_device rd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dis(<span class="number">1</span>, <span class="number">6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10</span>; ++n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dis(gen) &lt;&lt; <span class="string">' '</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//正太分布</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_device rd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// values near the mean are the most likely</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// standard deviation affects the dispersion of generated values from the mean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::normal_distribution&lt;&gt; d(<span class="number">5</span>,<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++hist[<span class="built_in">std</span>::round(d(gen))];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : hist) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;&lt; p.first &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p.second/<span class="number">200</span>, <span class="string">'*'</span>) &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="类型特征-type-traits"><a class="markdownIt-Anchor" href="#类型特征-type-traits"></a> 类型特征 type traits</h3>
<p>C++11标准中通过模板元基础库type_traits可以实现在编译期计算、查询、判断、转换和选择，增强了泛型编程的能力，也增强了程序的弹性，使得我们在编译期就能做到优化改进甚至排错，能进一步提高代码质量。</p>
<p>定义了一个名为is_pod的函数模板。该函数模板只是type_traits中模板类is_pod的简单包装。通过该函数，我们可以判断一个类型的数据是否为POD类型的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">is_pod</span><span class="params">(T)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::is_pod&lt;T&gt;::value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_pod(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>扩展阅读： <a href="https://en.cppreference.com/w/cpp/types" target="_blank" rel="noopener">C++111预定义Type traits</a>。</p>
<p>除去判断类型的特性，type_traits 标准库中我们也可以找到is_same这样的比较两个类型是否相等的类模板，以及enable_if这样的根据bool值选择类型的类模板。</p>
<p>从实现上讲，这些Type Traits通常是通过模板特化的元编程手段来完成的，比如在g++ 4.8.1的type_traits 头文件中我们可以找到以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// is_const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">is_const</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">   :</span> <span class="keyword">public</span> false_type &#123; &#125;;    <span class="comment">// 版本 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">is_const</span>&lt;_Tp const&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">   :</span> <span class="keyword">public</span> true_type &#123; &#125;;    <span class="comment">// 版本 2</span></span></pre></td></tr></table></figure>
<p>这里的false_type和true_type则是两个helper class，其定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// integral_constant</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_constant</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">static</span> <span class="keyword">constexpr</span> _Tp                  value = __v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">typedef</span> _Tp                           value_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">typedef</span> integral_constant&lt;_Tp, __v&gt;   type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> _Tp integral_constant&lt;_Tp, __v&gt;::value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// The type used as a compile-time boolean with true value.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt;     true_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// The type used as a compile-time boolean with false value.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt;    false_type;</span></pre></td></tr></table></figure>
<p>简单地说，true_type和false_type就是包含一个静态类成员value的类模板，其静态成员一个为true，一个为false。这样一来，通过特化，如果我们使用const类型作为模板is_const类型参数，则可以获得其常量静态成员value的值为true（1）。这是因为模板在实例化的时候选择了“版本2”。反过来，如果模板实例化到“版本1”，则value常量静态成员为false（0）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>并非所有的Type Traits都能够使用上面的元编程的手段来实现。C<ins>语言设计者在实践中进行了一些考量，让部分的Type Traits实现为了intrinsic，简单地说，就是要编译器辅助来计算出其值。我们可以看看g</ins>4.8.1中POD的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// is_pod</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_pod</span>:</span> <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, __is_pod(_Tp)&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;;</span></pre></td></tr></table></figure>
<p>这里的__is_pod就是编译器内部的intrinsic。事实上，在C<ins>11中，编译器必须辅助实现很多Type Traits的模板类，C</ins>11标准中这些Type Traits模板类如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_class</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_union</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_enum</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_polymorphic</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_empty</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_trivial_constructor</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_trivial_copy</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_trivial_assign</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_trivial_destructor</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_nothrow_constructor</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_nothrow_copy</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">has_nothrow_assign</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_pod</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_abstract</span>;</span></span></pre></td></tr></table></figure>
<p>总的来说，Type Traits就是通过元编程的手段，以及编译器的辅助来实现的</p>
<h3 id="模板增强"><a class="markdownIt-Anchor" href="#模板增强"></a> 模板增强</h3>
<h4 id="外部模板"><a class="markdownIt-Anchor" href="#外部模板"></a> 外部模板</h4>
<p>C++11之前，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。</p>
<p>C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;            <span class="comment">// 强行实例化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;  <span class="comment">// 不在该编译文件中实例化模板</span></span></pre></td></tr></table></figure>
<h4 id="尖括号"><a class="markdownIt-Anchor" href="#尖括号"></a> 尖括号 &gt;</h4>
<p>C++11 之前，&gt;&gt; 一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; wow;</span></pre></td></tr></table></figure>
<p>这在传统C<ins>编译器下是不能够被编译的，而 C</ins>11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</p>
<h4 id="类型别名模板-using"><a class="markdownIt-Anchor" href="#类型别名模板-using"></a> 类型别名模板 using</h4>
<p>C++11之前，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    U b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SuckType():a(value),b(value)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span></pre></td></tr></table></figure>
<p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">emplate &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span></pre></td></tr></table></figure>
<h4 id="默认模板参数"><a class="markdownIt-Anchor" href="#默认模板参数"></a> 默认模板参数</h4>
<p>我们定义一个加法函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>要使用 add，就必须每次都指定其模板参数的类型。<br>
在 C++11 中提供了一种便利，可以指定模板的默认参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="可变参数模板-variadic-template"><a class="markdownIt-Anchor" href="#可变参数模板-variadic-template"></a> 可变参数模板 Variadic Template</h3>
<h3 id="variadic-functions"><a class="markdownIt-Anchor" href="#variadic-functions"></a> Variadic Functions</h3>
<p>C99中使用宏进行可变参数编程: <code>va_list, va_start, va_end, va_arg</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDoubles</span> <span class="params">(<span class="keyword">int</span> n, ...)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	va_list vl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	va_start( vl , n );</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		<span class="keyword">double</span> val = va_arg( vl , <span class="keyword">double</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	va_end( vl );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>C++11 引入可变参数模板(Variadic Template)，模板编程更容易，且运行时更少占用内存。</p>
<p>在C++11之前，实现函数对象（functors）或元组(tuple)工具的时候局限性非常大，往往需要不断重复编写代码实现多参数支持。有了可变参数模板，代码可以得到大量简化。</p>
<h4 id="函数式"><a class="markdownIt-Anchor" href="#函数式"></a> 函数式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arguments&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SampleFunction</span><span class="params">(Arguments... parameters)</span></span>;</span></pre></td></tr></table></figure>
<h4 id="类式"><a class="markdownIt-Anchor" href="#类式"></a> 类式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arguments&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SampleClass(Arguments&amp;&amp;... parameters) : data&#123;<span class="built_in">std</span>::forward&lt;T&gt;(t)...&#125;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Element&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; a;  <span class="comment">// use it like this</span></span></pre></td></tr></table></figure>
<p>C++11 引入__parameter pack（参数包）__概念。<br>
在模板参数 Element 左边出现省略号 … ，就是表示 Element 是一个模板参数包（template type parameter pack）。<br>
在上面例子中，Element 表示是一连串任意的参数打成的一个包。<br>
第10行中，Element 就是 int, string这个参数的合集。<br>
不仅“类型”的模板参数（也就是typename定义的参数）可以这样做，非类型的模板参数也可以这样做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> PrimaryDimesion, <span class="keyword">unsigned</span>...Dimesions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">array</span> &#123;</span> <span class="comment">/**/</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 3, 3&gt; rotation_matrix; <span class="comment">//3x3 ratiation matrix</span></span></pre></td></tr></table></figure>
<p>C<ins>11标准中并没有提供 get_param&lt;1&gt;(Element)这样的内建&quot;参数抽取函数&quot;来访问和操作参数包。<br>
C</ins>11标准中使用 unpack 和类似函数重载的 “模板特化” 来抽取参数，通过 “递归” 类展开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; :</span> <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Head head;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* implementation */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* zero-tuple implementation */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>第1行声明了一个可以对应任意参数的tuple类.<br>
第2行到7行声明了这个类的一个部分特化，注意，这就是抽取参数的典型方法了。<br>
<img alt="variadic template analysis" data-src="/assets/2019/12/09/variadic_template_analysis.png"><br>
只说明一下针对 parameter pack 相对的另一个概念，模板参数后面带省略号 … 就是一个解包（unpack），会把这个参数所表示的参数列表解开后去匹配新的模板，或是进行模板展开。</p>
<p>C<ins>11新的标准库里，有很多个库都直接依赖于 variadic template 这个语言特性，比如，tuple，bind，function。 C</ins>11 的 FQA 和 Wikipedia 的例子都是“类型安全”的printf：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (*s) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'%'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (*(s + <span class="number">1</span>) == <span class="string">'%'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invalid format string: missing arguments"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, T value, Args... args)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (*s) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'%'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (*(s + <span class="number">1</span>) == <span class="string">'%'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// call even when *s == 0 to detect extra arguments</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">printf</span>(s + <span class="number">1</span>, args...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"extra arguments provided to printf"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="类继承"><a class="markdownIt-Anchor" href="#类继承"></a> 类继承</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... BaseClasses&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> :</span> BaseClasses... &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="sizeof运算符"><a class="markdownIt-Anchor" href="#sizeof运算符"></a> sizeof…运算符</h4>
<p>sizeof…(parameter_pack) 返回参数包元素个数</p>
<p><strong>扩展阅读:</strong> <a href="http://www.generic-programming.org/_dgregor/cpp/variadic-templates.html" target="_blank" rel="noopener">Variadic Templates for GCC</a></p>
<blockquote>
<p><strong>November 1, 2006:</strong> Version 1.5 of the variadic templates implementation in GCC is now available for download. This version introduces several bug fixes, new features, and one syntax change, including:<br>
The syntax for determining the length of a parameter pack has changed. Instead of sizeof(Args…) we now use sizeof…(Args), which should be less confusing.<br>
One can now expand parameter packs in base classes and initializers of those base classes, e.g.,<br>
template</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> :</span> <span class="keyword">public</span> Mixins... &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  myclass(<span class="keyword">const</span> Mixins&amp;... mixins)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    : Mixins(mixins)... &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<blockquote>
<p>One can now expand parameter packs in a throw specifier.<br>
One can now expand parameter packs in initializer list., e.g.,</p>
</blockquote>
<blockquote>
<p>template</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> Values&amp;... values)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	boost::any <span class="built_in">array</span>[<span class="keyword">sizeof</span>...(Values)] = &#123; values... &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="构造函数-constructor-delegate"><a class="markdownIt-Anchor" href="#构造函数-constructor-delegate"></a> 构造函数 Constructor Delegate</h3>
<h4 id="委托构造"><a class="markdownIt-Anchor" href="#委托构造"></a> 委托构造</h4>
<p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        value2 = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="继承构造"><a class="markdownIt-Anchor" href="#继承构造"></a> 继承构造</h4>
<p>继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。<br>
假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">int</span> i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等系列的构造函数版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等好多个和基类构造函数对应的构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>C++11的继承构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">int</span> i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...等等系列的构造函数版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">using</span> A::A;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//关于基类各构造函数的继承一句话搞定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;；</span></pre></td></tr></table></figure>
<p>如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p>
<h3 id="stdfunction-stdbind"><a class="markdownIt-Anchor" href="#stdfunction-stdbind"></a> std::function 、std::bind</h3>
<h4 id="可调用对象"><a class="markdownIt-Anchor" href="#可调用对象"></a> 可调用对象</h4>
<p>可调用对象几种定义：</p>
<ul>
<li>是一个函数指针</li>
<li>一个类成员函数指针</li>
<li>可被转换成函数指针的类对象</li>
<li>是一个具有operator()成员函数的类的对象</li>
</ul>
<p>C++11中提供了std::function和std::bind统一了可调用对象的各种操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// lambda表达式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a % b;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> denominator/divisor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上述三种可调用对象虽然类型不同，但是共享了一种调用形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></pre></td></tr></table></figure>
<p>std::function就可以将上述类型保存起来，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  a = add; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  b = mod ; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  c = divide();</span></pre></td></tr></table></figure>
<h4 id="stdfunction"><a class="markdownIt-Anchor" href="#stdfunction"></a> std::function</h4>
<p>std::function 是一个可调用对象包装器，是一个类模板，可以容纳__除类成员函数指针之外__的所有可调用对象 。它可以用统一的方式处理下列可调用对象并允许保存和延迟它们的执行</p>
<ul>
<li>函数</li>
<li>函数对象</li>
<li>函数指针</li>
</ul>
<p>定义格式：std::function&lt;函数类型&gt;。</p>
<p>std::function可以取代函数指针的作用，且比普通函数指针更加的灵活和便利，因为它可以延迟函数的执行，特别适合作为回调函数使用。</p>
<h4 id="stdbind"><a class="markdownIt-Anchor" href="#stdbind"></a> std::bind</h4>
<p>可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
<p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。<br>
std::bind主要有以下两个作用：</p>
<ul>
<li>将可调用对象和其参数绑定成一个防函数；</li>
<li>只绑定部分参数，减少可调用对象传入的参数。</li>
</ul>
<h5 id="stdbind绑定普通函数"><a class="markdownIt-Anchor" href="#stdbind绑定普通函数"></a> std::bind绑定普通函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,_1,<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;  <span class="comment">// output 5</span></span></pre></td></tr></table></figure>
<ul>
<li>bind的第一个参数是函数名，普通函数做实参时，会__隐式转换成函数指针__。<br>
因此std::bind (my_divide,_1,2)等价于std::bind (&amp;my_divide,_1,2)；</li>
<li>_1表示占位符，位于&lt;functional&gt;中，_<em>std:: placeholders::<em>1</em></em>；</li>
</ul>
<h5 id="stdbind绑定一个成员函数"><a class="markdownIt-Anchor" href="#stdbind绑定一个成员函数"></a> std::bind绑定一个成员函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Foo foo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, <span class="built_in">std</span>::placeholders::_1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f(<span class="number">5</span>); <span class="comment">// 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</li>
<li>必须显示的指定&amp;Foo::print_sum，因为编译器__不会将对象的成员函数隐式转换成函数指针__，所以必须在Foo::print_sum前添加_&amp;_；</li>
<li>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;foo；</li>
</ul>
<h5 id="stdbind绑定一个引用参数"><a class="markdownIt-Anchor" href="#stdbind绑定一个引用参数"></a> std::bind绑定一个引用参数</h5>
<p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">char</span> c)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    os &lt;&lt; s &lt;&lt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> os;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words&#123;<span class="string">"helo"</span>, <span class="string">"world"</span>, <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"C++11"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">ostringstream</span> os;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> c = <span class="string">' '</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for_each(words.begin(), words.end(), </span></pre></td></tr><tr><td class="code"><pre><span class="line">                   [&amp;os, c](<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; os.str() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">ostringstream</span> os1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ostream不能拷贝，若希望传递给bind一个对象，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 而不拷贝它，就必须使用标准库提供的ref函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    for_each(words.begin(), words.end(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   bind(print, ref(os1), _1, c));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; os1.str() &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="指向成员函数的指针"><a class="markdownIt-Anchor" href="#指向成员函数的指针"></a> 指向成员函数的指针</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f("</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">")\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g("</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">")\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Foo* foo1, Foo* foo2, <span class="keyword">void</span> (Foo::*fun)())</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (foo1-&gt;*fun)();  <span class="comment">// call fun on the object foo1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (foo2-&gt;*fun)();  <span class="comment">// call fun on the object foo2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Foo foo1&#123;<span class="number">1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Foo foo2&#123;<span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    apply(&amp;foo1, &amp;foo2, &amp;Foo::f);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    apply(&amp;foo1, &amp;foo2, &amp;Foo::g);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &amp;Foo::f；</li>
<li>fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即(foo1-&gt;*fun)();</li>
</ul>
<p>函数指针指向的是函数而非对象。和其他指针类型一样，函数指针指向某种特定类型。<br>
函数类型由它的返回值和参数类型决定，与函数名无关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">length_compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span></pre></td></tr></table></figure>
<ul>
<li>上述函数类型是：bool (const string &amp;, const string &amp;);</li>
<li>上述函数指针pf：bool (*pf)(const string &amp;, const string &amp;);</li>
</ul>
<p>当把函数名作为一个值使用时，该函数自动的转换成指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pf = length_compare &lt;=&gt; 等价于pf = &amp;length_compare</span></pre></td></tr></table></figure>
<ul>
<li>函数类型不能定义为形参，但是形参可以是指向函数的指针；</li>
<li>函数作为实参使用时，会自动的转换成函数指针；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span> <span class="comment">// Func是函数类型；</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span> <span class="comment">// FuncP是函数指针类型；</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(length_compare)</span> Func2  <span class="comment">// Func2是函数类型；</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(length_compare)</span> *Func2P <span class="comment">// Func2P是函数指针类型；</span></span></span></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意decltype(length_compare)返回的是函数类型，而不是函数指针类型；</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FTtype = <span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>); <span class="comment">//函数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pf)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//函数指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FTtype fn)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 编译器将其隐式转化成函数指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; fn(a,b) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="number">1</span>,<span class="number">2</span>,func);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(FTtype).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// FiiiE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(func).name() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// FiiiE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>(func)).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// FiiiE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(pf).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// PFiiiE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下面两个声明语句是同一个函数，因为编译器会自动的将FTtype 转换成函数指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FTtype  fn)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, pf fn)</span></span>;</span></pre></td></tr></table></figure>
<p>虽然不能返回一个函数，但是能返回执行函数类型的指针。和函数参数不同，编译器不会自动地将函数返回类型当作指针类型处理，必须显示的将返回类型指定为指针。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">F  <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">//错误： F是函数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">PF  <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">//正确： PF是函数指针类型</span></span></pre></td></tr></table></figure>
<p>f1也可以写出下面两种形式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto f1(int)-&gt;int(*)(int*, int);</span></pre></td></tr></table></figure>
<h3 id="lambda-表达式"><a class="markdownIt-Anchor" href="#lambda-表达式"></a> Lambda 表达式</h3>
<p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p>
<p>Lambda 表达式的基本语法如下：</p>
<blockquote>
<p>[ caputrue ] ( params ) opt -&gt; ret { body; };</p>
</blockquote>
<ol>
<li>capture是捕获列表；</li>
<li>params是参数表；</li>
<li>opt是函数选项，mutable,exception,attribute
<ol>
<li>mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。</li>
<li>exception说明lambda表达式是否抛出异常以及何种异常。</li>
<li>attribute用来声明属性。</li>
</ol>
</li>
<li>ret是返回值类型（拖尾返回类型）。</li>
<li>body是函数体。</li>
</ol>
<p>__捕获列表：__lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<blockquote>
<ol>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意__值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝__。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</li>
<li>[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量。</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。<strong>捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</strong></li>
</ol>
</blockquote>
<p><strong>值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝</strong><br>
<strong>捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=] &#123; <span class="keyword">return</span> a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a+=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//输出0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [&amp;a] &#123; <span class="keyword">return</span> a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a+=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt;<span class="built_in">endl</span>;       <span class="comment">//输出1</span></span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> i_ = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x1 = [] &#123; <span class="keyword">return</span> i_; &#125;;                   <span class="comment">//error,没有捕获外部变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x2 = [=] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;          <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x3 = [&amp;] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_; &#125;;               <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;       <span class="comment">//error,没有捕获x,y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;     <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_++; &#125;;             <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span> , b=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [] &#123; <span class="keyword">return</span> a; &#125;;                         <span class="comment">//error,没有捕获外部变量    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = [&amp;] &#123; <span class="keyword">return</span> a++ &#125;;                      <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f3 = [=] &#123; <span class="keyword">return</span> a; &#125;;                        <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;;                       <span class="comment">//error,a是以复制方式捕获的，无法修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f5 = [a] &#123; <span class="keyword">return</span> a+b; &#125;;                      <span class="comment">//error,没有捕获变量b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span></pre></td></tr></table></figure>
<p>注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去__修改按值捕获的外部变量，需要显示指明lambda表达式为mutable__。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。<strong>mutable的作用，就在于取消operator()的const</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [=] &#123; <span class="keyword">return</span> a++; &#125;;                <span class="comment">//error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = [=] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;       <span class="comment">//OK</span></span></pre></td></tr></table></figure>
<p>lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为__闭包类型（closure type）<strong>。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个__右值</strong>。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<p>lambda表达式是不能被赋值的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = [] &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = [] &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = b;   <span class="comment">// 非法，lambda无法赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = a;   <span class="comment">// 合法，生成一个副本</span></span></pre></td></tr></table></figure>
<p>闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以__用一个lambda表达式去初始化另外一个lambda表达式而产生副本__。</p>
<p>在多种捕获方式中，<strong>最好不要使用[=]和[&amp;]默认捕获所有变量</strong>。</p>
<p>默认引用捕获所有变量，你有很大可能会出现__悬挂引用（Dangling references）__，因为引用捕获不会延长引用的变量的生命周期：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; add_x(<span class="keyword">int</span> x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [&amp;](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> x + a; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Filter(<span class="keyword">int</span> divisorVal):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        divisor&#123;divisorVal&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> divisor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [divisor](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>原代码中，lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; getFilter() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % <span class="keyword">this</span>-&gt;divisor == <span class="number">0</span>; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，<strong>采用默认值捕捉所有变量仍然是不安全的</strong>，主要是由于__指针变量的复制，实际上还是按引用传值__。</p>
<p>lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; wrapper = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span></pre></td></tr></table></figure>
<p>lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p>
<p>最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nt value = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(v.beigin(), v.end(), [value](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x &gt; value; &#125;);</span></pre></td></tr></table></figure>
<p>再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::generate(v.begin(), v.end(), [&amp;a, &amp;b] &#123; <span class="keyword">int</span> value = b; b = b + a; a = value; <span class="keyword">return</span> value; &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 此时v &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;</span></span></pre></td></tr></table></figure>
<p>当需要遍历容器并对每个元素进行操作时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> even_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), [&amp;even_count](<span class="keyword">int</span> val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!(val &amp; <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++ even_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number of even is "</span> &lt;&lt; even_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr></table></figure>
<p>大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。</p>
<h3 id="新增容器"><a class="markdownIt-Anchor" href="#新增容器"></a> 新增容器</h3>
<h4 id="stdarray"><a class="markdownIt-Anchor" href="#stdarray"></a> std::array</h4>
<p>std::array 保存在__栈内存__中，相比__堆内存__中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</p>
<p>std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 非法, 数组大小参数必须是常量表达式</span></span></pre></td></tr></table></figure>
<p>当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span> 4&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// C 风格接口传参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// foo(arr, arr.size());           // 非法, 无法隐式转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">foo(&amp;arr[<span class="number">0</span>], arr.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo(arr.data(), arr.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 `std::sort`</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(arr.begin(), arr.end());</span></pre></td></tr></table></figure>
<h4 id="stdforward_list"><a class="markdownIt-Anchor" href="#stdforward_list"></a> std::forward_list</h4>
<p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。<br>
和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p>
<h4 id="unorder-container"><a class="markdownIt-Anchor" href="#unorder-container"></a> unorder container</h4>
<p>C++11 引入了两组无序容器：</p>
<ul>
<li>std::unordered_map、std::unordered_multimap</li>
<li>std::unordered_set、std::unordered_multiset</li>
</ul>
<p>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</p>
<ul>
<li>使用标准类型时，可以不提供hash_key算法. unordered_map&lt;T1, T2&gt; vars;</li>
<li>使用自定义类型时，需要提供hash_key算法. unordered_map&lt;T1, T2, hash_key&gt; vars;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_key</span>    //定制返回哈希值的仿函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//BKDRHash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Store&amp; s) <span class="keyword">const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> seed = <span class="number">131</span>; <span class="comment">/* 31 131 1313 13131 131313 etc.. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; s.name.size(); ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hash = ( hash * seed)  + s.name[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hash:"</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> hash;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;Store, <span class="keyword">int</span>, hash_key&gt;::iterator MyIte;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_map</span><span class="params">( )</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">unordered_map</span>&lt;Store, <span class="keyword">int</span>, hash_key&gt; umap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Store <span class="title">s1</span><span class="params">(<span class="string">"火锅店"</span>, <span class="string">"重庆"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Store <span class="title">s2</span><span class="params">(<span class="string">"凉皮店"</span>, <span class="string">"西安"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Store <span class="title">s3</span><span class="params">(<span class="string">"烤鸭店"</span>, <span class="string">"北京"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    umap.insert(make_pair(s1, <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    umap.insert(make_pair(s2, <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    umap.insert(make_pair(s3, <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    umap[s3] = 1;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyIte it = umap.begin( );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>( it != umap.end( ))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first.name&lt;&lt;<span class="string">"["</span> &lt;&lt; it-&gt;first.addr &lt;&lt; <span class="string">"]:"</span> &lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++it;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="stdtuple"><a class="markdownIt-Anchor" href="#stdtuple"></a> std::tuple</h4>
<p>元组的使用有三个核心的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::make_tuple <span class="comment">// 构造元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::get <span class="comment">//获得元组某个位置的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tie <span class="comment">//元组拆包</span></span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, <span class="string">'A'</span>, <span class="string">"张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, <span class="string">'C'</span>, <span class="string">"李四"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, <span class="string">'D'</span>, <span class="string">"王五"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, <span class="string">'D'</span>, <span class="string">"null"</span>);   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: 0, "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"GPA: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"成绩: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> gpa;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 元组进行拆包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: 1, "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"GPA: "</span> &lt;&lt; gpa &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"成绩: "</span> &lt;&lt; grade &lt;&lt; <span class="string">", "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>合并两个元组，可以通过 std::tuple_cat 来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span></pre></td></tr></table></figure>
<h5 id="stdtuple-vs-stdpair"><a class="markdownIt-Anchor" href="#stdtuple-vs-stdpair"></a> std::tuple VS std::pair</h5>
<p>std::tuple是类似pair的模板。每个pair的成员类型都不相同，但每个pair都恰好有两个成员。不同std::tuple类型的成员类型也不相同，但一个std::tuple可以有任意数量的成员。每个确定的std::tuple类型的成员数目是固定的，但一个std::tuple类型的成员数目可以与另一个std::tuple类型不同。</p>
<p>但我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，std::tuple是非常有用的。我们可以__将std::tuple看作一个”快速而随意”的数据结构__。</p>
<p>当我们定义一个std::tuple时，需要指出每个成员的类型。<br>
当我们创建一个std::tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化；<br>
也以为每个成员提供一个初始值，此时的构造函数是explicit的，因此必须使用直接初始化方法。</p>
<p>类似make_pair函数，标准库定义了make_tuple函数，我们还可以使用它来生成std::tuple对象。<br>
类似make_pair，make_tuple函数使用初始值的类型来推断tuple的类型。</p>
<p>一个std::tuple类型的成员数目是没有限制的，因此，tuple的成员都是未命名的。要访问一个tuple的成员，就要使用一个名为get的标准库函数模板。为了使用get，我们必须指定一个显式模板实参，它指出我们想要访问第几个成员。我们传递给get一个tuple对象，它返回指定成员的引用。get尖括号中的值必须是一个整型常量表达式。与往常一样，我们从0开始计数，意味着get&lt;0&gt;是第一个成员。</p>
<p>为了使用tuple_size或tuple_element，我们需要知道一个tuple对象的类型。与往常一样，确定一个对象的类型的最简单方法就是使用decltype。</p>
<p>std::tuple的关系和相等运算符的行为类似容器的对应操作。这些运算符逐对比较左侧tuple和右侧tuple的成员。只有两个tuple具有相同数量的成员时，我们才可以比较它们。而且，为了使用tuple的相等或不等运算符，对每对成员使用==运算符必须都是合法的；为了使用关系运算符，对每对成员使用 &lt; 必须都是合法的。由于tuple定义了&lt; 和 == 运算符，我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型。</p>
<p>std::tuple的一个常见用途是从一个函数返回多个值。</p>
<p>std::tuple是一个模板，允许我们将多个不同类型的成员捆绑成单一对象。每个tuple包含指定数量的成员，但对一个给定的tuple类型，标准库并未限制我们可以定义的成员数量上限。</p>
<p>std::tuple中元素是被紧密地存储的(位于连续的内存区域)，而不是链式结构。</p>
<p>std::tuple实现了多元组，这是一个编译期就确定大小的容器，可以容纳不同类型的元素。多元组类型在当前标准库中被定义为可以用任意数量参数初始化的类模板。每一模板参数确定多元组中一元素的类型。所以，多元组是一个多类型、大小固定的值的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_tuple_4</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123; <span class="comment">// tuple::tuple: Constructs a tuple object. This involves individually constructing its elements,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// with an initialization that depends on the constructor form invoke</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; first;                             <span class="comment">// default</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; second(first);                    <span class="comment">// copy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; third(<span class="built_in">std</span>::make_tuple(<span class="number">20</span>, <span class="string">'b'</span>));   <span class="comment">// move</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">long</span>, <span class="keyword">char</span>&gt; fourth(third);                   <span class="comment">// implicit conversion</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; fifth(<span class="number">10</span>, <span class="string">'a'</span>);                    <span class="comment">// initialization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; sixth(<span class="built_in">std</span>::make_pair(<span class="number">30</span>, <span class="string">'c'</span>));    <span class="comment">// from pair / move</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(sixth);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(sixth) &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h3>
<p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p>
<ol>
<li>检查一个串是否包含某种形式的子串；</li>
<li>将匹配的子串替换；</li>
<li>从某个串中取出符合条件的子串。</li>
</ol>
<p>C++11 提供的正则表达式库操作 <strong>std::string</strong> 对象，对模式 <strong>std::regex</strong> (本质是 std::basic_regex)进行初始化，通过 <strong>std::regex_match</strong>进行匹配，从而产生 <strong>std::smatch</strong>（本质是 std::match_results 对象）。</p>
<p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式：</p>
<blockquote>
<p>[a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个及以上小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 转义后则表示匹配字符 . ，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的所要匹配的内容就是文件名为纯小写字母的文本文件。</p>
</blockquote>
<p>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"test"</span>, <span class="string">"a0.txt"</span>, <span class="string">"AAA.txt"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在 C++ 中 `\` 会被作为字符串内的转义符，为使 `\.` 作为正则表达式传递进去生效，需要对 `\` 进行二次转义，从而有 `\\.`</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="function">regex <span class="title">txt_regex</span><span class="params">(<span class="string">"[a-z]+\\.txt"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>另一种常用的形式就是依次传入 std::string、std::smatch、std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">regex <span class="title">base_regex</span><span class="params">(<span class="string">"([a-z]+)\\.txt"</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::smatch base_match;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::regex_match(fname, base_match, base_regex)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sub_match 的第一个元素匹配整个字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sub_match 的第二个元素匹配了第一个括号表达式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (base_match.size() == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> base = base_match[<span class="number">1</span>].str();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sub-match[0]: "</span> &lt;&lt; base_match[<span class="number">0</span>].str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">" sub-match[1]: "</span> &lt;&lt; base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>以上两个代码段的输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo.txt: <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">bar.txt: <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a0.txt: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">AAA.txt: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sub-match[<span class="number">0</span>]: foo.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo.txt sub-match[<span class="number">1</span>]: foo</span></pre></td></tr><tr><td class="code"><pre><span class="line">sub-match[<span class="number">0</span>]: bar.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">bar.txt sub-match[<span class="number">1</span>]: bar</span></pre></td></tr></table></figure>
<h3 id="语言级线程支持"><a class="markdownIt-Anchor" href="#语言级线程支持"></a> 语言级线程支持</h3>
<ul>
<li>std::thread</li>
<li>std::mutex/std::unique_lock</li>
<li>std::future/std::packaged_task</li>
<li>std::condition_variable</li>
</ul>
<p>代码编译需要使用 -pthread 选项</p>
<h3 id="右值引用和move语义"><a class="markdownIt-Anchor" href="#右值引用和move语义"></a> 右值引用和move语义</h3>
<p>以字符串处理为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">a</span><span class="params">(x)</span></span>;                                    <span class="comment">// line 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">b</span><span class="params">(x + y)</span></span>;                                    <span class="comment">// line 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">c</span><span class="params">(some_function_returning_a_string())</span></span>;       <span class="comment">// line 3</span></span></pre></td></tr></table></figure>
<p>如果使用以下拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; that)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(that.data) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memcpy</span>(data, that.data, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>以上3行中，只有第一行(line 1)的x深度拷贝是有必要的，因为我们可能会在后边用到x，x是一个左值(lvalues)。</p>
<p>第二行和第三行的参数则是右值，因为表达式产生的string对象是匿名对象，之后没有办法再使用了。</p>
<p>C++ 11引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; that)   <span class="comment">// string&amp;&amp; is an rvalue reference to a string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	data = that.data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	that.data = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我们__没有深度拷贝堆内存__中的数据，而是仅仅__复制了指针，并把源对象的指针置空__。事实上，我们“偷取”了属于源对象的内存数据。由于__源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了__。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做 <strong>转移构造函数（move constructor）</strong>，他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。</p>
<p>有了右值引用，再来看看赋值操作符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">string</span> that)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::swap(data, that.data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意到我们是直接对参数that传值，所以that会像其他任何对象一样被初始化，那么确切的说，that是怎样被初始化的呢？对于__C++ 98，是复制构造函数__，但是__对于C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择__。</p>
<p>如果是a=b，这样就会调用复制构造函数来初始化that（因为b是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。</p>
<p>如果是a = x + y，这样就会调用转移构造函数来初始化that（因为x+y是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为x+y是右值，再次，从右值指向的对象中转移是没有问题的。</p>
<p>总结：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。</p>
<p>下面我们进一步讨论__右值引用、move语义__。</p>
<p>C<ins>98标准库中提供了一种唯一拥有性的智能指针std::auto_ptr，该类型在C</ins>11中已被废弃，因为其“复制”行为是危险的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; b(a);</span></pre></td></tr></table></figure>
<p>注意b是怎样使用a进行初始化的，它不复制triangle，而是把triangle的所有权从a传递给了b，也可以说成“a 被转移进了b”或者“triangle被从a转移到了b”。</p>
<p>auto_ptr 的复制构造函数可能看起来像这样（简化）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&amp; source)   <span class="comment">// note the missing const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p = source.p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	source.p = <span class="number">0</span>;   <span class="comment">// now the source no longer owns the object</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>auto_ptr 的危险之处在于看上去应该是复制，但实际上确是转移。调用被转移过的auto_ptr 的成员函数将会导致不可预知的后果。所以你必须非常谨慎的使用auto_ptr ，如果他被转移过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; make_triangle()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">auto_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; c(make_triangle());      <span class="comment">// move temporary into c</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> area = make_triangle()-&gt;area();   <span class="comment">// perfectly safe</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);    <span class="comment">// create triangle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Shape&gt; b(a);               <span class="comment">// move a into b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> area = a-&gt;area();                <span class="comment">// undefined behavior</span></span></pre></td></tr></table></figure>
<p>然，在持有auto_ptr 对象的a表达式和持有调用函数返回的auto_ptr值类型的make_triangle()表达式之间一定有一些潜在的区别，每调用一次后者就会创建一个新的auto_ptr对象。这里a 其实就是一个左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。</p>
<p>转移像a这样的左值是非常危险的，因为我们可能调用a的成员函数，这会导致不可预知的行为。另一方面，转移像make_triangle()这样的右值却是非常安全的，因为复制构造函数之后，我们不能再使用这个临时对象了，因为这个转移后的临时对象会在下一行之前销毁掉。</p>
<p>我们现在知道转移左值是十分危险的，但是转移右值却是很安全的。如果C++能从语言级别支持区分左值和右值参数，我就可以完全杜绝对左值转移，或者把转移左值在调用的时候暴露出来，以使我们不会不经意的转移左值。</p>
<h4 id="右值引用"><a class="markdownIt-Anchor" href="#右值引用"></a> 右值引用</h4>
<p>C++ 11对这个问题的答案是__右值引用__。</p>
<p>右值引用是针对右值的新的引用类型，语法是X&amp;&amp;。以前的老的引用类型X&amp; 现在被称作左值引用。</p>
<p>使用右值引用X&amp;&amp;作为参数的最有用的函数之一就是转移构造函数X::X(X&amp;&amp; source)，它的主要作用是把源对象的本地资源转移给当前对象。</p>
<p>C++ 11中，std::auto_ptr&lt; T &gt;已经被std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用。</p>
<p>其转移构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; source)   <span class="comment">// note the rvalue reference</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ptr = source.ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    source.ptr = <span class="literal">nullptr</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个转移构造函数跟auto_ptr中复制构造函数做的事情一样，但是它却只能接受右值作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; b(a);                 <span class="comment">// error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; c(make_triangle());       <span class="comment">// okay</span></span></pre></td></tr></table></figure>
<p>第二行不能编译通过，因为a是左值，但是参数unique_ptr&amp;&amp; source只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。<br>
第三行编译没有问题，因为make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象c，这正是我们需要的。</p>
<h4 id="转移左值-stdmove"><a class="markdownIt-Anchor" href="#转移左值-stdmove"></a> 转移左值 std::move</h4>
<p>有时候，我们可能想转移左值，也就是说，有时候我们想让编译器把左值当作右值对待，以便能使用转移构造函数，即便这有点不安全。出于这个目的，C++ 11在标准库的头文件&lt; utility &gt;中提供了一个模板函数std::move。</p>
<blockquote>
<p>std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。</p>
</blockquote>
<p>以下是如何正确的转移左值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; a(<span class="keyword">new</span> Triangle);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; b(a);              <span class="comment">// still an error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; c(<span class="built_in">std</span>::move(a));   <span class="comment">// okay</span></span></pre></td></tr></table></figure>
<p><strong>注意</strong>: 第三行之后，a不再拥有Triangle对象。不过这没有关系，因为通过明确的写出std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对a做任何想要做的事情来初始化c；我不再需要a了，对于a，您请自便。</p>
<p>当然，如果你在使用了mova(a)之后，还继续使用a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。</p>
<p>总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">unique_ptr</span>&lt;Shape&gt; member;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Foo(<span class="built_in">unique_ptr</span>&lt;Shape&gt;&amp;&amp; parameter)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    : member(parameter)   <span class="comment">// error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>上面的parameter，其类型是一个右值引用，只能说明parameter是指向右值的引用，而parameter本身是个左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）</p>
<p>因此以上对parameter的转移是不允许的，需要使用std::move来显示转换成右值</p>
<h4 id="stdforward"><a class="markdownIt-Anchor" href="#stdforward"></a> std::forward</h4>
<p>std::forward 原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; param)</span> <span class="comment">//左值引用版本</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; param)</span>  <span class="comment">//右值引用版本</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//param被右值初始化时，T应为右值引用类型，如果T被绑定为左值引用则报错。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">" substituting _Tp is an lvalue reference type"</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//其中remove_reference的实现如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1. 特化版本（一般的类）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> T type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2. 左值引用版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> T type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3. 右值引用版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> T type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h5 id="完美转发perfect-forwarding"><a class="markdownIt-Anchor" href="#完美转发perfect-forwarding"></a> 完美转发（Perfect Forwarding）</h5>
<p>完美转发</p>
<blockquote>
<p>是指在函数模板中，完全依照模板的参数类型（即保持实参的左值、右值特性），将实参传递给函数模板中调用的另外一个函数。</p>
</blockquote>
<p>原理分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//完美转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; fparam)</span> <span class="comment">//fparam是个Universal引用</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    doSomething(<span class="built_in">std</span>::forward&lt;T&gt;(fparam));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1. 假设传入func是一个左值的Widget对象， T被推导为Widget&amp;，则forward如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//==&gt;引用折叠折后</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&gt;(param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2. 假设传入func是一个右值的Widget对象， T被推导为Wiget，则forward如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;Widget&gt;::type&amp; param)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="stdforward-vs-stdmove"><a class="markdownIt-Anchor" href="#stdforward-vs-stdmove"></a> std::forward VS std::move</h5>
<ol>
<li>std::move是无条件转换，不管它的参数是左值还是右值，都会被强制转换成右值。就其本身而言，它没有move任何东西。</li>
<li>std::forward是有条件转换。只有在它的参数绑定到一个右值时，它才转换它的参数到一个右值。当参数绑定到左值时，转换后仍为左值。</li>
<li>对右值引用使用std::move，对universal引用则使用std::forward</li>
<li>如果局部变量有资格进行RVO优化，不要把std::move或std::forward用在这些局部变量中</li>
<li>std::move和std::forward在运行期都没有做任何事情。</li>
</ol>
<p>不完美转发和完美转发示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; //for std::forward</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(T&amp;&amp; v)</span> <span class="comment">//v是Universal引用</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//不完美转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(v);  <span class="comment">//v具有变量，本身是左值，调用print(int&amp; t)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//完美转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="built_in">std</span>::forward&lt;T&gt;(v)); <span class="comment">//按v被初始化时的类型转发（左值或右值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//强制将v转为右值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="built_in">std</span>::move(v)); <span class="comment">//将v强制转为右值，调用print(int&amp;&amp; t)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"========Test(1)========"</span> &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="number">1</span>); <span class="comment">//传入右值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"========Test(x)========"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(x); <span class="comment">//传入左值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"=====Test(std::forward&lt;int&gt;(1)==="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>)); <span class="comment">//T为int，以右值方式转发1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Test(std::forward&lt;int&amp;&gt;(1)); //T为int&amp;，需转入左值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"=====Test(std::forward&lt;int&gt;(x))==="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">//T为int，以右值方式转发x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"=====Test(std::forward&lt;int&amp;&gt;(x))==="</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&amp;&gt;(x)); <span class="comment">//T为int，以左值方式转发x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">========Test(<span class="number">1</span>)========</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">========Test(x)========</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>)===</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(x))===</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">=====Test(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&amp;&gt;(x))===</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">lvalue</span></pre></td></tr><tr><td class="code"><pre><span class="line">rvalue</span></pre></td></tr></table></figure>
<h5 id="万能的函数包装器"><a class="markdownIt-Anchor" href="#万能的函数包装器"></a> 万能的函数包装器</h5>
<h6 id="利用stdforward和可变参数模板实现"><a class="markdownIt-Anchor" href="#利用stdforward和可变参数模板实现"></a> 利用std::forward和可变参数模板实现</h6>
<ol>
<li>可将带返回值、不带返回值、带参和不带参的函数委托万能的函数包装器执行。</li>
<li>Args&amp;&amp;为Universal引用，因为这里的参数可能被左值或右值初始化。Funciont&amp;&amp;也为Universal引用，如被lambda表达式初始化。</li>
<li>利用std::forward将参数正确地（保持参数的左、右值属性）转发给原函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//万能的函数包装器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可将带返回值、不带返回值、带参和不带参的函数委托万能的函数包装器执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注意：Args&amp;&amp;表示Universal引用，因为这里的参数可能被左值或右值初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//      Funciont&amp;&amp;也为Universal引用，如被lambda表达式初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function, <span class="class"><span class="keyword">class</span>...<span class="title">Args</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">auto</span> <span class="title">FuncWrapper</span>(<span class="title">Function</span>&amp;&amp; <span class="title">func</span>, <span class="title">Args</span>&amp;&amp; ...<span class="title">args</span>)-&gt;<span class="title">decltype</span>(<span class="title">func</span>(<span class="title">std</span>:</span>:forward&lt;Args&gt;(args)...))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> func(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void test0()"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">test3</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> s1 + s2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FuncWrapper(test0);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int test1(): "</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; FuncWrapper(test1) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int test2(int x): "</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; FuncWrapper(test2, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"string test3(string s1, string s2): "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; FuncWrapper(test3, <span class="string">"aa"</span>, <span class="string">"bb"</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[](int x, int y)&#123;return x + y;&#125;: "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; FuncWrapper([](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> x + y;&#125;, <span class="number">1</span>,  <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">int test1(): 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">int test2(int x): 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">string test3(string s1, string s2): aabb</span></pre></td></tr><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> x + y&#125;: <span class="number">3</span></span></pre></td></tr></table></figure>
<h6 id="emplace_back减少内存拷贝和移动"><a class="markdownIt-Anchor" href="#emplace_back减少内存拷贝和移动"></a> emplace_back减少内存拷贝和移动</h6>
<ol>
<li>emplace_back的实现原理类似于“万能函数包装器”，将参数std::forward转发给元素类的构造函数。实现上，首先为该元素开辟内存空间，然后在这片空间中调用placement new进行初始化，这相当于“就地”(在元素所在内存空间)调用元素对象的构造函数。</li>
<li>push_back会先将参数转为相应的元素类型，这需要调用一次构造函数，再将这个临时对象拷贝构造给容器内的元素对象，所以共需要一次构造和一次拷贝构造。从效率上看不如emplace_back，因为后者只需要一次调用一次构造即可。</li>
<li>一般传入emplace_back的是构造函数所对应的参数(也只有这样传参才能节省一次拷贝构造)，所以要求对象有相应的构造函数，如果没有对应的构造函数，则只能用push_back，否则编译会报错。如emplace_back(int, int)，则要求元素对象需要有带两个int型的构造函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m_a;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="keyword">int</span> a) : m_a(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Test(int a)"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test(<span class="keyword">const</span> Test&amp; t) : m_a(t.m_a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++m_count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;m_a = t.m_a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//创建10个值为1的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;Test&gt; vec(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//首先将1转为Test(1)，会调用1次Test(int a)。然后，利用Test(1)去拷贝构造10个元素，所以调用10次拷贝构造。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.capacity():"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">", "</span>; <span class="comment">//10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.size():"</span> &lt;&lt; vec.size() &lt;&lt;  <span class="built_in">endl</span>;        <span class="comment">//10,空间己满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vec.push_back(Test(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//由于capacity空间己满。首先调用Test(1)，然后再push_back中再拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">//构造10个元素（而不是1个，为了效率），所以调用10次拷贝构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.capacity():"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">", "</span>;  <span class="comment">//20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.size():"</span> &lt;&lt; vec.size() &lt;&lt;  <span class="built_in">endl</span>;         <span class="comment">//11,空间未满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vec.push_back(<span class="number">1</span>);  <span class="comment">//先调用Test(1)，然后调用1次拷贝构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.capacity():"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">", "</span>; <span class="comment">//20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.size():"</span> &lt;&lt; vec.size() &lt;&lt;  <span class="built_in">endl</span>;         <span class="comment">//12,空间未满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vec.emplace_back(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//由于空间未满，直接在第12个元素位置调用placement new初始化那段空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//所以就会调用构造函数，节省了调用拷贝构造的开销</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.capacity():"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">", "</span>; <span class="comment">//20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.size():"</span> &lt;&lt; vec.size() &lt;&lt;  <span class="built_in">endl</span>;        <span class="comment">//13,空间未满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Test::m_count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vec.emplace_back(Test(<span class="number">1</span>)); </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//先调用Test(1)，再调用拷贝构造（注意与vec.emplace_back(1)之间差异）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.capacity():"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">", "</span>; <span class="comment">//20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec.size():"</span> &lt;&lt; vec.size() &lt;&lt;  <span class="built_in">endl</span>;        <span class="comment">//14,空间未满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test(<span class="keyword">int</span> a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">...  <span class="comment">//中间省略了调用10次Test(const Test&amp; t)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">vec.capacity():<span class="number">10</span>, vec.size():<span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">int</span> a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">...  <span class="comment">//中间省略了调用10次Test(const Test&amp; t)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">vec.capacity():<span class="number">20</span>, vec.size():<span class="number">11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">int</span> a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">const</span> Test&amp; t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">vec.capacity():<span class="number">20</span>, vec.size():<span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">int</span> a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">vec.capacity():<span class="number">20</span>, vec.size():<span class="number">13</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">int</span> a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test(<span class="keyword">const</span> Test&amp; t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">vec.capacity():<span class="number">20</span>, vec.size():<span class="number">14</span></span></pre></td></tr></table></figure>
<h3 id="数据对齐-alignof-alignas"><a class="markdownIt-Anchor" href="#数据对齐-alignof-alignas"></a> 数据对齐 alignof、alignas</h3>
<p>C++11主要引入两个关键字：操作符alignof、对齐描述符（alignment-specifier) alignas。操作符alignof的操作数表示一个定义完整的自定义类型或者内置类型或者变量，返回的值是一个std:: size_t类型的整型常量。如同sizeof操作符一样，alignof获得的也是一个与平台相关的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InComplete</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Completed</span>&#123;</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span>&amp; c=b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> d[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//对内置类型和完整类型使用alignof</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">alignof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">alignof</span>(Completed)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//4,1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//对变量、引用或者数组使用alignof, 数组的对齐值由其元素决定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">alignof</span>(a)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">alignof</span>(b)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">alignof</span>(c)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">alignof</span>(d)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//4,8,8,1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//本句无法通过编译，Incomplete类型不完整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//cout&lt;&lt;alignof(Incomplete)&lt;&lt;endl;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>对齐描述符alignas，既可以接受常量表达式，也可以接受类型作为参数，比如：<code>c++ alignas(double) char c;</code> 效果跟 <code>c++ alignas(alignof(double)) char c;</code> 是一样的。</p>
<p>注意 在C++11标准之前，我们也可以使用一些编译器的扩展来描述对齐方式，比如GNU格式的attribute((aligned(8))) 就是一个广泛被接受的版本。</p>
<p>C<ins>11标准建议用户在声明同一个变量的时候使用同样的对齐方式以免发生意外。不过C</ins>11并没有规定声明变量采用了不同的对齐方式就终止编译器的编译。</p>
<p>下面代码实现了一个固定容量但是大小随着所用的数据类型变化的容器类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="keyword">alignof</span>(<span class="keyword">double</span>)*<span class="number">4</span>)</span> ColorVector</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//固定容量的模板数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedCapacityArray</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T t)</span></span>&#123;<span class="comment">/*在data中加入t变量*/</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//一些其他成员函数、成员变量等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      char alignas(T) data[1024]=&#123;0&#125;; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//int length=1024/sizeof(T);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FixedCapacityArray&lt;<span class="keyword">char</span>&gt; arrCh;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alignof(char):"</span>&lt;&lt;<span class="keyword">alignof</span>(<span class="keyword">char</span>)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alignof(arrCh.data):"</span>&lt;&lt;<span class="keyword">alignof</span>(arrCh.data)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FixedCapacityArray&lt;ColorVector&gt; arrCV;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alignof(ColorVector):"</span>&lt;&lt;<span class="keyword">alignof</span>(ColorVector)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alignof(arrCV.data):"</span>&lt;&lt;<span class="keyword">alignof</span>(arrCV.data)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>FixedCapacityArray固定使用1024字节的空间，但由于模板的存在，可以实例化为各种版本。这样一来，我们可以在相同的内存使用量的前提下，做出多种（内置或者自定义）版本的数组。对于arrCh，由于数组中的元素都是char类型，所以对齐到1就行了，而对于我们定义的arrCV, 必须使其符合ColorVector的扩展对齐，即对齐到8字节的内存边界上。在这个例子中，起到关键作用的代码是</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">char alignas(T) data[1024]=&#123;0&#125;;</span></pre></td></tr></table></figure>
<p>该句指示data[1024]这个char类型数组必须按照模板参数T的对齐方式进行对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alignof</span>(<span class="keyword">char</span>):<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">alignof</span>(arrCh.data):<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">alignof</span>(ColorVector):<span class="number">32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">alignof</span>(arrCV.data):<span class="number">32</span></span></pre></td></tr></table></figure>
<p>由于char数组默认对齐值为1，会导致data[1024]数组也对齐到1.这肯定不是编写FixedCapacityArray的程序员愿意见到的。</p>
<p>在C++11标准引入alignas修饰符之前，这样的固定容量的泛型数组有时可能遇到因为对齐不佳而导致的性能损失（甚至程序错误），这给库的编写者带来了很大的困扰。而引入alignas能够解决这些移植性的困难</p>
<p>C++11对于对齐的支持并不限于alignof操作符及alignas操作符。在STL库中，还内建了std::align函数来动态地根据指定的对齐方式调整数据块的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">align</span><span class="params">(<span class="built_in">std</span>:: <span class="keyword">size_t</span> alignment, <span class="built_in">std</span>:: <span class="keyword">size_t</span> size,<span class="keyword">void</span>*&amp;ptr,<span class="built_in">std</span>:: <span class="keyword">size_t</span>&amp;space)</span></span>;</span></pre></td></tr></table></figure>
<p>该函数在ptr指向的大小为space的内存中进行对齐方式的调整，将ptr开始的size大小的数据调整为按alignment对齐</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorVector</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">double</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">size_t</span> <span class="keyword">const</span> size=<span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ColorVector* <span class="keyword">const</span> vec=<span class="keyword">new</span> ColorVector[size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">void</span>*p=vec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">size_t</span> sz=size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">void</span>* aligned=align(<span class="keyword">alignof</span>(<span class="keyword">double</span>)*<span class="number">4</span>,size,p,sz);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(aligned!=<span class="literal">nullptr</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="keyword">alignof</span>(p)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>__注意：__C++11中的alignas能否完全代替#pragma pack</p>
<blockquote>
<p>The alignas specifier may be applied to the declaration of a variable or a non-bitfield class data member, or it can be applied to the declaration or definition of a class/struct/union or enumeration. It cannot be applied to a function parameter or to the exception parameter of a catch clause.The object or the type declared by such a declaration will have its alignment requirement equal to the strictest (largest) non-zero expression of all alignas specifiers used in the declaration, unless it would weaken the natural alignment of the type.If the strictest (largest) alignas on a declaration is weaker than the alignment it would have without any alignas specifiers (that is, weaker than its natural alignment or weaker than alignas on another declaration of the same object or type), the program is ill-formed</p>
</blockquote>
<p>如上所述，不能指定比本身还小的对齐</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">1</span>)</span> Point</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;p;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">alignof</span>(p)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// output 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// output 8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;p2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pop(pop)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">alignof</span>(p2)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//output 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p2)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//output 5</span></span></pre></td></tr></table></figure>
<p><a href="https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019" target="_blank" rel="noopener">#pragma pack参见文档</a></p>
<h3 id="通用属性"><a class="markdownIt-Anchor" href="#通用属性"></a> 通用属性</h3>
<blockquote>
<p>随着C<ins>语言的演化和编译器的发展，人们常会发现标准提供的语言能力不能完全满足要求。于是编译器厂商或组织为了满足编译器客户的需求，设计出一系列的语言扩展（language extension）来扩展语法。这些扩展语法并不存在于C</ins>/C标准中，却有可能拥有较多的用户。<br>
扩展语法中比较常见的就是&quot;属性&quot;。属性是对语言中的实体对象（比如函数、变量、类型等）附加一些的额外注解信息，其用来实现一些语言及非语言层面的功能，或是实现优化代码等的一种手段。不同编译器有不同的属性语法。比如对于g++，属性是通过GNU的关键字__attribute__来声明的。程序员只需要简单地声明：<code>__attribute__((attribute-list))</code> 即可为程序中的函数、变量和类型设定一些额外信息，以便编译器可以进行错误检查和性能优化等</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> n)</span> __<span class="title">attribute__</span><span class="params">((<span class="keyword">const</span>))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> areas=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			areas+=area(<span class="number">3</span>)*i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里的const属性告诉编译器：本函数返回值只依赖于输入，不会改变任何函数外的数据，因此没有任何副作用。在此情况下，编译器可以对area函数进行优化处理。area(3)的值只需要计算一次，编译之后可以将area(3)视为循环中的常量而只使用其计算结果，从而大大提高了程序的执行性能。</p>
<blockquote>
<p>GNU对C/C++使用__attribute__提供通用属性支持，windows平台下微软使用__declspec提供类似的支持</p>
</blockquote>
<h4 id="自定义通用属性"><a class="markdownIt-Anchor" href="#自定义通用属性"></a> 自定义通用属性</h4>
<p>C<ins>11语言中的通用属性使用了左右双中括号的形式：**c</ins> [[attribute-list]]**</p>
<blockquote>
<p>C++11的通用属性可以作用于类型、变量、名称、代码块等。对于作用于声明的通用属性，既可以写在声明的起始处，也可以写在声明的标识符之后。而对于作用于整个语句的通用属性，则应该写在语句起始处。而出现在以上两种规则描述的位置之外的通用属性，作用于哪个实体跟编译器具体的实现有关</p>
</blockquote>
<h4 id="预定义通用属性"><a class="markdownIt-Anchor" href="#预定义通用属性"></a> 预定义通用属性</h4>
<p>在现有C++11标准中，只预定义了两个通用属性，分别是__[[noreturn]]__ 和 <strong>[[carries_dependency]]</strong>。</p>
<p>[[noreturn]] 是用于标识不会返回的函数的。这里必须注意，__不会返回__和__没有返回值的（void）__函数的区别。</p>
<p>没有返回值的void函数在调用完成后，调用者会接着执行函数后的代码；而不会返回的函数在被调用完成后，后续代码不会再被执行。[[noreturn]] 主要用于标识那些不会将控制流返回给原调用函数的函数，典型的例子有：有终止应用程序语句的函数、有无限循环语句的函数、有异常抛出的函数等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething1</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething2</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">ThrowAway</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">throw</span> <span class="string">"expection"</span>; <span class="comment">//控制流跳转到异常处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	DoSomething1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ThrowAway();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	DoSomething2(); <span class="comment">// 该函数不可到达</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>[[carries_dependency]] 则跟并行情况下的编译器优化有关。事实上，[[carries_depency]] 主要是为了解决弱内存模型平台上使用memory_order_consume内存顺序枚举问题。</p>
<p>memory_order_consume的主要作用是保证对当前 “原子类型数据” 的读取操作先于所有之后关于该原子变量的操作完成，但它不影响其他原子操作的顺序。要保证这样的&quot;先于发生&quot; 的关系，编译器往往需要根据memory_model枚举值在原子操作间构建一系列的依赖关系，以减少在弱一致性模型的平台上产生内存栅栏。不过这样的关系则往往会由于函数的存在而被破坏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>*&gt; p1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>*&gt; p2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>*&gt; p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>*&gt; p4;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义了4个原子类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_in1</span><span class="params">(<span class="keyword">int</span>*val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="built_in">cout</span>&lt;&lt;*val&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_in2</span><span class="params">(<span class="keyword">int</span>*[[carries_dependency]] val)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     p2.store(val,memory_order_release);  <span class="comment">//p2.store对p的使用会被保证在任何关于p的使用之后完成。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="built_in">cout</span>&lt;&lt;*p2&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[[carries_dependency]] <span class="function"><span class="keyword">int</span>*<span class="title">func_out</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span>(<span class="keyword">int</span>*)p3.load(memory_order_consume); <span class="comment">//p3.load对p的使用会被保证在任何关于p的使用之前完成。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span>* p_ptr1=(<span class="keyword">int</span>*)p1.load(memory_order_consume); <span class="comment">//L1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="built_in">cout</span>&lt;&lt;*p_ptrl&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//L2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     func_in1(p_ptr1); <span class="comment">//L3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     func_in2(p_ptr1); <span class="comment">//L4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span>*p_ptr2=func_out(); <span class="comment">//L5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     p4.store(p_ptr2,memory_order_release); <span class="comment">//L6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="built_in">cout</span>&lt;&lt;*p_ptr2&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>L1句中，p1.load采用了memory_order_consume的内存顺序，因此任何关于p1或者p_ptr1的原子操作，必须发生在L1句之后。</p>
<p>L2将由编译器保证其执行必须在L1之后（通过编译器正确的指令排序和内存栅栏）。</p>
<p>编译器在处理L3时，由于func_in1对于编译器而言并没有声明[[carries_dependency]]属性，编译器则可能采用保守的方法，在func_in1调用表达式之前插入内存栅栏。</p>
<p>编译器在处理L4句时，由于函数func_in2使用了[[carries_dependency]], 编译器则会假设函数体内部会正确地处理内存顺序，因此不再产生内存栅栏指令。</p>
<p>事实上func_in2中也由于p2.store使用内存顺序memory_order_release, 因而不会产生任何的问题。</p>
<p>编译器处理L5句时，由于func_out的返回值使用了[[carries_dependency]]，编译器也不会在返回前为p3.load(memory_order_consume) 插入内存栅栏指令去保证正确的内存顺序。</p>
<p>在L6行中，p4.store使用了memory_order_release, 因此func_out不产生内存栅栏也是毫无问题的。</p>
<p>[[noreturn]]，[[carries_dependency]] 只是帮助编译器进行优化，这符合通用属性设计的原则。 当读者使用的平台是弱内存模型的时候，并且很关心并行程序的执行性能时，可以考虑使用 [[carries_dependency]]。</p>
<h3 id="unicode"><a class="markdownIt-Anchor" href="#unicode"></a> Unicode</h3>
<p>C<ins>98标准中，为了支持Unicode，定义了“宽字符”的内置类型wchar_t. 不过不久程序员便发现C</ins>标准对wchar_t的“宽度”显然太过容忍，在Windows上，多数wchar_t被实现为16位宽，而在Linux上，则被实现为32位。事实上，C++98标准定义中，wchar_t的宽度是由编译器实现决定的。理论上，wchar_t的长度可以是8位、16位或者32位。这样带来的最大的问题是，程序员写出的包含wchar_t的代码通常不可移植。</p>
<p>C++11引入以下两种新的内置数据类型来存储不同编码长度的Unicode数据。<br>
A char16_t: 用于存储UTF-16编码的Unicode数据。<br>
B char32_t: 用于存储UTF-32编码的Unicode数据。</p>
<p>至于UTF-8编码的Unicode数据，C<ins>11还是使用8字节宽度的char类型的数组来保存。而char16_t和char32_t的长度则犹如其名称所显示的那样，长度分别为16字节和32字节，对任何编译器或者系统都是一样的。此外，C</ins>11还定义了一些常量字符串的前缀。在声明常量字符串的时候，这些前缀声明可以让编译器使字符串按照前缀类型产生数据。事实上，C++11一共定义了3种这样的前缀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u8表示UTF<span class="number">-8</span>编码</span></pre></td></tr><tr><td class="code"><pre><span class="line">u表示为UTF<span class="number">-16</span>编码</span></pre></td></tr><tr><td class="code"><pre><span class="line">U表示为UTF<span class="number">-32</span>编码</span></pre></td></tr></table></figure>
<p>3种前缀对应着3种不同的Unicode编码。一旦声明了这些前缀，编译器会在产生代码的时候按照相应的编码方式存储。以上3种前缀加上基于宽字符wchar_t的前缀“L”, 及不加前缀的普通字符串字面量，算来在C++11中，一共有了5种方式来声明字符串字面量，其中4种是前缀表达的。</p>
<p>不要将各种前缀字符串字面量连续声明，因为标准定义除了UTF-8和宽字符字符串字面量同时声明会冲突外，其他字符串字面量的组合最终会产生什么结果，以及会按照什么类型解释，是由编译器实现自行决定的。因此应该尽量避免这种不可移植的字符串字面量声明方式。</p>
<p>C++11中还规定了一些简明的方式，即在字符串中用’\u’加4个十六进制数编码的Unicode码位（UTF-16）来标识一个Unicode字符。比如’\u4F60’ 表示的就是Unicode中的中文字符 “你”，而’\u597D’ 则是Unicode中的 “好”。此外，也可以通过’\U’ 后跟8个十六进制数编码的Unicode码位（UTF-32）的方式来书写Unicode字面常量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char</span> utf8[] =u8 <span class="string">"\u4F60\u597D\u597D\u554A"</span>; <span class="comment">//你好啊</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char16_t</span> utf16[] =u <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char32_t</span> utf32[] =U <span class="string">"hello equals\u4F60\u597D\u554A"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span>&lt;&lt;utf8&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span>&lt;&lt;utf16&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">cout</span>&lt;&lt;utf32&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char32_t</span> u2[] =u <span class="string">"hello"</span>; <span class="comment">//Error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char</span> u3[] = U <span class="string">"hello"</span>; <span class="comment">//Error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">char16_t</span> u4=u8 <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我们声明了3中不同类型的Unicode字符串utf8、utf16和utf32。由于无论对哪种Unicode编码，英文的Unicode码位都相同，因此只有非英文使用了&quot;\u&quot;的码位方式来标志。<br>
<strong>使用了Unicode字符串前缀，这个字符串的类型就确定了，仅能放在相应类型的数组中</strong>。<br>
u2、u3、u4就是因为类型不匹配而不能通过编译</p>
<h3 id="原生字符串字面量-raw-string-literal"><a class="markdownIt-Anchor" href="#原生字符串字面量-raw-string-literal"></a> 原生字符串字面量 Raw String Literal</h3>
<p>原生字符串字面量（raw string literal）并不是一个新鲜的概念，在许多编程语言中，我们都可以看到对原生字符串字面量的支持。 原生字符串使用户书写的字符串 “所见即所得”，不再需要如’\t’、’\n’等控制字符来调整字符串中的格式，这对编程语言的学习和使用都是具有积极意义的。</p>
<p>在C<ins>11中，终于引入了原生字符串字面量的支持。C</ins>11中原生字符串的声明相当简单，程序员只需要在字符串前加入前缀，即字母R，并在引号中用使用括号左右标识，就可以声明该字符串为原生字符串了。<br>
<code>R&quot;(custom raw string inside the bracket)&quot;</code></p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> @Reference</h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp" target="_blank" rel="noopener">C++ Reference Official Manual</a></li>
<li><a href="http://www.generic-programming.org/_dgregor/cpp/variadic-templates.html" target="_blank" rel="noopener">Variadic Templates for GCC</a></li>
<li><a href="/assets/2019/12/09/C++11.pdf">C<ins>11 VS C</ins>03 Cheat Sheet pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>左值、右值表达式(LValue-And-RValue Expression)</title>
    <url>/program/lvalue-and-rvalue.html</url>
    <content><![CDATA[<h3 id="l-value"><a class="markdownIt-Anchor" href="#l-value"></a> L-Value</h3>
<p>Expressions that refer to <strong>memory locations</strong> are called “l-value” expressions. An l-value represents a storage region’s “locator” value, or a “left” value, implying that it can appear on the left of the equal sign (=). L-values are often identifiers.</p>
<p>Expressions referring to <strong>modifiable locations</strong> are called “modifiable l-values.” A modifiable l-value cannot have an array type, an incomplete type, or a type with the <strong>const</strong> attribute. For structures and unions to be modifiable l-values, they must not have any members with the const attribute. The name of the identifier denotes a storage location, while the value of the variable is the value stored at that location.</p>
<p>An identifier is a modifiable l-value if it refers to a memory location and if its type is arithmetic, structure, union, or pointer. For example, if ptr is a pointer to a storage region, then <strong>*ptr</strong> is a modifiable l-value that designates the storage region to which ptr points.</p>
<p>Any of the following C expressions can be l-value expressions:</p>
<blockquote>
<ul>
<li>An identifier of integral, floating, pointer, structure, or union type</li>
<li>A subscript ([ ]) expression that does not evaluate to an array</li>
<li>A member-selection expression (-&gt; or .)</li>
<li>A unary-indirection (*) expression that does not refer to an array</li>
<li>An l-value expression in parentheses</li>
<li>A const object (a nonmodifiable l-value)</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="r-value"><a class="markdownIt-Anchor" href="#r-value"></a> R-Value</h3>
<p>The term “r-value” is sometimes used to describe the value of an expression and to distinguish it from an l-value. All l-values are r-values but not all r-values are l-values.</p>
<h3 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h3>
<p>The terms lvalue and rvalue are not something one runs into often in C/C++ programming, but when one does, it’s usually not immediately clear what they mean. The most common place to run into these terms are in compiler error &amp; warning messages. For example, compiling the following with gcc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>You get:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test.c: In function 'main':</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.c:<span class="number">8</span>:<span class="number">5</span>: error: lvalue required as left operand of assignment</span></pre></td></tr></table></figure>
<p>True, this code is somewhat perverse and not something you’d write, but the error message mentions lvalue, which is not a term one usually finds in C/C++ tutorials. Another example is compiling this code with g++:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Now the error is:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">testcpp.cpp: In function 'int&amp; foo()':</span></pre></td></tr><tr><td class="code"><pre><span class="line">testcpp.cpp:<span class="number">5</span>:<span class="number">12</span>: error: invalid initialization of non-<span class="keyword">const</span> reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">of type 'int&amp;' from an rvalue of type 'int'</span></pre></td></tr></table></figure>
<p>Here again, the error mentions some mysterious rvalue. So what do lvalue and rvalue mean in C and C++? This is what I intend to explore in this article.</p>
<h4 id="a-simple-definition"><a class="markdownIt-Anchor" href="#a-simple-definition"></a> A simple definition</h4>
<p>This section presents an intentionally simplified definition of lvalues and rvalues. The rest of the article will elaborate on this definition.</p>
<blockquote>
<p>An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address).</p>
</blockquote>
<blockquote>
<p>rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.</p>
</blockquote>
<h4 id="basic-examples"><a class="markdownIt-Anchor" href="#basic-examples"></a> Basic examples</h4>
<p>The terms as defined above may appear vague, which is why it’s important to see some simple examples right away.<br>
Let’s assume we have an integer variable defined and assigned to:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var = <span class="number">4</span>;</span></pre></td></tr></table></figure>
<p>An assignment expects an lvalue as its left operand, and var is an lvalue, because it is an object with an identifiable memory location. On the other hand, the following are invalid:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> = var;       <span class="comment">// ERROR!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>; <span class="comment">// ERROR!</span></span></pre></td></tr></table></figure>
<p>Neither the constant 4, nor the expression var + 1 are lvalues (<strong>which makes them rvalues</strong>). They’re not lvalues because both are temporary results of expressions, which don’t have an identifiable memory location (i.e. they can just reside in some temporary register for the duration of the computation). Therefore, assigning to them makes no semantic sense - there’s nowhere to assign to.</p>
<p>So it should now be clear what the error message in the first code snippet means. foo returns a temporary value which is an rvalue. Attempting to assign to it is an error, so when seeing foo() = 2; the compiler complains that it expected to see an lvalue on the left-hand-side of the assignment statement.</p>
<p>Not all assignments to results of function calls are invalid, however. For example, C++ references make this possible:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalvar = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> globalvar;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Here foo returns a reference, which is an lvalue, so it can be assigned to. Actually, the ability of C++ to return lvalues from functions is important for implementing some overloaded operators. One common example is overloading the brackets operator [] in classes that implement some kind of lookup access. std::map does this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; mymap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mymap[<span class="number">10</span>] = <span class="number">5.6</span>;</span></pre></td></tr></table></figure>
<p>The assignment mymap[10] works because the non-const overload of std::map::operator[] returns a reference that can be assigned to.</p>
<h4 id="modifiable-lvalues"><a class="markdownIt-Anchor" href="#modifiable-lvalues"></a> Modifiable lvalues</h4>
<p>Initially when lvalues were defined for C, it literally meant “values suitable for left-hand-side of assignment”. Later, however, when ISO C added the const keyword, this definition had to be refined. After all:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 'a' is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;           <span class="comment">// but it can't be assigned!</span></span></pre></td></tr></table></figure>
<p>So a further refinement had to be added. Not all lvalues can be assigned to. Those that can are called modifiable lvalues. Formally, the C99 standard defines modifiable lvalues as:</p>
<blockquote>
<p>[…] an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.</p>
</blockquote>
<h4 id="conversions-between-lvalues-and-rvalues"><a class="markdownIt-Anchor" href="#conversions-between-lvalues-and-rvalues"></a> Conversions between lvalues and rvalues</h4>
<p>Generally speaking, language constructs operating on object values require rvalues as arguments. For example, the binary addition operator ‘+’ takes two rvalues as arguments and returns an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// + needs rvalues, so a and b are converted to rvalues</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="comment">// and an rvalue is returned</span></span></pre></td></tr></table></figure>
<p>As we’ve seen earlier, a and b are both lvalues. Therefore, in the third line, they undergo an implicit lvalue-to-rvalue conversion. All lvalues that aren’t arrays, functions or of incomplete types can be converted thus to rvalues.</p>
<p>What about the other direction? Can rvalues be converted to lvalues? Of course not! This would violate the very nature of an lvalue according to its definition [1].</p>
<p>This doesn’t mean that lvalues can’t be produced from rvalues by more explicit means. For example, the unary ‘*’ (dereference) operator takes an rvalue argument but produces an lvalue as a result. Consider this valid code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// OK: p + 1 is an rvalue, but *(p + 1) is an lvalue</span></span></pre></td></tr></table></figure>
<p>Conversely, the unary address-of operator ‘&amp;’ takes an lvalue argument and produces an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// ERROR: lvalue required as unary '&amp;' operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// OK: var is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// ERROR: lvalue required as left operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="comment">// of assignment</span></span></pre></td></tr></table></figure>
<p>The ampersand plays another role in C++ - it allows to define reference types. These are called “lvalue references”. Non-const lvalue references cannot be assigned rvalues, since that would require an invalid rvalue-to-lvalue conversion:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; sref = <span class="built_in">std</span>::<span class="built_in">string</span>();  <span class="comment">// ERROR: invalid initialization of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// non-const reference of type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// 'std::string&amp;' from an rvalue of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// type 'std::string'</span></span></pre></td></tr></table></figure>
<p>Constant lvalue references can be assigned rvalues. Since they’re constant, the value can’t be modified through the reference and hence there’s no problem of modifying an rvalue. This makes possible the very common C++ idiom of accepting values by constant references into functions, which avoids unnecessary copying and construction of temporary objects.</p>
<h4 id="cv-qualified-rvalues"><a class="markdownIt-Anchor" href="#cv-qualified-rvalues"></a> CV-qualified rvalues</h4>
<p>If we read carefully the portion of the C++ standard discussing lvalue-to-rvalue conversions [2], we notice it says:</p>
<blockquote>
<p>An lvalue (3.10) of a non-function, non-array type T can be converted to an rvalue. […] If T is a non-class type, the type of the rvalue is the cv-unqualified version of T. Otherwise, the type of the rvalue is T.</p>
</blockquote>
<p>What is this “cv-unqualified” thing? CV-qualifier is a term used to describe const and volatile type qualifiers.<br>
From section 3.9.3:</p>
<blockquote>
<p>Each type which is a cv-unqualified complete or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type: a const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. […] The cv-qualified or cv-unqualified versions of a type are distinct types; however, they shall have the same representation and alignment requirements (3.9)</p>
</blockquote>
<p>But what has this got to do with rvalues? Well, in C, rvalues never have cv-qualified types. Only lvalues do. In C++, on the other hand, class rvalues can have cv-qualified types, but built-in types (like int) can’t. Consider this example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bar().foo();  <span class="comment">// calls foo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cbar().foo(); <span class="comment">// calls foo const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>The second call in main actually calls the foo () const method of A, because the type returned by cbar is const A, which is distinct from A. This is exactly what’s meant by the last sentence in the quote mentioned earlier. Note also that the return value from cbar is an rvalue. So this is an example of a cv-qualified rvalue in action.</p>
<h4 id="rvalue-references-c11"><a class="markdownIt-Anchor" href="#rvalue-references-c11"></a> Rvalue references (C++11)</h4>
<p>Rvalue references and the related concept of move semantics is one of the most powerful new features the C++11 standard introduces to the language. A full discussion of the feature is way beyond the scope of this humble article [3], but I still want to provide a simple example, because I think it’s a good place to demonstrate how an understanding of what lvalues and rvalues are aids our ability to reason about non-trivial language concepts.</p>
<p>I’ve just spent a good part of this article explaining that one of the main differences between lvalues and rvalues is that lvalues can be modified, and rvalues can’t. Well, C++11 adds a crucial twist to this distinction, by allowing us to have references to rvalues and thus modify them, in some special circumstances.</p>
<p>As an example, consider a simplistic implementation of a dynamic “integer vector”. I’m showing just the relevant methods here:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intvec</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="keyword">size_t</span> num = <span class="number">0</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(num), m_data(new int[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Intvec()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"destructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span>[] m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(other.m_size), m_data(<span class="keyword">new</span> <span class="keyword">int</span>[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data[i] = other.m_data[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_data, tmp.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="string">"\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> m_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>So, we have the usual constructor, destructor, copy constructor and copy assignment operator [4] defined, all using a logging function to let us know when they’re actually called.</p>
<p>Let’s run some simple code, which copies the contents of v1 into v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Intvec v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning lvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning lvalue...\n"</span>;</span></pre></td></tr></table></figure>
<p>What this prints is:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning lvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning lvalue...</span></pre></td></tr></table></figure>
<p>Makes sense - this faithfully represents what’s going on inside operator=. But suppose that we want to assign some rvalue to v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning rvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = Intvec(<span class="number">33</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning rvalue...\n"</span>;</span></pre></td></tr></table></figure>
<p>Although here I just assign a freshly constructed vector, it’s just a demonstration of a more general case where some temporary rvalue is being built and then assigned to v2 (this can happen for some function returning a vector, for example). What gets printed now is this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>
<p>Ouch, this looks like a lot of work. In particular, it has one extra pair of constructor/destructor calls to create and then destroy the temporary object. And this is a shame, because inside the copy assignment operator, another temporary copy is being created and destroyed. That’s extra work, for nothing.</p>
<p>Well, no more. C++11 gives us rvalue references with which we can implement “move semantics”, and in particular a “move assignment operator” [5]. Let’s add another operator= to Intvec:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>The &amp;&amp; syntax is the new rvalue reference. It does exactly what it sounds it does - gives us a reference to an rvalue, which is going to be destroyed after the call. We can use this fact to just “steal” the internals of the rvalue - it won’t need them anyway! This prints:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] move assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>
<p>What happens here is that our new move assignment operator is invoked since an rvalue gets assigned to v2. The constructor and destructor calls are still needed for the temporary object that’s created by Intvec(33), but another temporary inside the assignment operator is no longer needed. The operator simply switches the rvalue’s internal buffer with its own, arranging it so the rvalue’s destructor will release our object’s own buffer, which is no longer used. Neat.</p>
<p>I’ll just mention once again that this example is only the tip of the iceberg on move semantics and rvalue references. As you can probably guess, it’s a complex subject with a lot of special cases and gotchas to consider. My point here was to demonstrate a very interesting application of the difference between lvalues and rvalues in C++. The compiler obviously knows when some entity is an rvalue, and can arrange to invoke the correct constructor at compile time.</p>
<h4 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h4>
<p>One can write a lot of C++ code without being concerned with the issue of rvalues vs. lvalues, dismissing them as weird compiler jargon in certain error messages. However, as this article aimed to show, getting a better grasp of this topic can aid in a deeper understanding of certain C++ code constructs, and make parts of the C++ spec and discussions between language experts more intelligible.</p>
<p>Also, in the new C++ spec this topic becomes even more important, because C++11’s introduction of rvalue references and move semantics. To really grok this new feature of the language, a solid understanding of what rvalues and lvalues are becomes crucial.</p>
<blockquote>
<ol>
<li>rvalues can be assigned to lvalues explicitly. The lack of implicit conversion means that rvalues cannot be used in places where lvalues are expected.</li>
<li>That’s section 4.1 in the new C++11 standard draft.</li>
<li>You can find a lot of material on this topic by simply googling “rvalue references”. Some resources I personally found useful: <a href="https://www.artima.com/cppsource/rvalue.html" target="_blank" rel="noopener">this one</a>, and <a href="https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11" target="_blank" rel="noopener">this one</a>, and especially <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">this one</a>.</li>
<li>This a canonical implementation of a copy assignment operator, from the point of view of exception safety. By using the copy constructor and then the non-throwing std::swap, it makes sure that no intermediate state with uninitialized memory can arise if exceptions are thrown.</li>
<li>So now you know why I was keeping referring to my operator= as “copy assignment operator”. In C++11, the distinction becomes important.</li>
</ol>
</blockquote>
<h3 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h3>
<blockquote>
<p>@Reference</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/c-language/l-value-and-r-value-expressions?view=vs-2019" target="_blank" rel="noopener">L-Value and R-Value Expressions</a></li>
<li><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/" target="_blank" rel="noopener">Understanding lvalues and rvalues in C and C++</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>中国古代道家文化简研</title>
    <url>/culture/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E9%81%93%E5%AE%B6%E6%96%87%E5%8C%96%E7%AE%80%E7%A0%94.html</url>
    <content><![CDATA[<h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3>
<a id="more"></a>
<h3 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h3>
]]></content>
      <categories>
        <category>中华文化</category>
      </categories>
      <tags>
        <tag>道家</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown guide and mdeditor</title>
    <url>/markdown/markdown-guide-and-mdeditor.html</url>
    <content><![CDATA[<pre><code>markdown 语法sample
</code></pre>
<hr>
<blockquote>
<p>Itatic And Bold Sample<br>
partial differential equasion***偏微分方程***<br>
常微分方程_<strong>是这样解开的</strong>_<br>
仰天大笑出门去，我辈岂是蓬蒿人</p>
</blockquote>
<hr>
<blockquote>
<h2 id="order-list-sample遇见冬天的离别"><a class="markdownIt-Anchor" href="#order-list-sample遇见冬天的离别"></a> Order List Sample<br>
遇见冬天的离别</h2>
<h2 id="孙燕姿的绿光"><a class="markdownIt-Anchor" href="#孙燕姿的绿光"></a> 孙燕姿的绿光</h2>
<ol>
<li>窗外的麻雀，消失在电线杆上</li>
<li>就是开不了口让她知道</li>
<li>断了的弦，再谈一遍</li>
<li>哪里跟那里<br>
1. 你的转变，想断掉的弦<br>
2. 你的美，已经追不回，追了又追我要不会<br>
3. 诶，小朋友在玩什么呀，</li>
<li>一波还未平息，一波早就过去</li>
</ol>
</blockquote>
<hr>
<a id="more"></a>
<blockquote>
<p>Unorder List Sample<br>
让我疯狂的可爱女人</p>
<ul>
<li>没有了联络，后来的生活，都是听别人说</li>
</ul>
<ul>
<li>你发如雪，凄美了离别，我等待苍老了谁</li>
</ul>
<ul>
<li>没有地球，太阳还是会绕</li>
</ul>
<ul>
<li>你的外没注意太彻底
<ul>
<li>彩虹</li>
<li>周杰伦作曲 方文山作词</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>Code Sample<br>
To denote a word or phrase as code, enclose it in tick marks (`).<br>
Atthecommandprompt,type<code>nano</code>.</p>
<pre><code> int a = 12 // code syntax require at lease 4 spaces on the left
</code></pre>
</blockquote>
<hr>
<h1 id="mdeditor-online-samples"><a class="markdownIt-Anchor" href="#mdeditor-online-samples"></a> MDEditor <a href="/editor/sample.html">Online Samples</a></h1>
<p><strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p><img alt="markdown" title="markdown" data-src="https://www.mdeditor.com/images/logos/markdown.png"></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<h2 id="mdeditor是一个在线编辑markdown文档的编辑器"><a class="markdownIt-Anchor" href="#mdeditor是一个在线编辑markdown文档的编辑器"></a> MdEditor是一个在线编辑Markdown文档的编辑器</h2>
<p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<s>Pandoc</s>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href="https://github.com/pandao/editor.md" target="_blank" rel="noopener" title="Editor.md">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p>
<p><img alt="Pandao editor.md" title="Pandao editor.md" data-src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png"></p>
<h2 id="mdeditor的功能列表演示"><a class="markdownIt-Anchor" href="#mdeditor的功能列表演示"></a> MdEditor的功能列表演示</h2>
<h1 id="标题h1"><a class="markdownIt-Anchor" href="#标题h1"></a> 标题H1</h1>
<h2 id="标题h2"><a class="markdownIt-Anchor" href="#标题h2"></a> 标题H2</h2>
<h3 id="标题h3"><a class="markdownIt-Anchor" href="#标题h3"></a> 标题H3</h3>
<h4 id="标题h4"><a class="markdownIt-Anchor" href="#标题h4"></a> 标题H4</h4>
<h5 id="标题h5"><a class="markdownIt-Anchor" href="#标题h5"></a> 标题H5</h5>
<h6 id="标题h5-2"><a class="markdownIt-Anchor" href="#标题h5-2"></a> 标题H5</h6>
<h3 id="字符效果和横线等"><a class="markdownIt-Anchor" href="#字符效果和横线等"></a> 字符效果和横线等</h3>
<hr>
<p><s>删除线</s> <s>删除线（开启识别HTML标签时）</s></p>
<p><em>斜体字</em>      <em>斜体字</em></p>
<p><strong>粗体</strong>  <strong>粗体</strong></p>
<p><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-blockquotes"><a class="markdownIt-Anchor" href="#引用-blockquotes"></a> 引用 Blockquotes</h3>
<blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-links"><a class="markdownIt-Anchor" href="#锚点与链接-links"></a> 锚点与链接 Links</h3>
<p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br>
<a href="https://www.mdeditor.com/" target="_blank" rel="noopener" title="普通链接带标题">普通链接带标题</a><br>
直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>
[锚点链接][anchor-id]<br>
[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br>
<a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">mailto:test.test@gmail.com</a><br>
GFM a-tail link @pandao<br>
邮箱地址自动链接 <a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com" target="_blank" rel="noopener">www@vip.qq.com</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-codes"><a class="markdownIt-Anchor" href="#多语言代码高亮-codes"></a> 多语言代码高亮 Codes</h3>
<h4 id="行内代码-inline-code"><a class="markdownIt-Anchor" href="#行内代码-inline-code"></a> 行内代码 Inline code</h4>
<p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a class="markdownIt-Anchor" href="#缩进风格"></a> 缩进风格</h4>
<p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;
</code></pre>
<p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |
</code></pre>
<h4 id="js代码"><a class="markdownIt-Anchor" href="#js代码"></a> JS代码</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="html-代码-html-codes"><a class="markdownIt-Anchor" href="#html-代码-html-codes"></a> HTML 代码 HTML codes</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">"Microsoft Yahei"</span>, Tahoma, <span class="string">"Hiragino Sans GB"</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>
<h3 id="图片-images"><a class="markdownIt-Anchor" href="#图片-images"></a> 图片 Images</h3>
<p>图片加链接 (Image + Link)：</p>
<p><a href="https://www.mdeditor.com/images/logos/markdown.png" target="_blank" rel="noopener" title="markdown"><img alt data-src="https://www.mdeditor.com/images/logos/markdown.png"></a></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-lists"><a class="markdownIt-Anchor" href="#列表-lists"></a> 列表 Lists</h3>
<h4 id="无序列表减号unordered-lists-"><a class="markdownIt-Anchor" href="#无序列表减号unordered-lists-"></a> 无序列表（减号）Unordered Lists (-)</h4>
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表星号unordered-lists"><a class="markdownIt-Anchor" href="#无序列表星号unordered-lists"></a> 无序列表（星号）Unordered Lists (*)</h4>
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表加号和嵌套unordered-lists"><a class="markdownIt-Anchor" href="#无序列表加号和嵌套unordered-lists"></a> 无序列表（加号和嵌套）Unordered Lists (+)</h4>
<ul>
<li>列表一</li>
<li>列表二
<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-ordered-lists-"><a class="markdownIt-Anchor" href="#有序列表-ordered-lists-"></a> 有序列表 Ordered Lists (-)</h4>
<ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="gfm-task-list"><a class="markdownIt-Anchor" href="#gfm-task-list"></a> GFM task list</h4>
<ul>
<li>[x] GFM task list 1</li>
<li>[x] GFM task list 2</li>
<li>[ ] GFM task list 3
<ul>
<li>[ ] GFM task list 3-1</li>
<li>[ ] GFM task list 3-2</li>
<li>[ ] GFM task list 3-3</li>
</ul>
</li>
<li>[ ] GFM task list 4
<ul>
<li>[ ] GFM task list 4-1</li>
<li>[ ] GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-tables"><a class="markdownIt-Anchor" href="#绘制表格-tables"></a> 绘制表格 Tables</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Left-Aligned</th>
<th style="text-align:center">Center Aligned</th>
<th style="text-align:right">Right Aligned</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Item</th>
<th style="text-align:right">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="特殊符号-html-entities-codes"><a class="markdownIt-Anchor" href="#特殊符号-html-entities-codes"></a> 特殊符号 HTML Entities Codes</h4>
<p>© &amp;  ¨ ™ ¡ £<br>
&amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « ·</p>
<p>X² Y³ ¾ ¼  ×  ÷   »</p>
<p>18ºC  &quot;  '</p>
<p>[========]</p>
<h3 id="emoji表情"><a class="markdownIt-Anchor" href="#emoji表情"></a> Emoji表情 😃</h3>
<blockquote>
<p>Blockquotes ⭐️</p>
</blockquote>
<h4 id="gfm-task-lists-emoji-fontawesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x"><a class="markdownIt-Anchor" href="#gfm-task-lists-emoji-fontawesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x"></a> GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4>
<ul>
<li>[x] 😃 @mentions, 😃 #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li>[x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li>[x] [ ] 😃 this is a complete item 😃;</li>
<li>[ ] []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li>[ ] [ ]this is an incomplete item :fa-star: :fa-gear:;
<ul>
<li>[ ] 😃 this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li>[ ] 😃 this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-escape"><a class="markdownIt-Anchor" href="#反斜杠-escape"></a> 反斜杠 Escape</h4>
<p>*literal asterisks*</p>
<p>[========]</p>
<h3 id="科学公式-texkatex"><a class="markdownIt-Anchor" href="#科学公式-texkatex"></a> 科学公式 TeX(KaTeX)</h3>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>行内的公式$$E=mc<sup>2$$行内的公式，行内的$$E=mc</sup>2$$公式。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x &gt; y
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p class="katex-block katex-error" title="ParseError: KaTeX parse error: Can&#039;t use function &#039;\(&#039; in math mode at position 1: \̲(̲\sqrt{3x-1}+(1+…">\(\sqrt{3x-1}+(1+x)^2\)
</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mi>θ</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msup><mi>x</mi><mi>i</mi></msup><mo>+</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>多行公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span></pre></td></tr><tr><td class="code"><pre><span class="line">\leq</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span></pre></td></tr><tr><td class="code"><pre><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \frac&#123;1&#125;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#123;1+\cdots&#125; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x) &#x3D; \int_&#123;-\infty&#125;^\infty</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    \,d\xi</span></pre></td></tr></table></figure>
<h3 id="分页符-page-break"><a class="markdownIt-Anchor" href="#分页符-page-break"></a> 分页符 Page break</h3>
<blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<p>[========]</p>
<h3 id="绘制流程图-flowchart"><a class="markdownIt-Anchor" href="#绘制流程图-flowchart"></a> 绘制流程图 Flowchart</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span></pre></td></tr><tr><td class="code"><pre><span class="line">op&#x3D;&gt;operation: 登陆操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 进入后台</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st-&gt;op-&gt;cond</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond(yes)-&gt;e</span></pre></td></tr><tr><td class="code"><pre><span class="line">cond(no)-&gt;op</span></pre></td></tr></table></figure>
<p>[========]</p>
<h3 id="绘制序列图-sequence-diagram"><a class="markdownIt-Anchor" href="#绘制序列图-sequence-diagram"></a> 绘制序列图 Sequence Diagram</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note right of China: China thinks\nabout it</span></pre></td></tr><tr><td class="code"><pre><span class="line">China--&gt;Andrew: How are you?</span></pre></td></tr><tr><td class="code"><pre><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span></pre></td></tr></table></figure>
<h3 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h3>
<blockquote>
<p>Go To <a href="/editor/">Online Editor</a><br>
See more samples from the <a href="https://www.markdownguide.org/assets/book/markdown-guide.pdf" target="_blank" rel="noopener" title="Ctrl/Command to open in new tab">official manual guide</a> with pdf</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
