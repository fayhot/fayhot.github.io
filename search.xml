<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>左值、右值表达式(LValue-And-RValue Expression)</title>
    <url>/program/lvalue-and-rvalue.html</url>
    <content><![CDATA[<h3 id="L-Value"><a href="#L-Value" class="headerlink" title="L-Value"></a>L-Value</h3><p>Expressions that refer to <strong>memory locations</strong> are called “l-value” expressions. An l-value represents a storage region’s “locator” value, or a “left” value, implying that it can appear on the left of the equal sign (=). L-values are often identifiers.</p>
<p>Expressions referring to <strong>modifiable locations</strong> are called “modifiable l-values.” A modifiable l-value cannot have an array type, an incomplete type, or a type with the <strong>const</strong> attribute. For structures and unions to be modifiable l-values, they must not have any members with the const attribute. The name of the identifier denotes a storage location, while the value of the variable is the value stored at that location.</p>
<p>An identifier is a modifiable l-value if it refers to a memory location and if its type is arithmetic, structure, union, or pointer. For example, if ptr is a pointer to a storage region, then <strong>*ptr</strong> is a modifiable l-value that designates the storage region to which ptr points.</p>
<p>Any of the following C expressions can be l-value expressions:</p>
<blockquote>
<ul>
<li>An identifier of integral, floating, pointer, structure, or union type</li>
<li>A subscript ([ ]) expression that does not evaluate to an array</li>
<li>A member-selection expression (-&gt; or .)</li>
<li>A unary-indirection (*) expression that does not refer to an array</li>
<li>An l-value expression in parentheses</li>
<li>A const object (a nonmodifiable l-value)</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="R-Value"><a href="#R-Value" class="headerlink" title="R-Value"></a>R-Value</h3><p>The term “r-value” is sometimes used to describe the value of an expression and to distinguish it from an l-value. All l-values are r-values but not all r-values are l-values.</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>The terms lvalue and rvalue are not something one runs into often in C/C++ programming, but when one does, it’s usually not immediately clear what they mean. The most common place to run into these terms are in compiler error &amp; warning messages. For example, compiling the following with gcc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>You get:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test.c: In function 'main':</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.c:<span class="number">8</span>:<span class="number">5</span>: error: lvalue required as left operand of assignment</span></pre></td></tr></table></figure>

<p>True, this code is somewhat perverse and not something you’d write, but the error message mentions lvalue, which is not a term one usually finds in C/C++ tutorials. Another example is compiling this code with g++:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Now the error is:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">testcpp.cpp: In function 'int&amp; foo()':</span></pre></td></tr><tr><td class="code"><pre><span class="line">testcpp.cpp:<span class="number">5</span>:<span class="number">12</span>: error: invalid initialization of non-<span class="keyword">const</span> reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">of type 'int&amp;' from an rvalue of type 'int'</span></pre></td></tr></table></figure>

<p>Here again, the error mentions some mysterious rvalue. So what do lvalue and rvalue mean in C and C++? This is what I intend to explore in this article.</p>
<h4 id="A-simple-definition"><a href="#A-simple-definition" class="headerlink" title="A simple definition"></a>A simple definition</h4><p>This section presents an intentionally simplified definition of lvalues and rvalues. The rest of the article will elaborate on this definition.</p>
<blockquote>
<p>An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address).</p>
</blockquote>
<blockquote>
<p>rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.</p>
</blockquote>
<h4 id="Basic-examples"><a href="#Basic-examples" class="headerlink" title="Basic examples"></a>Basic examples</h4><p>The terms as defined above may appear vague, which is why it’s important to see some simple examples right away.<br>Let’s assume we have an integer variable defined and assigned to:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var = <span class="number">4</span>;</span></pre></td></tr></table></figure>

<p>An assignment expects an lvalue as its left operand, and var is an lvalue, because it is an object with an identifiable memory location. On the other hand, the following are invalid:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> = var;       <span class="comment">// ERROR!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>; <span class="comment">// ERROR!</span></span></pre></td></tr></table></figure>

<p>Neither the constant 4, nor the expression var + 1 are lvalues (<strong>which makes them rvalues</strong>). They’re not lvalues because both are temporary results of expressions, which don’t have an identifiable memory location (i.e. they can just reside in some temporary register for the duration of the computation). Therefore, assigning to them makes no semantic sense - there’s nowhere to assign to.</p>
<p>So it should now be clear what the error message in the first code snippet means. foo returns a temporary value which is an rvalue. Attempting to assign to it is an error, so when seeing foo() = 2; the compiler complains that it expected to see an lvalue on the left-hand-side of the assignment statement.</p>
<p>Not all assignments to results of function calls are invalid, however. For example, C++ references make this possible:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalvar = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> globalvar;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foo() = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Here foo returns a reference, which is an lvalue, so it can be assigned to. Actually, the ability of C++ to return lvalues from functions is important for implementing some overloaded operators. One common example is overloading the brackets operator [] in classes that implement some kind of lookup access. std::map does this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; mymap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mymap[<span class="number">10</span>] = <span class="number">5.6</span>;</span></pre></td></tr></table></figure>

<p>The assignment mymap[10] works because the non-const overload of std::map::operator[] returns a reference that can be assigned to.</p>
<h4 id="Modifiable-lvalues"><a href="#Modifiable-lvalues" class="headerlink" title="Modifiable lvalues"></a>Modifiable lvalues</h4><p>Initially when lvalues were defined for C, it literally meant “values suitable for left-hand-side of assignment”. Later, however, when ISO C added the const keyword, this definition had to be refined. After all:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 'a' is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;           <span class="comment">// but it can't be assigned!</span></span></pre></td></tr></table></figure>

<p>So a further refinement had to be added. Not all lvalues can be assigned to. Those that can are called modifiable lvalues. Formally, the C99 standard defines modifiable lvalues as:</p>
<blockquote>
<p>[…] an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.</p>
</blockquote>
<h4 id="Conversions-between-lvalues-and-rvalues"><a href="#Conversions-between-lvalues-and-rvalues" class="headerlink" title="Conversions between lvalues and rvalues"></a>Conversions between lvalues and rvalues</h4><p>Generally speaking, language constructs operating on object values require rvalues as arguments. For example, the binary addition operator ‘+’ takes two rvalues as arguments and returns an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// + needs rvalues, so a and b are converted to rvalues</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="comment">// and an rvalue is returned</span></span></pre></td></tr></table></figure>

<p>As we’ve seen earlier, a and b are both lvalues. Therefore, in the third line, they undergo an implicit lvalue-to-rvalue conversion. All lvalues that aren’t arrays, functions or of incomplete types can be converted thus to rvalues.</p>
<p>What about the other direction? Can rvalues be converted to lvalues? Of course not! This would violate the very nature of an lvalue according to its definition [1].</p>
<p>This doesn’t mean that lvalues can’t be produced from rvalues by more explicit means. For example, the unary ‘*’ (dereference) operator takes an rvalue argument but produces an lvalue as a result. Consider this valid code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// OK: p + 1 is an rvalue, but *(p + 1) is an lvalue</span></span></pre></td></tr></table></figure>

<p>Conversely, the unary address-of operator ‘&amp;’ takes an lvalue argument and produces an rvalue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// ERROR: lvalue required as unary '&amp;' operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// OK: var is an lvalue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// ERROR: lvalue required as left operand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="comment">// of assignment</span></span></pre></td></tr></table></figure>

<p>The ampersand plays another role in C++ - it allows to define reference types. These are called “lvalue references”. Non-const lvalue references cannot be assigned rvalues, since that would require an invalid rvalue-to-lvalue conversion:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; sref = <span class="built_in">std</span>::<span class="built_in">string</span>();  <span class="comment">// ERROR: invalid initialization of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// non-const reference of type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// 'std::string&amp;' from an rvalue of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    <span class="comment">// type 'std::string'</span></span></pre></td></tr></table></figure>

<p>Constant lvalue references can be assigned rvalues. Since they’re constant, the value can’t be modified through the reference and hence there’s no problem of modifying an rvalue. This makes possible the very common C++ idiom of accepting values by constant references into functions, which avoids unnecessary copying and construction of temporary objects.</p>
<h4 id="CV-qualified-rvalues"><a href="#CV-qualified-rvalues" class="headerlink" title="CV-qualified rvalues"></a>CV-qualified rvalues</h4><p>If we read carefully the portion of the C++ standard discussing lvalue-to-rvalue conversions [2], we notice it says:</p>
<blockquote>
<p>An lvalue (3.10) of a non-function, non-array type T can be converted to an rvalue. […] If T is a non-class type, the type of the rvalue is the cv-unqualified version of T. Otherwise, the type of the rvalue is T.</p>
</blockquote>
<p>What is this “cv-unqualified” thing? CV-qualifier is a term used to describe const and volatile type qualifiers.<br>From section 3.9.3:</p>
<blockquote>
<p>Each type which is a cv-unqualified complete or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type: a const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. […] The cv-qualified or cv-unqualified versions of a type are distinct types; however, they shall have the same representation and alignment requirements (3.9)</p>
</blockquote>
<p>But what has this got to do with rvalues? Well, in C, rvalues never have cv-qualified types. Only lvalues do. In C++, on the other hand, class rvalues can have cv-qualified types, but built-in types (like int) can’t. Consider this example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bar().foo();  <span class="comment">// calls foo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cbar().foo(); <span class="comment">// calls foo const</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The second call in main actually calls the foo () const method of A, because the type returned by cbar is const A, which is distinct from A. This is exactly what’s meant by the last sentence in the quote mentioned earlier. Note also that the return value from cbar is an rvalue. So this is an example of a cv-qualified rvalue in action.</p>
<h4 id="Rvalue-references-C-11"><a href="#Rvalue-references-C-11" class="headerlink" title="Rvalue references (C++11)"></a>Rvalue references (C++11)</h4><p>Rvalue references and the related concept of move semantics is one of the most powerful new features the C++11 standard introduces to the language. A full discussion of the feature is way beyond the scope of this humble article [3], but I still want to provide a simple example, because I think it’s a good place to demonstrate how an understanding of what lvalues and rvalues are aids our ability to reason about non-trivial language concepts.</p>
<p>I’ve just spent a good part of this article explaining that one of the main differences between lvalues and rvalues is that lvalues can be modified, and rvalues can’t. Well, C++11 adds a crucial twist to this distinction, by allowing us to have references to rvalues and thus modify them, in some special circumstances.</p>
<p>As an example, consider a simplistic implementation of a dynamic “integer vector”. I’m showing just the relevant methods here:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intvec</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="keyword">size_t</span> num = <span class="number">0</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(num), m_data(new int[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Intvec()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"destructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span>[] m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        : m_size(other.m_size), m_data(<span class="keyword">new</span> <span class="keyword">int</span>[m_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy constructor"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m_data[i] = other.m_data[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Intvec&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::swap(m_data, tmp.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="string">"\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> m_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>* m_data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>So, we have the usual constructor, destructor, copy constructor and copy assignment operator [4] defined, all using a logging function to let us know when they’re actually called.</p>
<p>Let’s run some simple code, which copies the contents of v1 into v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Intvec v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning lvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning lvalue...\n"</span>;</span></pre></td></tr></table></figure>

<p>What this prints is:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning lvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning lvalue...</span></pre></td></tr></table></figure>

<p>Makes sense - this faithfully represents what’s going on inside operator=. But suppose that we want to assign some rvalue to v2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning rvalue...\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 = Intvec(<span class="number">33</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning rvalue...\n"</span>;</span></pre></td></tr></table></figure>

<p>Although here I just assign a freshly constructed vector, it’s just a demonstration of a more general case where some temporary rvalue is being built and then assigned to v2 (this can happen for some function returning a vector, for example). What gets printed now is this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fec8</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>
<p>Ouch, this looks like a lot of work. In particular, it has one extra pair of constructor/destructor calls to create and then destroy the temporary object. And this is a shame, because inside the copy assignment operator, another temporary copy is being created and destroyed. That’s extra work, for nothing.</p>
<p>Well, no more. C++11 gives us rvalue references with which we can implement “move semantics”, and in particular a “move assignment operator” [5]. Let’s add another operator= to Intvec:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The &amp;&amp; syntax is the new rvalue reference. It does exactly what it sounds it does - gives us a reference to an rvalue, which is going to be destroyed after the call. We can use this fact to just “steal” the internals of the rvalue - it won’t need them anyway! This prints:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28fef8</span>] move assignment <span class="keyword">operator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">0x28ff08</span>] destructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">ended assigning rvalue...</span></pre></td></tr></table></figure>

<p>What happens here is that our new move assignment operator is invoked since an rvalue gets assigned to v2. The constructor and destructor calls are still needed for the temporary object that’s created by Intvec(33), but another temporary inside the assignment operator is no longer needed. The operator simply switches the rvalue’s internal buffer with its own, arranging it so the rvalue’s destructor will release our object’s own buffer, which is no longer used. Neat.</p>
<p>I’ll just mention once again that this example is only the tip of the iceberg on move semantics and rvalue references. As you can probably guess, it’s a complex subject with a lot of special cases and gotchas to consider. My point here was to demonstrate a very interesting application of the difference between lvalues and rvalues in C++. The compiler obviously knows when some entity is an rvalue, and can arrange to invoke the correct constructor at compile time.</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>One can write a lot of C++ code without being concerned with the issue of rvalues vs. lvalues, dismissing them as weird compiler jargon in certain error messages. However, as this article aimed to show, getting a better grasp of this topic can aid in a deeper understanding of certain C++ code constructs, and make parts of the C++ spec and discussions between language experts more intelligible.</p>
<p>Also, in the new C++ spec this topic becomes even more important, because C++11’s introduction of rvalue references and move semantics. To really grok this new feature of the language, a solid understanding of what rvalues and lvalues are becomes crucial.</p>
<blockquote>
<ol>
<li>rvalues can be assigned to lvalues explicitly. The lack of implicit conversion means that rvalues cannot be used in places where lvalues are expected.</li>
<li>That’s section 4.1 in the new C++11 standard draft.</li>
<li>You can find a lot of material on this topic by simply googling “rvalue references”. Some resources I personally found useful: <a href="https://www.artima.com/cppsource/rvalue.html" target="_blank" rel="noopener">this one</a>, and <a href="https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11" target="_blank" rel="noopener">this one</a>, and especially <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">this one</a>.</li>
<li>This a canonical implementation of a copy assignment operator, from the point of view of exception safety. By using the copy constructor and then the non-throwing std::swap, it makes sure that no intermediate state with uninitialized memory can arise if exceptions are thrown.</li>
<li>So now you know why I was keeping referring to my operator= as “copy assignment operator”. In C++11, the distinction becomes important.</li>
</ol>
</blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>@Reference</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/c-language/l-value-and-r-value-expressions?view=vs-2019" target="_blank" rel="noopener">L-Value and R-Value Expressions</a></li>
<li><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/" target="_blank" rel="noopener">Understanding lvalues and rvalues in C and C++</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>前馈神经网络(Feedforward Neural Network)</title>
    <url>/pytorch/tutorial-feedforward-neural-network.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络(Convolutional Neural Network)</title>
    <url>/pytorch/tutorial-convolutional-neural-network.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归 (Logistic Regression)</title>
    <url>/pytorch/tutorial-logistic-regression-03.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归 (Linear Regression)</title>
    <url>/pytorch/tutorial-linear-regression.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><a id="more"></a>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch基础</title>
    <url>/pytorch/tutorial-basic-01.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><a id="more"></a>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown-guide</title>
    <url>/markdown/markdown-guide.html</url>
    <content><![CDATA[<pre><code>markdown 语法sample</code></pre><blockquote>
<p>Heading rule by <strong>#</strong> repeats<br>alternate<br> “== 表示#<br> “–” 表示 ##</p>
</blockquote>
<h1 id="heading-level-1"><a href="#heading-level-1" class="headerlink" title="heading level 1"></a>heading level 1</h1><h2 id="heading-level-2"><a href="#heading-level-2" class="headerlink" title="heading level 2"></a>heading level 2</h2><h3 id="heading-level-3"><a href="#heading-level-3" class="headerlink" title="heading level 3"></a>heading level 3</h3><h4 id="heading-level4"><a href="#heading-level4" class="headerlink" title="heading level4"></a>heading level4</h4><h5 id="heading-level-5"><a href="#heading-level-5" class="headerlink" title="heading level 5"></a>heading level 5</h5><h6 id="heading-level-6"><a href="#heading-level-6" class="headerlink" title="heading level 6"></a>heading level 6</h6><p>####### headiing level 7 is out of rule</p>
<a id="more"></a>

<blockquote>
<p>分割线使用，上下留白，至少重复三次 _</p>
</blockquote>
<hr>
<blockquote>
<p>Itatic And Bold Sample<br>partial differential equasion<strong><em>偏微分方程</em></strong><br>常微分方程<em><strong>是这样解开的</strong></em><br>仰天大笑出门去，我辈岂是蓬蒿人  </p>
</blockquote>
<hr>
<blockquote>
<p>Order List Sample<br>遇见冬天的离别<br>–<br>孙燕姿的绿光<br>–</p>
<ol>
<li>窗外的麻雀，消失在电线杆上</li>
<li>就是开不了口让她知道</li>
<li>断了的弦，再谈一遍</li>
<li>哪里跟那里<ol>
<li>你的转变，想断掉的弦</li>
<li>你的美，已经追不回，追了又追我要不会</li>
<li>诶，小朋友在玩什么呀，</li>
</ol>
</li>
<li>一波还未平息，一波早就过去</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>Unorder List Sample<br>让我疯狂的可爱女人</p>
<ul>
<li>没有了联络，后来的生活，都是听别人说</li>
</ul>
<ul>
<li>你发如雪，凄美了离别，我等待苍老了谁</li>
</ul>
<ul>
<li>没有地球，太阳还是会绕</li>
</ul>
<ul>
<li>你的外没注意太彻底<ul>
<li>彩虹</li>
<li>周杰伦作曲 方文山作词</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>Code Sample<br> To denote a word or phrase as code, enclose it in tick marks (`).<br> Atthecommandprompt,type<code>nano</code>.</p>
<pre><code>int a = 12 // code syntax require at lease 4 spaces on the left</code></pre></blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>See more samples from the <a href="https://www.markdownguide.org/assets/book/markdown-guide.pdf" target="_blank" rel="noopener" title="Ctrl/Command to open in new tab">official manual guide</a> with pdf</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
